import Combine
import CoreFoundation
import Darwin
import Darwin.sysdir
import Darwin.uuid
import Dispatch
import Foundation.FoundationErrors
import Foundation.FoundationLegacySwiftCompatibility
import Foundation.NSArray
import Foundation.NSAttributedString
import Foundation.NSAutoreleasePool
import Foundation.NSBundle
import Foundation.NSByteCountFormatter
import Foundation.NSByteOrder
import Foundation.NSCache
import Foundation.NSCalendar
import Foundation.NSCharacterSet
import Foundation.NSCoder
import Foundation.NSComparisonPredicate
import Foundation.NSCompoundPredicate
import Foundation.NSData
import Foundation.NSDate
import Foundation.NSDateComponentsFormatter
import Foundation.NSDateFormatter
import Foundation.NSDateInterval
import Foundation.NSDateIntervalFormatter
import Foundation.NSDecimal
import Foundation.NSDecimalNumber
import Foundation.NSDictionary
import Foundation.NSEnergyFormatter
import Foundation.NSEnumerator
import Foundation.NSError
import Foundation.NSException
import Foundation.NSExpression
import Foundation.NSExtensionContext
import Foundation.NSExtensionItem
import Foundation.NSExtensionRequestHandling
import Foundation.NSFileCoordinator
import Foundation.NSFileHandle
import Foundation.NSFileManager
import Foundation.NSFilePresenter
import Foundation.NSFileVersion
import Foundation.NSFileWrapper
import Foundation.NSFormatter
import Foundation.NSHTTPCookie
import Foundation.NSHTTPCookieStorage
import Foundation.NSHashTable
import Foundation.NSISO8601DateFormatter
import Foundation.NSIndexPath
import Foundation.NSIndexSet
import Foundation.NSInflectionRule
import Foundation.NSInvocation
import Foundation.NSItemProvider
import Foundation.NSJSONSerialization
import Foundation.NSKeyValueCoding
import Foundation.NSKeyValueObserving
import Foundation.NSKeyValueSharedObservers
import Foundation.NSKeyedArchiver
import Foundation.NSLengthFormatter
import Foundation.NSLinguisticTagger
import Foundation.NSListFormatter
import Foundation.NSLocale
import Foundation.NSLocalizedNumberFormatRule
import Foundation.NSLock
import Foundation.NSMapTable
import Foundation.NSMassFormatter
import Foundation.NSMeasurement
import Foundation.NSMeasurementFormatter
import Foundation.NSMetadata
import Foundation.NSMetadataAttributes
import Foundation.NSMethodSignature
import Foundation.NSMorphology
import Foundation.NSNetServices
import Foundation.NSNotification
import Foundation.NSNotificationQueue
import Foundation.NSNull
import Foundation.NSNumberFormatter
import Foundation.NSObjCRuntime
import Foundation.NSObject
import Foundation.NSOperation
import Foundation.NSOrderedCollectionChange
import Foundation.NSOrderedCollectionDifference
import Foundation.NSOrderedSet
import Foundation.NSOrthography
import Foundation.NSPathUtilities
import Foundation.NSPersonNameComponents
import Foundation.NSPersonNameComponentsFormatter
import Foundation.NSPointerArray
import Foundation.NSPointerFunctions
import Foundation.NSPort
import Foundation.NSPredicate
import Foundation.NSProcessInfo
import Foundation.NSProgress
import Foundation.NSPropertyList
import Foundation.NSProxy
import Foundation.NSRange
import Foundation.NSRegularExpression
import Foundation.NSRelativeDateTimeFormatter
import Foundation.NSRunLoop
import Foundation.NSScanner
import Foundation.NSSet
import Foundation.NSSortDescriptor
import Foundation.NSStream
import Foundation.NSString
import Foundation.NSTermOfAddress
import Foundation.NSTextCheckingResult
import Foundation.NSThread
import Foundation.NSTimeZone
import Foundation.NSTimer
import Foundation.NSURL
import Foundation.NSURLAuthenticationChallenge
import Foundation.NSURLCache
import Foundation.NSURLConnection
import Foundation.NSURLCredential
import Foundation.NSURLCredentialStorage
import Foundation.NSURLError
import Foundation.NSURLProtectionSpace
import Foundation.NSURLProtocol
import Foundation.NSURLRequest
import Foundation.NSURLResponse
import Foundation.NSURLSession
import Foundation.NSUUID
import Foundation.NSUbiquitousKeyValueStore
import Foundation.NSUndoManager
import Foundation.NSUnit
import Foundation.NSUserActivity
import Foundation.NSUserDefaults
import Foundation.NSValue
import Foundation.NSValueTransformer
import Foundation.NSXMLParser
import Foundation.NSXPCConnection
import Foundation.NSZone
import ObjectiveC
import Observation
import System

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncCharacterSequence<Base> : AsyncSequence where Base : AsyncSequence, Base.Element == UInt8 {

    /// The type of element produced by this asynchronous sequence.
    public typealias Element = Character

    /// The type of asynchronous iterator that produces elements of this
    /// asynchronous sequence.
    @frozen public struct AsyncIterator : AsyncIteratorProtocol {

        /// Asynchronously advances to the next element and returns it, or ends the
        /// sequence if there is no next element.
        ///
        /// - Returns: The next element, if it exists, or `nil` to signal the end of
        ///   the sequence.
        @inlinable public mutating func next() async rethrows -> Character?

        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Element = Character
    }

    /// Creates the asynchronous iterator that produces elements of this
    /// asynchronous sequence.
    ///
    /// - Returns: An instance of the `AsyncIterator` type used to produce
    /// elements of the asynchronous sequence.
    public func makeAsyncIterator() -> AsyncCharacterSequence<Base>.AsyncIterator
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncCharacterSequence : Sendable where Base : Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncCharacterSequence.AsyncIterator : Sendable where Base.AsyncIterator : Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncLineSequence<Base> : AsyncSequence where Base : AsyncSequence, Base.Element == UInt8 {

    /// The type of element produced by this asynchronous sequence.
    public typealias Element = String

    /// The type of asynchronous iterator that produces elements of this
    /// asynchronous sequence.
    public struct AsyncIterator : AsyncIteratorProtocol {

        public typealias Element = String

        /// Asynchronously advances to the next element and returns it, or ends the
        /// sequence if there is no next element.
        ///
        /// - Returns: The next element, if it exists, or `nil` to signal the end of
        ///   the sequence.
        public mutating func next() async rethrows -> String?
    }

    /// Creates the asynchronous iterator that produces elements of this
    /// asynchronous sequence.
    ///
    /// - Returns: An instance of the `AsyncIterator` type used to produce
    /// elements of the asynchronous sequence.
    public func makeAsyncIterator() -> AsyncLineSequence<Base>.AsyncIterator
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncLineSequence : Sendable where Base : Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncLineSequence.AsyncIterator : Sendable where Base.AsyncIterator : Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct AsyncUnicodeScalarSequence<Base> : AsyncSequence where Base : AsyncSequence, Base.Element == UInt8 {

    /// The type of element produced by this asynchronous sequence.
    public typealias Element = UnicodeScalar

    /// The type of asynchronous iterator that produces elements of this
    /// asynchronous sequence.
    @frozen public struct AsyncIterator : AsyncIteratorProtocol {

        /// Asynchronously advances to the next element and returns it, or ends the
        /// sequence if there is no next element.
        ///
        /// - Returns: The next element, if it exists, or `nil` to signal the end of
        ///   the sequence.
        @inlinable public mutating func next() async rethrows -> UnicodeScalar?

        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Element = UnicodeScalar
    }

    /// Creates the asynchronous iterator that produces elements of this
    /// asynchronous sequence.
    ///
    /// - Returns: An instance of the `AsyncIterator` type used to produce
    /// elements of the asynchronous sequence.
    public func makeAsyncIterator() -> AsyncUnicodeScalarSequence<Base>.AsyncIterator
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncUnicodeScalarSequence : Sendable where Base : Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncUnicodeScalarSequence.AsyncIterator : Sendable where Base.AsyncIterator : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributeContainer : Sendable {

    public init()
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer {

    @preconcurrency public subscript<T>(_: T.Type) -> T.Value? where T : AttributedStringKey, T.Value : Sendable

    @preconcurrency @inlinable public subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey, K.Value : Sendable

    public subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope

    public static subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> AttributeContainer.Builder<K> where K : AttributedStringKey { get }

    public subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> AttributeContainer.Builder<K> where K : AttributedStringKey { get }

    public struct Builder<T> : Sendable where T : AttributedStringKey {

        @preconcurrency public func callAsFunction(_ value: T.Value) -> AttributeContainer where T.Value : Sendable
    }

    public mutating func merge(_ other: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew)

    public func merging(_ other: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew) -> AttributeContainer
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: AttributeContainer, b: AttributeContainer) -> Bool
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributeContainer : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributeContainer {

    /// Returns a copy of the attribute container with only attributes that specify the provided inheritance behavior.
    /// - Parameter inheritedByAddedText: An `inheritedByAddedText` value to filter. Attributes matching this value are included in the returned container.
    /// - Returns: A copy of the attribute container with only attributes whose `inheritedByAddedText` property matches the provided value.
    public func filter(inheritedByAddedText: Bool) -> AttributeContainer

    /// Returns a copy of the attribute container with only attributes that have the provided run boundaries.
    /// - Parameter runBoundaries: The required `runBoundaries` value of the filtered attributes. If `nil` is provided, only attributes not bound to any specific boundary will be returned.
    /// - Returns: A copy of the attribute container with only attributes whose `runBoundaries` property matches the provided value.
    public func filter(runBoundaries: AttributedString.AttributeRunBoundaries?) -> AttributeContainer
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer : CodableWithConfiguration {

    public func encode(to encoder: any Encoder, configuration: AttributeScopeCodableConfiguration) throws

    public init(from decoder: any Decoder, configuration: AttributeScopeCodableConfiguration) throws

    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias DecodingConfiguration = AttributeScopeCodableConfiguration

    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias EncodingConfiguration = AttributeScopeCodableConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeContainer {

    public init(_ dictionary: [NSAttributedString.Key : Any])

    public init<S>(_ dictionary: [NSAttributedString.Key : Any], including scope: KeyPath<AttributeScopes, S.Type>) throws where S : AttributeScope

    public init<S>(_ dictionary: [NSAttributedString.Key : Any], including scope: S.Type) throws where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup @frozen public enum AttributeDynamicLookup {

    public subscript<T>(_: T.Type) -> T where T : AttributedStringKey { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeDynamicLookup {

    public subscript<T>(dynamicMember keyPath: KeyPath<AttributeScopes.FoundationAttributes, T>) -> T where T : AttributedStringKey { get }

    public subscript<T>(dynamicMember keyPath: KeyPath<AttributeScopes.FoundationAttributes.NumberFormatAttributes, T>) -> T where T : AttributedStringKey { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public subscript<T>(dynamicMember keyPath: KeyPath<AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes, T>) -> T where T : AttributedStringKey { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeDynamicLookup : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributeScope : DecodingConfigurationProviding, EncodingConfigurationProviding {

    static var decodingConfiguration: AttributeScopeCodableConfiguration { get }

    static var encodingConfiguration: AttributeScopeCodableConfiguration { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScope {

    public static var encodingConfiguration: AttributeScopeCodableConfiguration { get }

    public static var decodingConfiguration: AttributeScopeCodableConfiguration { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScope {

    /// A list of all attribute keys contained within this scope and any sub-scopes.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public static var attributeKeys: some Sequence<any AttributedStringKey.Type> { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public struct AttributeScopeCodableConfiguration : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@frozen public enum AttributeScopes {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes {

    public var foundation: AttributeScopes.FoundationAttributes.Type { get }

    public struct FoundationAttributes : AttributeScope {

        public let link: AttributeScopes.FoundationAttributes.LinkAttribute

        public let languageIdentifier: AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute

        public let personNameComponent: AttributeScopes.FoundationAttributes.PersonNameComponentAttribute

        public let numberFormat: AttributeScopes.FoundationAttributes.NumberFormatAttributes

        public let dateField: AttributeScopes.FoundationAttributes.DateFieldAttribute

        public let alternateDescription: AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute

        public let imageURL: AttributeScopes.FoundationAttributes.ImageURLAttribute

        public let replacementIndex: AttributeScopes.FoundationAttributes.ReplacementIndexAttribute

        public let measurement: AttributeScopes.FoundationAttributes.MeasurementAttribute

        public let byteCount: AttributeScopes.FoundationAttributes.ByteCountAttribute

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        public let durationField: AttributeScopes.FoundationAttributes.DurationFieldAttribute

        /// The base writing direction of a paragraph.
        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        public let writingDirection: AttributeScopes.FoundationAttributes.WritingDirectionAttribute

        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public let agreementConcept: AttributeScopes.FoundationAttributes.AgreementConceptAttribute

        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public let agreementArgument: AttributeScopes.FoundationAttributes.AgreementArgumentAttribute

        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public let referentConcept: AttributeScopes.FoundationAttributes.ReferentConceptAttribute

        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        public let localizedNumberFormat: AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute

        public let inlinePresentationIntent: AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute

        public let presentationIntent: AttributeScopes.FoundationAttributes.PresentationIntentAttribute

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        public let markdownSourcePosition: AttributeScopes.FoundationAttributes.MarkdownSourcePositionAttribute

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        public let listItemDelimiter: AttributeScopes.FoundationAttributes.ListItemDelimiterAttribute

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        public let localizedStringArgumentAttributes: AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes

        public let inflectionAlternative: AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute

        public let morphology: AttributeScopes.FoundationAttributes.MorphologyAttribute

        public let inflect: AttributeScopes.FoundationAttributes.InflectionRuleAttribute

        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias DecodingConfiguration = AttributeScopeCodableConfiguration

        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias EncodingConfiguration = AttributeScopeCodableConfiguration
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes {

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum LinkAttribute : CodableAttributedStringKey {

        public typealias Value = URL

        public static var name: String
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    @frozen public enum ReferentConceptAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {

        public typealias Value = Int

        public static let name: String

        public static let markdownName: String
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    @frozen public enum AgreementConceptAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {

        public typealias Value = Int

        public static let name: String

        public static let markdownName: String
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    @frozen public enum AgreementArgumentAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {

        public typealias Value = Int

        public static let name: String

        public static let markdownName: String
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum MorphologyAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {

        public typealias Value = Morphology

        public static let name: String

        public static let markdownName: String
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum InflectionRuleAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {

        public typealias Value = InflectionRule

        public static let name: String

        public static let markdownName: String
    }

    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    @frozen public enum LocalizedNumberFormatAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey {

        public struct Value : Equatable, Hashable, Codable, Sendable {

            public static var automatic: AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value, b: AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute.Value) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public static let name: String

        public static let markdownName: String
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum LanguageIdentifierAttribute : CodableAttributedStringKey {

        public typealias Value = String

        public static let name: String
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum PersonNameComponentAttribute : CodableAttributedStringKey {

        public typealias Value = AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component

        public static let name: String

        public enum Component : String, Codable, Sendable {

            case givenName

            case familyName

            case middleName

            case namePrefix

            case nameSuffix

            case nickname

            case delimiter

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: String)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
            public typealias RawValue = String

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: String { get }
        }
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public struct NumberFormatAttributes : AttributeScope {

        public let numberSymbol: AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute

        public let numberPart: AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute

        @frozen public enum NumberPartAttribute : CodableAttributedStringKey {

            public enum NumberPart : Int, Codable, Sendable {

                case integer

                case fraction

                /// Creates a new instance with the specified raw value.
                ///
                /// If there is no value of the type that corresponds with the specified raw
                /// value, this initializer returns `nil`. For example:
                ///
                ///     enum PaperSize: String {
                ///         case A4, A5, Letter, Legal
                ///     }
                ///
                ///     print(PaperSize(rawValue: "Legal"))
                ///     // Prints "Optional(PaperSize.Legal)"
                ///
                ///     print(PaperSize(rawValue: "Tabloid"))
                ///     // Prints "nil"
                ///
                /// - Parameter rawValue: The raw value to use for the new instance.
                public init?(rawValue: Int)

                /// The raw type that can be used to represent all values of the conforming
                /// type.
                ///
                /// Every distinct value of the conforming type has a corresponding unique
                /// value of the `RawValue` type, but there may be values of the `RawValue`
                /// type that don't have a corresponding value of the conforming type.
                @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
                public typealias RawValue = Int

                /// The corresponding value of the raw type.
                ///
                /// A new instance initialized with `rawValue` will be equivalent to this
                /// instance. For example:
                ///
                ///     enum PaperSize: String {
                ///         case A4, A5, Letter, Legal
                ///     }
                ///
                ///     let selectedSize = PaperSize.Letter
                ///     print(selectedSize.rawValue)
                ///     // Prints "Letter"
                ///
                ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
                ///     // Prints "true"
                public var rawValue: Int { get }
            }

            public static let name: String

            public typealias Value = AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart
        }

        @frozen public enum SymbolAttribute : CodableAttributedStringKey {

            public enum Symbol : Int, Codable, Sendable {

                case groupingSeparator

                case sign

                case decimalSeparator

                case currency

                case percent

                /// Creates a new instance with the specified raw value.
                ///
                /// If there is no value of the type that corresponds with the specified raw
                /// value, this initializer returns `nil`. For example:
                ///
                ///     enum PaperSize: String {
                ///         case A4, A5, Letter, Legal
                ///     }
                ///
                ///     print(PaperSize(rawValue: "Legal"))
                ///     // Prints "Optional(PaperSize.Legal)"
                ///
                ///     print(PaperSize(rawValue: "Tabloid"))
                ///     // Prints "nil"
                ///
                /// - Parameter rawValue: The raw value to use for the new instance.
                public init?(rawValue: Int)

                /// The raw type that can be used to represent all values of the conforming
                /// type.
                ///
                /// Every distinct value of the conforming type has a corresponding unique
                /// value of the `RawValue` type, but there may be values of the `RawValue`
                /// type that don't have a corresponding value of the conforming type.
                @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
                public typealias RawValue = Int

                /// The corresponding value of the raw type.
                ///
                /// A new instance initialized with `rawValue` will be equivalent to this
                /// instance. For example:
                ///
                ///     enum PaperSize: String {
                ///         case A4, A5, Letter, Legal
                ///     }
                ///
                ///     let selectedSize = PaperSize.Letter
                ///     print(selectedSize.rawValue)
                ///     // Prints "Letter"
                ///
                ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
                ///     // Prints "true"
                public var rawValue: Int { get }
            }

            public static let name: String

            public typealias Value = AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol
        }

        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias DecodingConfiguration = AttributeScopeCodableConfiguration

        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias EncodingConfiguration = AttributeScopeCodableConfiguration
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum DateFieldAttribute : CodableAttributedStringKey {

        public enum Field : Hashable, Codable, Sendable {

            case era

            case year

            /// For non-Gregorian calendars, this corresponds to the extended Gregorian year in which the calendar’s year begins.
            case relatedGregorianYear

            case quarter

            case month

            case weekOfYear

            case weekOfMonth

            case weekday

            /// The ordinal position of the weekday unit within the month unit. For example, `2` in "2nd Wednesday in July"
            case weekdayOrdinal

            case day

            case dayOfYear

            case amPM

            case hour

            case minute

            case second

            case secondFraction

            case timeZone

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: AttributeScopes.FoundationAttributes.DateFieldAttribute.Field, b: AttributeScopes.FoundationAttributes.DateFieldAttribute.Field) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public static let name: String

        public typealias Value = AttributeScopes.FoundationAttributes.DateFieldAttribute.Field
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum InflectionAlternativeAttribute : CodableAttributedStringKey, MarkdownDecodableAttributedStringKey, ObjectiveCConvertibleAttributedStringKey {

        public typealias Value = AttributedString

        public typealias ObjectiveCValue = NSObject

        public static let name: String

        public static let markdownName: String

        public static func decodeMarkdown(from decoder: any Decoder) throws -> AttributedString

        public static func objectiveCValue(for value: AttributedString) throws -> NSObject

        public static func value(for object: NSObject) throws -> AttributedString
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum InlinePresentationIntentAttribute : CodableAttributedStringKey, ObjectiveCConvertibleAttributedStringKey {

        public typealias Value = InlinePresentationIntent

        public typealias ObjectiveCValue = NSNumber

        public static let name: String

        public static func objectiveCValue(for value: InlinePresentationIntent) throws -> NSNumber

        public static func value(for object: NSNumber) throws -> InlinePresentationIntent
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum PresentationIntentAttribute : CodableAttributedStringKey {

        public typealias Value = PresentationIntent

        public static let name: String
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @frozen public enum MarkdownSourcePositionAttribute : CodableAttributedStringKey {

        public static let name: String

        public typealias Value = AttributedString.MarkdownSourcePosition
    }

    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    @frozen public enum ListItemDelimiterAttribute : CodableAttributedStringKey, ObjectiveCConvertibleAttributedStringKey {

        public typealias Value = Character

        public typealias ObjectiveCValue = NSString

        public static let name: String

        public static func objectiveCValue(for value: Character) throws -> NSString

        public static func value(for object: NSString) throws -> Character

        public static func encode(_ value: Character, to encoder: any Encoder) throws

        public static func decode(from decoder: any Decoder) throws -> Character
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum AlternateDescriptionAttribute : CodableAttributedStringKey {

        public typealias Value = String

        public static let name: String
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum ImageURLAttribute : CodableAttributedStringKey {

        public typealias Value = URL

        public static let name: String
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum ReplacementIndexAttribute : CodableAttributedStringKey {

        public typealias Value = Int

        public static let name: String
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public struct MeasurementAttribute : CodableAttributedStringKey {

        public typealias Value = AttributeScopes.FoundationAttributes.MeasurementAttribute.Component

        public static let name: String

        public enum Component : Int, Codable, Sendable {

            case value

            case unit

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: Int)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
            public typealias RawValue = Int

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: Int { get }
        }
    }

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @frozen public enum ByteCountAttribute : CodableAttributedStringKey {

        public typealias Value = AttributeScopes.FoundationAttributes.ByteCountAttribute.Component

        public static let name: String

        public enum Component : Codable, Hashable, Sendable {

            case value

            case spelledOutValue

            case unit(AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit)

            case actualByteCount

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: AttributeScopes.FoundationAttributes.ByteCountAttribute.Component, b: AttributeScopes.FoundationAttributes.ByteCountAttribute.Component) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        public enum Unit : Codable, Sendable {

            case byte

            case kb

            case mb

            case gb

            case tb

            case pb

            case eb

            case zb

            case yb

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit, b: AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }
    }

    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    @frozen public enum DurationFieldAttribute : CodableAttributedStringKey {

        public typealias Value = AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field

        public static let name: String

        public enum Field : Int, Codable, Sendable {

            case weeks

            case days

            case hours

            case minutes

            case seconds

            case microseconds

            case milliseconds

            case nanoseconds

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: Int)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
            public typealias RawValue = Int

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: Int { get }
        }
    }

    /// The attribute key for the base writing direction of a paragraph.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    @frozen public enum WritingDirectionAttribute : CodableAttributedStringKey {

        public typealias Value = AttributedString.WritingDirection

        public static let name: String

        public static let runBoundaries: AttributedString.AttributeRunBoundaries?

        public static let inheritedByAddedText: Bool
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct LocalizedStringArgumentAttributes {

        public let localizedNumericArgument: AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute

        public let localizedDateArgument: AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateArgumentAttribute

        public let localizedDateIntervalArgument: AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateIntervalArgumentAttribute

        public let localizedURLArgument: AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedURLArgumentAttribute

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        @frozen public enum LocalizedNumericArgumentAttribute : CodableAttributedStringKey {

            public static let name: String

            public enum Value : Hashable, Codable, Sendable {

                case uint(UInt64)

                case int(Int64)

                case double(Double)

                case decimal(Decimal)

                /// Returns a Boolean value indicating whether two values are equal.
                ///
                /// Equality is the inverse of inequality. For any values `a` and `b`,
                /// `a == b` implies that `a != b` is `false`.
                ///
                /// - Parameters:
                ///   - lhs: A value to compare.
                ///   - rhs: Another value to compare.
                public static func == (a: AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute.Value, b: AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute.Value) -> Bool

                /// Encodes this value into the given encoder.
                ///
                /// If the value fails to encode anything, `encoder` will encode an empty
                /// keyed container in its place.
                ///
                /// This function throws an error if any values are invalid for the given
                /// encoder's format.
                ///
                /// - Parameter encoder: The encoder to write data to.
                public func encode(to encoder: any Encoder) throws

                /// Hashes the essential components of this value by feeding them into the
                /// given hasher.
                ///
                /// Implement this method to conform to the `Hashable` protocol. The
                /// components used for hashing must be the same as the components compared
                /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
                /// with each of these components.
                ///
                /// - Important: In your implementation of `hash(into:)`,
                ///   don't call `finalize()` on the `hasher` instance provided,
                ///   or replace it with a different instance.
                ///   Doing so may become a compile-time error in the future.
                ///
                /// - Parameter hasher: The hasher to use when combining the components
                ///   of this instance.
                public func hash(into hasher: inout Hasher)

                /// The hash value.
                ///
                /// Hash values are not guaranteed to be equal across different executions of
                /// your program. Do not save hash values to use during a future execution.
                ///
                /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
                ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
                ///   The compiler provides an implementation for `hashValue` for you.
                public var hashValue: Int { get }

                /// Creates a new instance by decoding from the given decoder.
                ///
                /// This initializer throws an error if reading from the decoder fails, or
                /// if the data read is corrupted or otherwise invalid.
                ///
                /// - Parameter decoder: The decoder to read data from.
                public init(from decoder: any Decoder) throws
            }
        }

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        @frozen public enum LocalizedDateArgumentAttribute : CodableAttributedStringKey {

            public typealias Value = Date

            public static let name: String
        }

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        @frozen public enum LocalizedDateIntervalArgumentAttribute : CodableAttributedStringKey {

            public typealias Value = Range<Date>

            public static let name: String
        }

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        @frozen public enum LocalizedURLArgumentAttribute : CodableAttributedStringKey {

            public typealias Value = URL

            public static let name: String
        }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.LinkAttribute : ObjectiveCConvertibleAttributedStringKey {

    public typealias ObjectiveCValue = NSObject

    public static func objectiveCValue(for value: URL) throws -> NSObject

    public static func value(for object: NSObject) throws -> URL
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.LinkAttribute : BitwiseCopyable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension AttributeScopes.FoundationAttributes.ReferentConceptAttribute : BitwiseCopyable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension AttributeScopes.FoundationAttributes.AgreementConceptAttribute : BitwiseCopyable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension AttributeScopes.FoundationAttributes.AgreementArgumentAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.MorphologyAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.InflectionRuleAttribute : BitwiseCopyable {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension AttributeScopes.FoundationAttributes.LocalizedNumberFormatAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute : MarkdownDecodableAttributedStringKey {

    public static let markdownName: String
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.LanguageIdentifierAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PersonNameComponentAttribute : ObjectiveCConvertibleAttributedStringKey {

    public typealias ObjectiveCValue = NSString
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PersonNameComponentAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.DateFieldAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.InflectionAlternativeAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.InlinePresentationIntentAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PresentationIntentAttribute : BitwiseCopyable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributeScopes.FoundationAttributes.MarkdownSourcePositionAttribute : BitwiseCopyable {
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributeScopes.FoundationAttributes.ListItemDelimiterAttribute : Sendable {
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributeScopes.FoundationAttributes.ListItemDelimiterAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.AlternateDescriptionAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ImageURLAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ReplacementIndexAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ByteCountAttribute : BitwiseCopyable {
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension AttributeScopes.FoundationAttributes.DurationFieldAttribute : BitwiseCopyable {
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributeScopes.FoundationAttributes.WritingDirectionAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.PersonNameComponentAttribute.Component : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.MeasurementAttribute.Component : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.ByteCountAttribute.Unit : Hashable {
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field : Equatable {
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field : Hashable {
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension AttributeScopes.FoundationAttributes.DurationFieldAttribute.Field : RawRepresentable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedNumericArgumentAttribute : BitwiseCopyable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateArgumentAttribute : BitwiseCopyable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedDateIntervalArgumentAttribute : BitwiseCopyable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributeScopes.FoundationAttributes.LocalizedStringArgumentAttributes.LocalizedURLArgumentAttribute : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.NumberPartAttribute.NumberPart : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributeScopes.FoundationAttributes.NumberFormatAttributes.SymbolAttribute.Symbol : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributedString : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public init()

    /// Creates a new attributed string with the given `String` value associated with the given
    /// attributes.
    public init(_ string: String, attributes: AttributeContainer = .init())

    /// Creates a new attributed string with the given `Substring` value associated with the given
    /// attributes.
    public init(_ substring: Substring, attributes: AttributeContainer = .init())

    public init<S>(_ elements: S, attributes: AttributeContainer = .init()) where S : Sequence, S.Element == Character

    public init(_ substring: AttributedSubstring)

    public init<S, T>(_ other: T, including scope: KeyPath<AttributeScopes, S.Type>) where S : AttributeScope, T : AttributedStringProtocol

    public init<S, T>(_ other: T, including scope: S.Type) where S : AttributeScope, T : AttributedStringProtocol
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: AttributedString, rhs: AttributedString) -> Bool
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString : ExpressibleByStringLiteral {

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: String)

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias ExtendedGraphemeClusterLiteralType = String

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias StringLiteralType = String

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias UnicodeScalarLiteralType = String
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public mutating func setAttributes(_ attributes: AttributeContainer)

    public mutating func mergeAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew)

    public mutating func replaceAttributes(_ attributes: AttributeContainer, with others: AttributeContainer)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString : AttributedStringProtocol {

    public struct Index : Comparable, Sendable {

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (left: AttributedString.Index, right: AttributedString.Index) -> Bool

        /// Returns a Boolean value indicating whether the value of the first
        /// argument is less than that of the second argument.
        ///
        /// This function is the only requirement of the `Comparable` protocol. The
        /// remainder of the relational operator functions are implemented by the
        /// standard library for any type that conforms to `Comparable`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func < (left: AttributedString.Index, right: AttributedString.Index) -> Bool
    }

    public var startIndex: AttributedString.Index { get }

    public var endIndex: AttributedString.Index { get }

    @preconcurrency public subscript<K>(_: K.Type) -> K.Value? where K : AttributedStringKey, K.Value : Sendable

    @preconcurrency @inlinable public subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey, K.Value : Sendable

    public subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public mutating func append(_ s: some AttributedStringProtocol)

    public mutating func insert(_ s: some AttributedStringProtocol, at index: AttributedString.Index)

    public mutating func removeSubrange(_ range: some RangeExpression<AttributedString.Index>)

    public mutating func replaceSubrange(_ range: some RangeExpression<AttributedString.Index>, with s: some AttributedStringProtocol)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public static func + (lhs: AttributedString, rhs: some AttributedStringProtocol) -> AttributedString

    public static func += (lhs: inout AttributedString, rhs: some AttributedStringProtocol)

    public static func + (lhs: AttributedString, rhs: AttributedString) -> AttributedString

    public static func += (lhs: inout AttributedString, rhs: AttributedString)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public subscript(bounds: some RangeExpression<AttributedString.Index>) -> AttributedSubstring
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    @preconcurrency public struct SingleAttributeTransformer<T> : Sendable where T : AttributedStringKey, T.Value : Sendable {

        public var range: Range<AttributedString.Index>

        public var value: T.Value?

        @preconcurrency public mutating func replace<U>(with key: U.Type, value: U.Value) where U : AttributedStringKey, U.Value : Sendable

        @preconcurrency public mutating func replace<U>(with keyPath: KeyPath<AttributeDynamicLookup, U>, value: U.Value) where U : AttributedStringKey, U.Value : Sendable
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    @preconcurrency public func transformingAttributes<K>(_ k: K.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K>) -> Void) -> AttributedString where K : AttributedStringKey, K.Value : Sendable

    @preconcurrency public func transformingAttributes<K1, K2>(_ k: K1.Type, _ k2: K2.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K1.Value : Sendable, K2.Value : Sendable

    @preconcurrency public func transformingAttributes<K1, K2, K3>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K1.Value : Sendable, K2.Value : Sendable, K3.Value : Sendable

    @preconcurrency public func transformingAttributes<K1, K2, K3, K4>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>, inout AttributedString.SingleAttributeTransformer<K4>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K4 : AttributedStringKey, K1.Value : Sendable, K2.Value : Sendable, K3.Value : Sendable, K4.Value : Sendable

    @preconcurrency public func transformingAttributes<K1, K2, K3, K4, K5>(_ k: K1.Type, _ k2: K2.Type, _ k3: K3.Type, _ k4: K4.Type, _ k5: K5.Type, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>, inout AttributedString.SingleAttributeTransformer<K4>, inout AttributedString.SingleAttributeTransformer<K5>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K4 : AttributedStringKey, K5 : AttributedStringKey, K1.Value : Sendable, K2.Value : Sendable, K3.Value : Sendable, K4.Value : Sendable, K5.Value : Sendable
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    @preconcurrency public func transformingAttributes<K>(_ k: KeyPath<AttributeDynamicLookup, K>, _ c: (inout AttributedString.SingleAttributeTransformer<K>) -> Void) -> AttributedString where K : AttributedStringKey, K.Value : Sendable

    @preconcurrency public func transformingAttributes<K1, K2>(_ k: KeyPath<AttributeDynamicLookup, K1>, _ k2: KeyPath<AttributeDynamicLookup, K2>, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K1.Value : Sendable, K2.Value : Sendable

    @preconcurrency public func transformingAttributes<K1, K2, K3>(_ k: KeyPath<AttributeDynamicLookup, K1>, _ k2: KeyPath<AttributeDynamicLookup, K2>, _ k3: KeyPath<AttributeDynamicLookup, K3>, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K1.Value : Sendable, K2.Value : Sendable, K3.Value : Sendable

    @preconcurrency public func transformingAttributes<K1, K2, K3, K4>(_ k: KeyPath<AttributeDynamicLookup, K1>, _ k2: KeyPath<AttributeDynamicLookup, K2>, _ k3: KeyPath<AttributeDynamicLookup, K3>, _ k4: KeyPath<AttributeDynamicLookup, K4>, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>, inout AttributedString.SingleAttributeTransformer<K4>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K4 : AttributedStringKey, K1.Value : Sendable, K2.Value : Sendable, K3.Value : Sendable, K4.Value : Sendable

    @preconcurrency public func transformingAttributes<K1, K2, K3, K4, K5>(_ k: KeyPath<AttributeDynamicLookup, K1>, _ k2: KeyPath<AttributeDynamicLookup, K2>, _ k3: KeyPath<AttributeDynamicLookup, K3>, _ k4: KeyPath<AttributeDynamicLookup, K4>, _ k5: KeyPath<AttributeDynamicLookup, K5>, _ c: (inout AttributedString.SingleAttributeTransformer<K1>, inout AttributedString.SingleAttributeTransformer<K2>, inout AttributedString.SingleAttributeTransformer<K3>, inout AttributedString.SingleAttributeTransformer<K4>, inout AttributedString.SingleAttributeTransformer<K5>) -> Void) -> AttributedString where K1 : AttributedStringKey, K2 : AttributedStringKey, K3 : AttributedStringKey, K4 : AttributedStringKey, K5 : AttributedStringKey, K1.Value : Sendable, K2.Value : Sendable, K3.Value : Sendable, K4.Value : Sendable, K5.Value : Sendable
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public struct CharacterView : Sendable {

        /// Creates a new, empty collection.
        public init()
    }

    public var characters: AttributedString.CharacterView
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedString {

    /// Tracks the location of the provided range throughout the mutation closure, updating the provided range to one that represents the same effective locations after the mutation.
    ///
    /// If updating the provided range is not possible (tracking failed) then this function will fatal error. Use the `Optional`-returning variants to provide custom fallback behavior.
    /// - Parameters:
    ///   - range: A range to track throughout the `body` closure.
    ///   - body: A mutating operation, or set of operations, to perform on the value of `self`. The value of `self` is provided to the closure as an `inout AttributedString` that the closure should mutate directly. Do not capture the value of `self` in the provided closure - the closure should mutate the provided `inout` copy.
    public mutating func transform<E>(updating range: inout Range<AttributedString.Index>, body: (inout AttributedString) throws(E) -> Void) throws(E) where E : Error

    /// Tracks the location of the provided ranges throughout the mutation closure, updating them to new ranges that represent the same effective locations after the mutation. 
    ///
    /// If updating the provided ranges is not possible (tracking failed) then this function will fatal error. Use the `Optional`-returning variants to provide custom fallback behavior.
    /// - Parameters:
    ///   - ranges: A list of ranges to track throughout the `body` closure. The updated array (after the function is called) is guaranteed to be the same size as the provided array. Updated ranges are located at the same indices as their respective original ranges in the input `ranges` array.
    ///   - body: A mutating operation, or set of operations, to perform on the value of `self`. The value of `self` is provided to the closure as an `inout AttributedString` that the closure should mutate directly. Do not capture the value of `self` in the provided closure - the closure should mutate the provided `inout` copy.
    public mutating func transform<E>(updating ranges: inout [Range<AttributedString.Index>], body: (inout AttributedString) throws(E) -> Void) throws(E) where E : Error

    /// Tracks the location of the provided range throughout the mutation closure, returning a new, updated range that represents the same effective locations after the mutation.
    /// - Parameters:
    ///   - range: A range to track throughout the `body` block.
    ///   - body: A mutating operation, or set of operations, to perform on this `AttributedString`.
    /// - Returns: the updated `Range` that is valid after the mutation has been performed, or `nil` if the mutation performed does not allow for tracking to succeed (such as replacing the provided inout variable with an entirely different `AttributedString`).
    public mutating func transform<E>(updating range: Range<AttributedString.Index>, body: (inout AttributedString) throws(E) -> Void) throws(E) -> Range<AttributedString.Index>? where E : Error

    /// Tracks the location of the provided ranges throughout the mutation closure, returning a new, updated range that represents the same effective locations after the mutation
    /// - Parameters:
    ///   - ranges: Ranges to track throughout the `body` block.
    ///   - body: A mutating operation, or set of operations, to perform on this `AttributedString`.
    /// - Returns: the updated `Range`s that are valid after the mutation has been performed or `nil` if the mutation performed does not allow for tracking to succeed (such as replacing the provided inout variable with an entirely different `AttributedString`). When the return value is non-`nil`, the returned array is guaranteed to be the same size as the provided array with updated ranges at the same indices as their respective original ranges in the input array.
    public mutating func transform<E>(updating ranges: [Range<AttributedString.Index>], body: (inout AttributedString) throws(E) -> Void) throws(E) -> [Range<AttributedString.Index>]? where E : Error
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public struct Runs : Sendable {
    }

    public var runs: AttributedString.Runs { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public struct UnicodeScalarView : Sendable {

        /// Creates a new, empty collection.
        public init()
    }

    public var unicodeScalars: AttributedString.UnicodeScalarView
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedString {

    /// A view of an attributed string’s contents as a collection of UTF-8 code units.
    public struct UTF8View : Sendable {
    }

    /// A view of the attributed string’s contents as a collection of UTF-8 code units.
    public var utf8: AttributedString.UTF8View { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedString {

    /// A view of an attributed string’s contents as a collection of UTF-16 code units.
    public struct UTF16View : Sendable {
    }

    /// A view of the attributed string’s contents as a collection of UTF-16 code units.
    public var utf16: AttributedString.UTF16View { get }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributedString {

    public enum AttributeRunBoundaries : Hashable, Sendable {

        case paragraph

        case character(Character)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AttributedString.AttributeRunBoundaries, b: AttributedString.AttributeRunBoundaries) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributedString {

    public struct AttributeInvalidationCondition : Hashable, Sendable {

        public static let textChanged: AttributedString.AttributeInvalidationCondition

        public static func attributeChanged<T>(_ key: T.Type) -> AttributedString.AttributeInvalidationCondition where T : AttributedStringKey

        public static func attributeChanged<T>(_ key: KeyPath<AttributeDynamicLookup, T>) -> AttributedString.AttributeInvalidationCondition where T : AttributedStringKey

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AttributedString.AttributeInvalidationCondition, b: AttributedString.AttributeInvalidationCondition) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString : CodableWithConfiguration {

    public func encode(to encoder: any Encoder, configuration: AttributeScopeCodableConfiguration) throws

    public init(from decoder: any Decoder, configuration: AttributeScopeCodableConfiguration) throws

    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias DecodingConfiguration = AttributeScopeCodableConfiguration

    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias EncodingConfiguration = AttributeScopeCodableConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public enum AttributeMergePolicy : Sendable {

        case keepNew

        case keepCurrent

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AttributedString.AttributeMergePolicy, b: AttributedString.AttributeMergePolicy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public init(_ nsStr: NSAttributedString)

    public init<S>(_ nsStr: NSAttributedString, including scope: KeyPath<AttributeScopes, S.Type>) throws where S : AttributeScope

    public init<S>(_ nsStr: NSAttributedString, including scope: S.Type) throws where S : AttributeScope
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedString {

    /// Creates an attributed string from a discontiguous attributed substring.
    /// - Parameter substring: A discontiguous attributed substring to create the new attributed string from.
    public init(_ substring: DiscontiguousAttributedSubstring)
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedString {

    /// Returns a discontiguous substring of this discontiguous attributed string using a set of ranges to indicate the discontiguous substring bounds.
    /// - Parameter indices: A set of ranges that indicate the bounds of the discontiguous substring to return.
    public subscript(indices: RangeSet<AttributedString.Index>) -> DiscontiguousAttributedSubstring

    /// Removes the elements at the given indices.
    /// - Parameter subranges: The indices of the elements to remove.
    public mutating func removeSubranges(_ subranges: RangeSet<AttributedString.Index>)
}

extension AttributedString {

    /// The writing direction of a piece of text.
    ///
    /// Writing direction defines the base direction in which bidirectional text
    /// lays out its directional runs. A directional run is a contigous sequence
    /// of characters that all have the same effective directionality, which can
    /// be determined using the Unicode BiDi algorithm. The ``leftToRight``
    /// writing direction puts the directional run that is placed first in the
    /// storage leftmost, and places subsequent directional runs towards the
    /// right. The ``rightToLeft`` writing direction puts the directional run
    /// that is placed first in the storage rightmost, and places subsequent
    /// directional runs towards the left.
    ///
    /// Note that writing direction is a property separate from a text's
    /// alignment, its line layout direction, or its character direction.
    /// However, it is often used to determine the default alignment of a
    /// paragraph. E.g. English (a language with
    /// ``Locale/LanguageDirection-swift.enum/leftToRight``
    /// ``Locale/Language-swift.struct/characterDirection``) is usually aligned
    /// to the left, but may be centered or aligned to the right for special
    /// effect, or to be visually more appealing in a user interface.
    ///
    /// For bidirectional text to be perceived as laid out correctly, make sure
    /// that the writing direction is set to the value equivalent to the
    /// ``Locale/Language-swift.struct/characterDirection`` of the primary
    /// language in the text. E.g. an English sentence that contains some
    /// Arabic (a language with
    /// ``Locale/LanguageDirection-swift.enum/rightToLeft``
    /// ``Locale/Language-swift.struct/characterDirection``) words, should use
    /// a ``leftToRight`` writing direction. An Arabic sentence that contains
    /// some English words, should use a ``rightToLeft`` writing direction.
    ///
    /// Writing direction is always orthogonoal to the line layout direction
    /// chosen to display a certain text. The line layout direction is the
    /// direction in which a sequence of lines is placed in. E.g. English text
    /// is usually displayed with a line layout direction of
    /// ``Locale/LanguageDirection-swift.enum/topToBottom``. While languages do
    /// have an associated line language direction (see
    /// ``Locale/Language-swift.struct/lineLayoutDirection``), not all displays
    /// of text follow the line layout direction of the text's primary language.
    ///
    /// Horizontal script is script with a line layout direction of either
    /// ``Locale/LanguageDirection-swift.enum/topToBottom`` or
    /// ``Locale/LanguageDirection-swift.enum/bottomToTop``. Vertical script
    /// has a ``Locale/LanguageDirection-swift.enum/leftToRight`` or
    /// ``Locale/LanguageDirection-swift.enum/rightToLeft`` line layout
    /// direction. In vertical scripts, a writing direction of ``leftToRight``
    /// is interpreted as top-to-bottom and a writing direction of
    /// ``rightToLeft`` is interpreted as bottom-to-top.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    @frozen public enum WritingDirection : Codable, Hashable, CaseIterable, Sendable {

        /// A left-to-right writing direction in horizontal script.
        ///
        /// - Note: In vertical scripts, this equivalent to a top-to-bottom
        /// writing direction.
        case leftToRight

        /// A right-to-left writing direction in horizontal script.
        ///
        /// - Note: In vertical scripts, this equivalent to a bottom-to-top
        /// writing direction.
        case rightToLeft

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AttributedString.WritingDirection, b: AttributedString.WritingDirection) -> Bool

        /// A type that can represent a collection of all values of this type.
        @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
        public typealias AllCases = [AttributedString.WritingDirection]

        /// A collection of all values of this type.
        nonisolated public static var allCases: [AttributedString.WritingDirection] { get }

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct LocalizationOptions {

        public var replacements: [any CVarArg]?

        /// A list of objects that are not interpolated in the final string, but
        /// can be used by annotations for automatic grammar agreement
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var concepts: [InflectionConcept]?

        /// Whether attributes for automatic grammar agreement and formatting should
        /// be processed upon loading the string. Default value is `true`.
        @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
        public var inflect: Bool

        public var applyReplacementIndexAttribute: Bool

        public init()

        @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
        public static func termsOfAddressConcept(_ termsOfAddress: [TermOfAddress]) -> AttributedString.LocalizationOptions

        @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
        public static func localizedPhraseConcept(_ phrase: String) -> AttributedString.LocalizationOptions
    }

    /// Options that affect the localized formatting of AttributedString
    public struct FormattingOptions : OptionSet, Sendable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: UInt

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: UInt)

        /// This option causes ReplacementStringAttribute attributes to be applied to the string to indicate the ranges of the inserted arguments. The values of these attributes will begin with 1 for the first interpolated argument in the `StringLocalizationValue`, 2 for the second, and so-on. However, because localizers are able to change the order in which arguments appear in the final string, these index values may appear in a different order.
        public static let applyReplacementIndexAttribute: AttributedString.FormattingOptions

        /// The type of the elements of an array literal.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias ArrayLiteralElement = AttributedString.FormattingOptions

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias Element = AttributedString.FormattingOptions

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias RawValue = UInt
    }

    /// Options that affect how an AttributedString is interpolated during localized formatting.
    public struct InterpolationOptions : OptionSet, Sendable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: UInt

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: UInt)

        /// By default, interpolating an AttributedString will result in the final string having all attributes present at its interpolation point, plus all attributes from the beginning of the interpolated AttributedString.
        /// Specify this option to instead indicate that pre-existing attributes at the point of interpolation (e.g., those specified with Markdown syntax) must be ignored. The result will only have the attributes from the interpolated AttributedString.
        /// This option has no effect when formatting a plain-text String, since all attributes will be stripped anyway.
        public static let insertAttributesWithoutMerging: AttributedString.InterpolationOptions

        /// The type of the elements of an array literal.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias ArrayLiteralElement = AttributedString.InterpolationOptions

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias Element = AttributedString.InterpolationOptions

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias RawValue = UInt
    }

    public init(localized key: String.LocalizationValue, options: AttributedString.FormattingOptions = [], table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil)

    public init(localized key: StaticString, defaultValue: String.LocalizationValue, options: AttributedString.FormattingOptions = [], table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil)

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init(localized key: String.LocalizationValue, options: AttributedString.LocalizationOptions, table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil)

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init(localized key: StaticString, defaultValue: String.LocalizationValue, options: AttributedString.LocalizationOptions, table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil)

    public init<S>(localized key: String.LocalizationValue, options: AttributedString.FormattingOptions = [], table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: KeyPath<AttributeScopes, S.Type>) where S : AttributeScope

    public init<S>(localized key: StaticString, defaultValue: String.LocalizationValue, options: AttributedString.FormattingOptions = [], table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: KeyPath<AttributeScopes, S.Type>) where S : AttributeScope

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init<S>(localized key: String.LocalizationValue, options: AttributedString.LocalizationOptions, table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: KeyPath<AttributeScopes, S.Type>) where S : AttributeScope

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init<S>(localized key: StaticString, defaultValue: String.LocalizationValue, options: AttributedString.LocalizationOptions, table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: KeyPath<AttributeScopes, S.Type>) where S : AttributeScope

    public init<S>(localized key: String.LocalizationValue, options: AttributedString.FormattingOptions = [], table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: S.Type) where S : AttributeScope

    public init<S>(localized key: StaticString, defaultValue: String.LocalizationValue, options: AttributedString.FormattingOptions = [], table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: S.Type) where S : AttributeScope

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init<S>(localized key: String.LocalizationValue, options: AttributedString.LocalizationOptions, table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: S.Type) where S : AttributeScope

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init<S>(localized key: StaticString, defaultValue: String.LocalizationValue, options: AttributedString.LocalizationOptions, table: String? = nil, bundle: Bundle? = nil, locale: Locale? = nil, comment: StaticString? = nil, including scope: S.Type) where S : AttributeScope
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension AttributedString {

    public init(localized resource: LocalizedStringResource)

    public init<S>(localized resource: LocalizedStringResource, including scope: KeyPath<AttributeScopes, S.Type>) where S : AttributeScope

    public init<S>(localized resource: LocalizedStringResource, including scope: S.Type) where S : AttributeScope

    public init(localized resource: LocalizedStringResource, options: AttributedString.LocalizationOptions)

    public init<S>(localized resource: LocalizedStringResource, options: AttributedString.LocalizationOptions, including scope: KeyPath<AttributeScopes, S.Type>) where S : AttributeScope

    public init<S>(localized resource: LocalizedStringResource, options: AttributedString.LocalizationOptions, including scope: S.Type) where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    public struct MarkdownParsingOptions : Sendable {

        public enum FailurePolicy : Int, Sendable {

            case throwError

            case returnPartiallyParsedIfPossible

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: Int)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
            public typealias RawValue = Int

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: Int { get }
        }

        public enum InterpretedSyntax : Int, Sendable {

            case full

            case inlineOnly

            case inlineOnlyPreservingWhitespace

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: Int)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
            public typealias RawValue = Int

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: Int { get }
        }

        public var allowsExtendedAttributes: Bool

        public var interpretedSyntax: AttributedString.MarkdownParsingOptions.InterpretedSyntax

        public var failurePolicy: AttributedString.MarkdownParsingOptions.FailurePolicy

        public var languageCode: String?

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        public var appliesSourcePositionAttributes: Bool

        public init(allowsExtendedAttributes: Bool = false, interpretedSyntax: AttributedString.MarkdownParsingOptions.InterpretedSyntax = .full, failurePolicy: AttributedString.MarkdownParsingOptions.FailurePolicy = .throwError, languageCode: String? = nil)

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        public init(allowsExtendedAttributes: Bool = false, interpretedSyntax: AttributedString.MarkdownParsingOptions.InterpretedSyntax = .full, failurePolicy: AttributedString.MarkdownParsingOptions.FailurePolicy = .throwError, languageCode: String? = nil, appliesSourcePositionAttributes: Bool = false)
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct MarkdownSourcePosition : Hashable, Codable, Sendable {

        public let startLine: Int

        public let startColumn: Int

        public let endLine: Int

        public let endColumn: Int

        public init(startLine: Int, startColumn: Int, endLine: Int, endColumn: Int)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: AttributedString.MarkdownSourcePosition, b: AttributedString.MarkdownSourcePosition) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public init<S>(markdown: String, including scope: KeyPath<AttributeScopes, S.Type>, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope

    public init(markdown: String, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws

    public init<S>(markdown: String, including scope: S.Type, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope

    public init<S>(markdown: Data, including scope: KeyPath<AttributeScopes, S.Type>, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope

    public init(markdown: Data, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws

    public init<S>(markdown: Data, including scope: S.Type, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope

    public init<S>(contentsOf url: URL, including scope: KeyPath<AttributeScopes, S.Type>, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope

    public init(contentsOf url: URL, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws

    public init<S>(contentsOf url: URL, including scope: S.Type, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString {

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public func inflected() -> AttributedString

    /// Process automatic grammar agreement and formatting attributes.
    ///
    /// - Parameters:
    ///   - locale: The locale used for formatting the string. It also specifies
    ///     the language used for automatic grammar agreement, unless overridden
    ///     with the `languageIdentifier` attribute.
    ///   - userTermOfAddress: The user's preferred term of address, if the user
    ///     has set one. A value of `nil` indicates no preference, in which case
    ///     the inflection alternative will be used for strings that address the
    ///     the user. Default value is `.currentUser`.
    ///   - inflectionConcepts: A list of objects providing additional hints for
    ///     automatic grammar agreement, such as terms of address for people who
    ///     are mentioned, or phrases with which the string has to grammatically
    ///     agree.
    ///
    /// Arguments that were previously formatted in the string must be annotated
    /// with the following attributes:
    ///  - `replacementIndex`, set to the index of the format specifier.
    ///  - `localizedNumericArgument`, if the argument was numeric, must also be
    ///     set to the original value of the argument.
    /// If not all arguments are properly annotated, the `agreeWithArgument` and
    /// `inflect` attributes may not work properly and behavior is undefined.
    @available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, visionOS 2.0, *)
    public func inflected(locale: Locale = .current, userTermOfAddress: TermOfAddress? = .currentUser, inflectionConcepts: [InflectionConcept] = []) -> AttributedString
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedString.Index {

    /// Indicates whether the index is valid for use with the provided attributed string.
    /// - Parameter text: An attributed string used to validate the index.
    /// - Returns: `true` when the index is valid for use with the provided attributed string; otherwise, false. An index is valid if it is both within the bounds of the attributed string and was produced from the provided string without any intermediate mutations.
    public func isValid(within text: some AttributedStringProtocol) -> Bool

    /// Indicates whether the index is valid for use with the provided discontiguous attributed string.
    /// - Parameter text: A discontiguous attributed string used to validate the index.
    /// - Returns: `true` when the index is valid for use with the provided discontiguous attributed string; otherwise, false. An index is valid if it is both within the bounds of the discontigous attributed string and was produced from the provided string without any intermediate mutations.
    public func isValid(within text: DiscontiguousAttributedSubstring) -> Bool
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Index {

    public init?<S>(_ sourcePosition: String.Index, within target: S) where S : AttributedStringProtocol
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.CharacterView : BidirectionalCollection {

    /// A type representing the sequence's elements.
    public typealias Element = Character

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = AttributedString.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: AttributedString.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: AttributedString.Index { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: AttributedString.Index) -> AttributedString.Index

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AttributedString.Index) -> AttributedString.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Index, offsetBy distance: Int) -> AttributedString.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Index, offsetBy distance: Int, limitedBy limit: AttributedString.Index) -> AttributedString.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    public func distance(from start: AttributedString.Index, to end: AttributedString.Index) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: AttributedString.Index) -> Character

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<AttributedString.Index>) -> Slice<AttributedString.CharacterView>

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Indices = DefaultIndices<AttributedString.CharacterView>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Iterator = IndexingIterator<AttributedString.CharacterView>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias SubSequence = Slice<AttributedString.CharacterView>
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.CharacterView : RangeReplaceableCollection {

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    public mutating func replaceSubrange(_ subrange: Range<AttributedString.CharacterView.Index>, with newElements: some Collection<Character>)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: AttributedString.Runs, rhs: AttributedString.Runs) -> Bool
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public struct Index : Sendable {
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs : BidirectionalCollection {

    /// A type representing the sequence's elements.
    public typealias Element = AttributedString.Runs.Run

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: AttributedString.Runs.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: AttributedString.Runs.Index { get }

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AttributedString.Runs.Index) -> AttributedString.Runs.Index

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: AttributedString.Runs.Index) -> AttributedString.Runs.Index

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    public func distance(from start: AttributedString.Runs.Index, to end: AttributedString.Runs.Index) -> Int

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Runs.Index, offsetBy distance: Int) -> AttributedString.Runs.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Runs.Index, offsetBy distance: Int, limitedBy limit: AttributedString.Runs.Index) -> AttributedString.Runs.Index?

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(position: AttributedString.Runs.Index) -> AttributedString.Runs.Run { get }

    public subscript(position: AttributedString.Index) -> AttributedString.Runs.Run { get }

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Indices = DefaultIndices<AttributedString.Runs>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Iterator = IndexingIterator<AttributedString.Runs>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias SubSequence = Slice<AttributedString.Runs>
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {

    @preconcurrency public struct AttributesSlice1<T> : BidirectionalCollection, Sendable where T : AttributedStringKey, T.Value : Sendable {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = AttributedString.Index

        /// A type representing the sequence's elements.
        public typealias Element = (T.Value?, Range<AttributedString.Index>)

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol, Sendable {

            /// The type of element traversed by the iterator.
            public typealias Element = AttributedString.Runs.AttributesSlice1<T>.Element

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> AttributedString.Runs.AttributesSlice1<T>.Iterator.Element?
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> AttributedString.Runs.AttributesSlice1<T>.Iterator

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: AttributedString.Runs.AttributesSlice1<T>.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: AttributedString.Runs.AttributesSlice1<T>.Index { get }

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: AttributedString.Runs.AttributesSlice1<T>.Index) -> AttributedString.Runs.AttributesSlice1<T>.Index

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: AttributedString.Runs.AttributesSlice1<T>.Index) -> AttributedString.Runs.AttributesSlice1<T>.Index

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice1<T>.Element { get }

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice1<T>>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice1<T>>
    }

    @preconcurrency public subscript<T>(keyPath: KeyPath<AttributeDynamicLookup, T>) -> AttributedString.Runs.AttributesSlice1<T> where T : AttributedStringKey, T.Value : Sendable { get }

    @preconcurrency public subscript<T>(t: T.Type) -> AttributedString.Runs.AttributesSlice1<T> where T : AttributedStringKey, T.Value : Sendable { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {

    @preconcurrency public struct AttributesSlice2<T, U> : BidirectionalCollection, Sendable where T : AttributedStringKey, U : AttributedStringKey, T.Value : Sendable, U.Value : Sendable {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = AttributedString.Index

        /// A type representing the sequence's elements.
        public typealias Element = (T.Value?, U.Value?, Range<AttributedString.Index>)

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol, Sendable {

            /// The type of element traversed by the iterator.
            public typealias Element = AttributedString.Runs.AttributesSlice2<T, U>.Element

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> AttributedString.Runs.AttributesSlice2<T, U>.Iterator.Element?
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> AttributedString.Runs.AttributesSlice2<T, U>.Iterator

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: AttributedString.Runs.AttributesSlice2<T, U>.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: AttributedString.Runs.AttributesSlice2<T, U>.Index { get }

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: AttributedString.Runs.AttributesSlice2<T, U>.Index) -> AttributedString.Runs.AttributesSlice2<T, U>.Index

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: AttributedString.Runs.AttributesSlice2<T, U>.Index) -> AttributedString.Runs.AttributesSlice2<T, U>.Index

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice2<T, U>.Element { get }

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice2<T, U>>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice2<T, U>>
    }

    @preconcurrency public subscript<T, U>(t: KeyPath<AttributeDynamicLookup, T>, u: KeyPath<AttributeDynamicLookup, U>) -> AttributedString.Runs.AttributesSlice2<T, U> where T : AttributedStringKey, U : AttributedStringKey, T.Value : Sendable, U.Value : Sendable { get }

    @preconcurrency public subscript<T, U>(t: T.Type, u: U.Type) -> AttributedString.Runs.AttributesSlice2<T, U> where T : AttributedStringKey, U : AttributedStringKey, T.Value : Sendable, U.Value : Sendable { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {

    @preconcurrency public struct AttributesSlice3<T, U, V> : BidirectionalCollection, Sendable where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, T.Value : Sendable, U.Value : Sendable, V.Value : Sendable {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = AttributedString.Index

        /// A type representing the sequence's elements.
        public typealias Element = (T.Value?, U.Value?, V.Value?, Range<AttributedString.Index>)

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol, Sendable {

            /// The type of element traversed by the iterator.
            public typealias Element = AttributedString.Runs.AttributesSlice3<T, U, V>.Element

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator.Element?
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> AttributedString.Runs.AttributesSlice3<T, U, V>.Iterator

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: AttributedString.Runs.AttributesSlice3<T, U, V>.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: AttributedString.Runs.AttributesSlice3<T, U, V>.Index { get }

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> AttributedString.Runs.AttributesSlice3<T, U, V>.Index

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: AttributedString.Runs.AttributesSlice3<T, U, V>.Index) -> AttributedString.Runs.AttributesSlice3<T, U, V>.Index

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice3<T, U, V>.Element { get }

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice3<T, U, V>>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice3<T, U, V>>
    }

    @preconcurrency public subscript<T, U, V>(t: KeyPath<AttributeDynamicLookup, T>, u: KeyPath<AttributeDynamicLookup, U>, v: KeyPath<AttributeDynamicLookup, V>) -> AttributedString.Runs.AttributesSlice3<T, U, V> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, T.Value : Sendable, U.Value : Sendable, V.Value : Sendable { get }

    @preconcurrency public subscript<T, U, V>(t: T.Type, u: U.Type, v: V.Type) -> AttributedString.Runs.AttributesSlice3<T, U, V> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, T.Value : Sendable, U.Value : Sendable, V.Value : Sendable { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {

    @preconcurrency public struct AttributesSlice4<T, U, V, W> : BidirectionalCollection, Sendable where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey, T.Value : Sendable, U.Value : Sendable, V.Value : Sendable, W.Value : Sendable {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = AttributedString.Index

        /// A type representing the sequence's elements.
        public typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, Range<AttributedString.Index>)

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol, Sendable {

            /// The type of element traversed by the iterator.
            public typealias Element = AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator.Element?
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Iterator

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index { get }

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index) -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Index

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice4<T, U, V, W>.Element { get }

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice4<T, U, V, W>>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice4<T, U, V, W>>
    }

    @preconcurrency public subscript<T, U, V, W>(t: KeyPath<AttributeDynamicLookup, T>, u: KeyPath<AttributeDynamicLookup, U>, v: KeyPath<AttributeDynamicLookup, V>, w: KeyPath<AttributeDynamicLookup, W>) -> AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey, T.Value : Sendable, U.Value : Sendable, V.Value : Sendable, W.Value : Sendable { get }

    @preconcurrency public subscript<T, U, V, W>(t: T.Type, u: U.Type, v: V.Type, w: W.Type) -> AttributedString.Runs.AttributesSlice4<T, U, V, W> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey, T.Value : Sendable, U.Value : Sendable, V.Value : Sendable, W.Value : Sendable { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {

    @preconcurrency public struct AttributesSlice5<T, U, V, W, X> : BidirectionalCollection, Sendable where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey, X : AttributedStringKey, T.Value : Sendable, U.Value : Sendable, V.Value : Sendable, W.Value : Sendable, X.Value : Sendable {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = AttributedString.Index

        /// A type representing the sequence's elements.
        public typealias Element = (T.Value?, U.Value?, V.Value?, W.Value?, X.Value?, Range<AttributedString.Index>)

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        public struct Iterator : IteratorProtocol, Sendable {

            /// The type of element traversed by the iterator.
            public typealias Element = AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element

            /// Advances to the next element and returns it, or `nil` if no next element
            /// exists.
            ///
            /// Repeatedly calling this method returns, in order, all the elements of the
            /// underlying sequence. As soon as the sequence has run out of elements, all
            /// subsequent calls return `nil`.
            ///
            /// You must not call this method if any other copy of this iterator has been
            /// advanced with a call to its `next()` method.
            ///
            /// The following example shows how an iterator can be used explicitly to
            /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
            /// then call the iterator's `next()` method until it returns `nil`.
            ///
            ///     let numbers = [2, 3, 5, 7]
            ///     var numbersIterator = numbers.makeIterator()
            ///
            ///     while let num = numbersIterator.next() {
            ///         print(num)
            ///     }
            ///     // Prints "2"
            ///     // Prints "3"
            ///     // Prints "5"
            ///     // Prints "7"
            ///
            /// - Returns: The next element in the underlying sequence, if a next element
            ///   exists; otherwise, `nil`.
            public mutating func next() -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator.Element?
        }

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Iterator

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index { get }

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Index

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: AttributedString.Index) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X>.Element { get }

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias Indices = DefaultIndices<AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias SubSequence = Slice<AttributedString.Runs.AttributesSlice5<T, U, V, W, X>>
    }

    @preconcurrency public subscript<T, U, V, W, X>(t: KeyPath<AttributeDynamicLookup, T>, u: KeyPath<AttributeDynamicLookup, U>, v: KeyPath<AttributeDynamicLookup, V>, w: KeyPath<AttributeDynamicLookup, W>, x: KeyPath<AttributeDynamicLookup, X>) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey, X : AttributedStringKey, T.Value : Sendable, U.Value : Sendable, V.Value : Sendable, W.Value : Sendable, X.Value : Sendable { get }

    @preconcurrency public subscript<T, U, V, W, X>(t: T.Type, u: U.Type, v: V.Type, w: W.Type, x: X.Type) -> AttributedString.Runs.AttributesSlice5<T, U, V, W, X> where T : AttributedStringKey, U : AttributedStringKey, V : AttributedStringKey, W : AttributedStringKey, X : AttributedStringKey, T.Value : Sendable, U.Value : Sendable, V.Value : Sendable, W.Value : Sendable, X.Value : Sendable { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs {

    @dynamicMemberLookup public struct Run : Sendable {
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.UnicodeScalarView : BidirectionalCollection {

    /// A type representing the sequence's elements.
    public typealias Element = UnicodeScalar

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = AttributedString.Index

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: AttributedString.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: AttributedString.Index { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: AttributedString.Index) -> AttributedString.Index

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AttributedString.Index) -> AttributedString.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Index, offsetBy distance: Int) -> AttributedString.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Index, offsetBy distance: Int, limitedBy limit: AttributedString.Index) -> AttributedString.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    public func distance(from start: AttributedString.Index, to end: AttributedString.Index) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: AttributedString.Index) -> UnicodeScalar { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<AttributedString.Index>) -> Slice<AttributedString.UnicodeScalarView> { get }

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Indices = DefaultIndices<AttributedString.UnicodeScalarView>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias Iterator = IndexingIterator<AttributedString.UnicodeScalarView>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias SubSequence = Slice<AttributedString.UnicodeScalarView>
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.UnicodeScalarView : RangeReplaceableCollection {

    /// Replaces the specified subrange of elements with the given collection.
    ///
    /// This method has the effect of removing the specified range of elements
    /// from the collection and inserting the new elements at the same location.
    /// The number of new elements need not match the number of elements being
    /// removed.
    ///
    /// In this example, three elements in the middle of an array of integers are
    /// replaced by the five elements of a `Repeated<Int>` instance.
    ///
    ///      var nums = [10, 20, 30, 40, 50]
    ///      nums.replaceSubrange(1...3, with: repeatElement(1, count: 5))
    ///      print(nums)
    ///      // Prints "[10, 1, 1, 1, 1, 1, 50]"
    ///
    /// If you pass a zero-length range as the `subrange` parameter, this method
    /// inserts the elements of `newElements` at `subrange.startIndex`. Calling
    /// the `insert(contentsOf:at:)` method instead is preferred.
    ///
    /// Likewise, if you pass a zero-length collection as the `newElements`
    /// parameter, this method removes the elements in the given subrange
    /// without replacement. Calling the `removeSubrange(_:)` method instead is
    /// preferred.
    ///
    /// Calling this method may invalidate any existing indices for use with this
    /// collection.
    ///
    /// - Parameters:
    ///   - subrange: The subrange of the collection to replace. The bounds of
    ///     the range must be valid indices of the collection.
    ///   - newElements: The new elements to add to the collection.
    ///
    /// - Complexity: O(*n* + *m*), where *n* is length of this collection and
    ///   *m* is the length of `newElements`. If the call to this method simply
    ///   appends the contents of `newElements` to the collection, this method is
    ///   equivalent to `append(contentsOf:)`.
    public mutating func replaceSubrange(_ subrange: Range<AttributedString.UnicodeScalarView.Index>, with newElements: some Collection<Unicode.Scalar>)
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedString.UTF8View : BidirectionalCollection {

    /// A type representing the sequence's elements.
    public typealias Element = UTF8.CodeUnit

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = AttributedString.Index

    public typealias Subsequence = AttributedString.UTF8View

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: AttributedString.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: AttributedString.Index { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: AttributedString.Index) -> AttributedString.Index

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AttributedString.Index) -> AttributedString.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Index, offsetBy distance: Int) -> AttributedString.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Index, offsetBy distance: Int, limitedBy limit: AttributedString.Index) -> AttributedString.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    public func distance(from start: AttributedString.Index, to end: AttributedString.Index) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: AttributedString.Index) -> UTF8.CodeUnit { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<AttributedString.Index>) -> AttributedString.UTF8View { get }

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias Indices = DefaultIndices<AttributedString.UTF8View>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias Iterator = IndexingIterator<AttributedString.UTF8View>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias SubSequence = AttributedString.UTF8View
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedString.UTF16View : BidirectionalCollection {

    /// A type representing the sequence's elements.
    public typealias Element = UTF16.CodeUnit

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = AttributedString.Index

    public typealias Subsequence = AttributedString.UTF16View

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: AttributedString.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: AttributedString.Index { get }

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: AttributedString.Index) -> AttributedString.Index

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: AttributedString.Index) -> AttributedString.Index

    /// Returns an index that is the specified distance from the given index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    ///
    ///     let s = "Swift"
    ///     let i = s.index(s.startIndex, offsetBy: 4)
    ///     print(s[i])
    ///     // Prints "t"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    /// - Returns: An index offset by `distance` from the index `i`. If
    ///   `distance` is positive, this is the same value as the result of
    ///   `distance` calls to `index(after:)`. If `distance` is negative, this
    ///   is the same value as the result of `abs(distance)` calls to
    ///   `index(before:)`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Index, offsetBy distance: Int) -> AttributedString.Index

    /// Returns an index that is the specified distance from the given index,
    /// unless that distance is beyond a given limiting index.
    ///
    /// The following example obtains an index advanced four positions from a
    /// string's starting index and then prints the character at that position.
    /// The operation doesn't require going beyond the limiting `s.endIndex`
    /// value, so it succeeds.
    ///
    ///     let s = "Swift"
    ///     if let i = s.index(s.startIndex, offsetBy: 4, limitedBy: s.endIndex) {
    ///         print(s[i])
    ///     }
    ///     // Prints "t"
    ///
    /// The next example attempts to retrieve an index six positions from
    /// `s.startIndex` but fails, because that distance is beyond the index
    /// passed as `limit`.
    ///
    ///     let j = s.index(s.startIndex, offsetBy: 6, limitedBy: s.endIndex)
    ///     print(j)
    ///     // Prints "nil"
    ///
    /// The value passed as `distance` must not offset `i` beyond the bounds of
    /// the collection, unless the index passed as `limit` prevents offsetting
    /// beyond those bounds.
    ///
    /// - Parameters:
    ///   - i: A valid index of the collection.
    ///   - distance: The distance to offset `i`. `distance` must not be negative
    ///     unless the collection conforms to the `BidirectionalCollection`
    ///     protocol.
    ///   - limit: A valid index of the collection to use as a limit. If
    ///     `distance > 0`, a limit that is less than `i` has no effect.
    ///     Likewise, if `distance < 0`, a limit that is greater than `i` has no
    ///     effect.
    /// - Returns: An index offset by `distance` from the index `i`, unless that
    ///   index would be beyond `limit` in the direction of movement. In that
    ///   case, the method returns `nil`.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the absolute
    ///   value of `distance`.
    public func index(_ i: AttributedString.Index, offsetBy distance: Int, limitedBy limit: AttributedString.Index) -> AttributedString.Index?

    /// Returns the distance between two indices.
    ///
    /// Unless the collection conforms to the `BidirectionalCollection` protocol,
    /// `start` must be less than or equal to `end`.
    ///
    /// - Parameters:
    ///   - start: A valid index of the collection.
    ///   - end: Another valid index of the collection. If `end` is equal to
    ///     `start`, the result is zero.
    /// - Returns: The distance between `start` and `end`. The result can be
    ///   negative only if the collection conforms to the
    ///   `BidirectionalCollection` protocol.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*k*), where *k* is the
    ///   resulting distance.
    public func distance(from start: AttributedString.Index, to end: AttributedString.Index) -> Int

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: AttributedString.Index) -> UTF16.CodeUnit { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<AttributedString.Index>) -> AttributedString.UTF16View { get }

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias Indices = DefaultIndices<AttributedString.UTF16View>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias Iterator = IndexingIterator<AttributedString.UTF16View>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias SubSequence = AttributedString.UTF16View
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.AttributeMergePolicy : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.AttributeMergePolicy : Hashable {
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedString.WritingDirection : BitwiseCopyable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Index : Comparable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: AttributedString.Runs.Index, rhs: AttributedString.Runs.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: AttributedString.Runs.Index, rhs: AttributedString.Runs.Index) -> Bool
}

@available(macOS, introduced: 12, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(iOS, introduced: 15, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(tvOS, introduced: 15, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(watchOS, introduced: 8, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(visionOS, introduced: 1, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
@available(*, deprecated, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
extension AttributedString.Runs.Index : Strideable {

    /// Returns the distance from this value to the given value, expressed as a 
    /// stride.
    ///
    /// If this type's `Stride` type conforms to `BinaryInteger`, then for two
    /// values `x` and `y`, and a distance `n = x.distance(to: y)`,
    /// `x.advanced(by: n) == y`. Using this method with types that have a
    /// noninteger `Stride` may result in an approximation.
    ///
    /// - Parameter other: The value to calculate the distance to.
    /// - Returns: The distance from this value to `other`.
    ///
    /// - Complexity: O(1)
    public func distance(to other: AttributedString.Runs.Index) -> Int

    /// Returns a value that is offset the specified distance from this value.
    ///
    /// Use the `advanced(by:)` method in generic code to offset a value by a
    /// specified distance. If you're working directly with numeric values, use
    /// the addition operator (`+`) instead of this method.
    ///
    ///     func addOne<T: Strideable>(to x: T) -> T
    ///         where T.Stride: ExpressibleByIntegerLiteral
    ///     {
    ///         return x.advanced(by: 1)
    ///     }
    ///
    ///     let x = addOne(to: 5)
    ///     // x == 6
    ///     let y = addOne(to: 3.5)
    ///     // y = 4.5
    ///
    /// If this type's `Stride` type conforms to `BinaryInteger`, then for a
    /// value `x`, a distance `n`, and a value `y = x.advanced(by: n)`,
    /// `x.distance(to: y) == n`. Using this method with types that have a
    /// noninteger `Stride` may result in an approximation. If the result of
    /// advancing by `n` is not representable as a value of this type, then a
    /// runtime error may occur.
    ///
    /// - Parameter n: The distance to advance this value.
    /// - Returns: A value that is offset from this value by `n`.
    ///
    /// - Complexity: O(1)
    public func advanced(by n: Int) -> AttributedString.Runs.Index

    /// A type that represents the distance between two values.
    @available(*, deprecated, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
    @available(iOS, introduced: 15, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
    @available(tvOS, introduced: 15, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
    @available(watchOS, introduced: 8, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
    @available(visionOS, introduced: 1, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
    @available(macOS, introduced: 12, deprecated: 26, message: "AttributedString.Runs.Index should not be used as a Strideable and should instead be offset using the API provided by AttributedString.Runs")
    public typealias Stride = Int
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Run : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: AttributedString.Runs.Run, rhs: AttributedString.Runs.Run) -> Bool
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Run : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Run {

    public var range: Range<AttributedString.Index> { get }

    public var attributes: AttributeContainer { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.Runs.Run {

    @preconcurrency @inlinable public subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey, K.Value : Sendable { get }

    @preconcurrency public subscript<K>(_: K.Type) -> K.Value? where K : AttributedStringKey, K.Value : Sendable { get }

    public subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.FailurePolicy : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.FailurePolicy : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.FailurePolicy : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.InterpretedSyntax : Equatable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.InterpretedSyntax : Hashable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedString.MarkdownParsingOptions.InterpretedSyntax : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringAttributeMutation {

    mutating func setAttributes(_ attributes: AttributeContainer)

    mutating func mergeAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy)

    mutating func replaceAttributes(_ attributes: AttributeContainer, with others: AttributeContainer)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol AttributedStringKey {

    associatedtype Value : Hashable

    static var name: String { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    static var runBoundaries: AttributedString.AttributeRunBoundaries? { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    static var inheritedByAddedText: Bool { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    static var invalidationConditions: Set<AttributedString.AttributeInvalidationCondition>? { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringKey {

    public var description: String { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public static var runBoundaries: AttributedString.AttributeRunBoundaries? { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public static var inheritedByAddedText: Bool { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public static var invalidationConditions: Set<AttributedString.AttributeInvalidationCondition>? { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public protocol AttributedStringProtocol : AttributedStringAttributeMutation, CustomStringConvertible, Hashable, Sendable {

    var startIndex: AttributedString.Index { get }

    var endIndex: AttributedString.Index { get }

    var runs: AttributedString.Runs { get }

    var characters: AttributedString.CharacterView { get }

    var unicodeScalars: AttributedString.UnicodeScalarView { get }

    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    var utf8: AttributedString.UTF8View { get }

    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    var utf16: AttributedString.UTF16View { get }

    @preconcurrency subscript<K>(_: K.Type) -> K.Value? where K : AttributedStringKey, K.Value : Sendable { get set }

    @preconcurrency subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey, K.Value : Sendable { get set }

    subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope { get set }

    subscript<R>(bounds: R) -> AttributedSubstring where R : RangeExpression, R.Bound == AttributedString.Index { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {

    public func settingAttributes(_ attributes: AttributeContainer) -> AttributedString

    public func mergingAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew) -> AttributedString

    public func replacingAttributes(_ attributes: AttributeContainer, with others: AttributeContainer) -> AttributedString
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {

    public static func == <RHS>(lhs: Self, rhs: RHS) -> Bool where RHS : AttributedStringProtocol

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {

    public func index(afterCharacter i: AttributedString.Index) -> AttributedString.Index

    public func index(beforeCharacter i: AttributedString.Index) -> AttributedString.Index

    public func index(_ i: AttributedString.Index, offsetByCharacters distance: Int) -> AttributedString.Index

    public func index(afterUnicodeScalar i: AttributedString.Index) -> AttributedString.Index

    public func index(beforeUnicodeScalar i: AttributedString.Index) -> AttributedString.Index

    public func index(_ i: AttributedString.Index, offsetByUnicodeScalars distance: Int) -> AttributedString.Index

    public func index(afterRun i: AttributedString.Index) -> AttributedString.Index

    public func index(beforeRun i: AttributedString.Index) -> AttributedString.Index

    public func index(_ i: AttributedString.Index, offsetByRuns distance: Int) -> AttributedString.Index
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedStringProtocol {

    public func range<T>(of stringToFind: T, options: String.CompareOptions = [], locale: Locale? = nil) -> Range<AttributedString.Index>? where T : StringProtocol
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedStringProtocol {

    /// Returns a discontiguous substring of this attributed string using a set of ranges to indicate the discontiguous substring bounds.
    /// - Parameter indices:  A set of ranges that indicate the bounds of the discontiguous substring to return.
    public subscript(indices: RangeSet<AttributedString.Index>) -> DiscontiguousAttributedSubstring { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct AttributedSubstring : Sendable {

    public init()
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedSubstring {

    /// A view of the attributed substring's contents as a collection of UTF-8 code units.
    public var utf8: AttributedString.UTF8View { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension AttributedSubstring {

    /// A view of the attributed substring's contents as a collection of UTF-16 code units.
    public var utf16: AttributedString.UTF16View { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedSubstring {

    public var base: AttributedString { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedSubstring {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedSubstring {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: AttributedSubstring, rhs: AttributedSubstring) -> Bool
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedSubstring : AttributedStringProtocol {

    public var startIndex: AttributedString.Index { get }

    public var endIndex: AttributedString.Index { get }

    public mutating func setAttributes(_ attributes: AttributeContainer)

    public mutating func mergeAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew)

    public mutating func replaceAttributes(_ attributes: AttributeContainer, with others: AttributeContainer)

    public var runs: AttributedString.Runs { get }

    public var characters: AttributedString.CharacterView { get }

    public var unicodeScalars: AttributedString.UnicodeScalarView { get }

    public subscript(bounds: some RangeExpression<AttributedString.Index>) -> AttributedSubstring { get }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension AttributedSubstring {

    @preconcurrency public subscript<K>(_: K.Type) -> K.Value? where K : AttributedStringKey, K.Value : Sendable

    @preconcurrency @inlinable public subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey, K.Value : Sendable

    public subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ByteCountFormatStyle : FormatStyle, Sendable {

    public var style: ByteCountFormatStyle.Style

    public var allowedUnits: ByteCountFormatStyle.Units

    public var spellsOutZero: Bool

    public var includesActualByteCount: Bool

    public var locale: Locale

    public var attributed: ByteCountFormatStyle.Attributed

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: Int64) -> String

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> ByteCountFormatStyle

    public init(style: ByteCountFormatStyle.Style = .file, allowedUnits: ByteCountFormatStyle.Units = .all, spellsOutZero: Bool = true, includesActualByteCount: Bool = false, locale: Locale = .autoupdatingCurrent)

    public enum Style : Int, Codable, Hashable, Sendable {

        case file

        case memory

        case decimal

        case binary

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    public struct Units : OptionSet, Codable, Hashable, Sendable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: UInt

        /// Creates a new option set from the given raw value.
        ///
        /// This initializer always succeeds, even if the value passed as `rawValue`
        /// exceeds the static properties declared as part of the option set. This
        /// example creates an instance of `ShippingOptions` with a raw value beyond
        /// the highest element, with a bit mask that effectively contains all the
        /// declared static members.
        ///
        ///     let extraOptions = ShippingOptions(rawValue: 255)
        ///     print(extraOptions.isStrictSuperset(of: .all))
        ///     // Prints "true"
        ///
        /// - Parameter rawValue: The raw value of the option set to create. Each bit
        ///   of `rawValue` potentially represents an element of the option set,
        ///   though raw values may include bits that are not defined as distinct
        ///   values of the `OptionSet` type.
        public init(rawValue: UInt)

        public static var bytes: ByteCountFormatStyle.Units { get }

        public static var kb: ByteCountFormatStyle.Units { get }

        public static var mb: ByteCountFormatStyle.Units { get }

        public static var gb: ByteCountFormatStyle.Units { get }

        public static var tb: ByteCountFormatStyle.Units { get }

        public static var pb: ByteCountFormatStyle.Units { get }

        public static var eb: ByteCountFormatStyle.Units { get }

        public static var zb: ByteCountFormatStyle.Units { get }

        public static var ybOrHigher: ByteCountFormatStyle.Units { get }

        public static var all: ByteCountFormatStyle.Units { get }

        public static var `default`: ByteCountFormatStyle.Units { get }

        /// The type of the elements of an array literal.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias ArrayLiteralElement = ByteCountFormatStyle.Units

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Element = ByteCountFormatStyle.Units

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias RawValue = UInt
    }

    public struct Attributed : FormatStyle, Sendable {

        public var style: ByteCountFormatStyle.Style

        public var allowedUnits: ByteCountFormatStyle.Units

        public var spellsOutZero: Bool

        public var includesActualByteCount: Bool

        public var locale: Locale

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> ByteCountFormatStyle.Attributed

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ value: Int64) -> AttributedString

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: ByteCountFormatStyle.Attributed, b: ByteCountFormatStyle.Attributed) -> Bool

        /// The type of data to format.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatInput = Int64

        /// The type of the formatted data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatOutput = AttributedString

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ByteCountFormatStyle, b: ByteCountFormatStyle) -> Bool

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Int64

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ByteCountFormatStyle.Style : RawRepresentable {
}

/**
 `Calendar` encapsulates information about systems of reckoning time in which the beginning, length, and divisions of a year are defined. It provides information about the calendar and support for calendrical computations such as determining the range of a given calendrical unit and adding units to a given absolute time.
*/
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct Calendar : Hashable, Equatable, Sendable {

    /// Calendar supports many different kinds of calendars. Each is identified by an identifier here.
    public enum Identifier : Sendable, CustomDebugStringConvertible {

        /// The common calendar in Europe, the Western Hemisphere, and elsewhere.
        case gregorian

        case buddhist

        case chinese

        case coptic

        case ethiopicAmeteMihret

        case ethiopicAmeteAlem

        case hebrew

        case iso8601

        case indian

        case islamic

        case islamicCivil

        case japanese

        case persian

        case republicOfChina

        /// A simple tabular Islamic calendar using the astronomical/Thursday epoch of CE 622 July 15
        @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
        case islamicTabular

        /// The Islamic Umm al-Qura calendar used in Saudi Arabia. This is based on astronomical calculation, instead of tabular behavior.
        @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
        case islamicUmmAlQura

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case bangla

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case gujarati

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case kannada

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case malayalam

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case marathi

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case odia

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case tamil

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case telugu

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case vikram

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case dangi

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case vietnamese

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Calendar.Identifier, b: Calendar.Identifier) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An enumeration for the various components of a calendar date.
    ///
    /// Several `Calendar` APIs use either a single unit or a set of units as input to a search algorithm.
    ///
    /// - seealso: `DateComponents`
    public enum Component : Sendable {

        case era

        case year

        case month

        case day

        case hour

        case minute

        case second

        case weekday

        case weekdayOrdinal

        case quarter

        case weekOfMonth

        case weekOfYear

        case yearForWeekOfYear

        case nanosecond

        case calendar

        case timeZone

        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        case isLeapMonth

        @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
        case isRepeatedDay

        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        case dayOfYear

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Calendar.Component, b: Calendar.Component) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Returns the user's current calendar.
    ///
    /// This calendar does not track changes that the user makes to their preferences.
    public static var current: Calendar { get }

    /// A Calendar that tracks changes to user's preferred calendar.
    ///
    /// If mutated, this calendar will no longer track the user's preferred calendar.
    ///
    /// - note: The autoupdating Calendar will only compare equal to another autoupdating Calendar.
    public static var autoupdatingCurrent: Calendar { get }

    /// Returns a new Calendar.
    ///
    /// - parameter identifier: The kind of calendar to use.
    public init(identifier: Calendar.Identifier)

    /// The identifier of the calendar.
    public var identifier: Calendar.Identifier { get }

    /// The locale of the calendar.
    public var locale: Locale?

    /// The time zone of the calendar.
    public var timeZone: TimeZone

    /// The first weekday of the calendar.
    public var firstWeekday: Int

    /// The number of minimum days in the first week.
    public var minimumDaysInFirstWeek: Int

    /// Returns the minimum range limits of the values that a given component can take on in the receiver.
    ///
    /// As an example, in the Gregorian calendar the minimum range of values for the Day component is 1-28.
    /// - parameter component: A component to calculate a range for.
    /// - returns: The range, or nil if it could not be calculated.
    public func minimumRange(of component: Calendar.Component) -> Range<Int>?

    /// The maximum range limits of the values that a given component can take on in the receive
    ///
    /// As an example, in the Gregorian calendar the maximum range of values for the Day component is 1-31.
    /// - parameter component: A component to calculate a range for.
    /// - returns: The range, or nil if it could not be calculated.
    public func maximumRange(of component: Calendar.Component) -> Range<Int>?

    /// Returns the range of absolute time values that a smaller calendar component (such as a day) can take on in a larger calendar component (such as a month) that includes a specified absolute time.
    ///
    /// You can use this method to calculate, for example, the range the `day` component can take on in the `month` in which `date` lies.
    /// - parameter smaller: The smaller calendar component.
    /// - parameter larger: The larger calendar component.
    /// - parameter date: The absolute time for which the calculation is performed.
    /// - returns: The range of absolute time values smaller can take on in larger at the time specified by date. Returns `nil` if larger is not logically bigger than smaller in the calendar, or the given combination of components does not make sense (or is a computation which is undefined).
    public func range(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Range<Int>?

    /// Returns, via two inout parameters, the starting time and duration of a given calendar component that contains a given date.
    ///
    /// - seealso: `range(of:for:)`
    /// - seealso: `dateInterval(of:for:)`
    /// - parameter component: A calendar component.
    /// - parameter start: Upon return, the starting time of the calendar component that contains the date.
    /// - parameter interval: Upon return, the duration of the calendar component that contains the date.
    /// - parameter date: The specified date.
    /// - returns: `true` if the starting time and duration of a component could be calculated, otherwise `false`.
    public func dateInterval(of component: Calendar.Component, start: inout Date, interval: inout TimeInterval, for date: Date) -> Bool

    /// Returns the starting time and duration of a given calendar component that contains a given date.
    ///
    /// - parameter component: A calendar component.
    /// - parameter date: The specified date.
    /// - returns: A new `DateInterval` if the starting time and duration of a component could be calculated, otherwise `nil`.
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public func dateInterval(of component: Calendar.Component, for date: Date) -> DateInterval?

    /// Returns, for a given absolute time, the ordinal number of a smaller calendar component (such as a day) within a specified larger calendar component (such as a week).
    ///
    /// The ordinality is in most cases not the same as the decomposed value of the component. Typically return values are 1 and greater. For example, the time 00:45 is in the first hour of the day, and for components `hour` and `day` respectively, the result would be 1. An exception is the week-in-month calculation, which returns 0 for days before the first week in the month containing the date.
    ///
    /// - note: Some computations can take a relatively long time.
    /// - parameter smaller: The smaller calendar component.
    /// - parameter larger: The larger calendar component.
    /// - parameter date: The absolute time for which the calculation is performed.
    /// - returns: The ordinal number of smaller within larger at the time specified by date. Returns `nil` if larger is not logically bigger than smaller in the calendar, or the given combination of components does not make sense (or is a computation which is undefined).
    public func ordinality(of smaller: Calendar.Component, in larger: Calendar.Component, for date: Date) -> Int?

    /// Returns a new `Date` representing the date calculated by adding components to a given date.
    ///
    /// - parameter components: A set of values to add to the date.
    /// - parameter date: The starting date.
    /// - parameter wrappingComponents: If `true`, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is `false`.
    /// - returns: A new date, or nil if a date could not be calculated with the given input.
    public func date(byAdding components: DateComponents, to date: Date, wrappingComponents: Bool = false) -> Date?

    /// Returns a new `Date` representing the date calculated by adding an amount of a specific component to a given date.
    ///
    /// - parameter component: A single component to add.
    /// - parameter value: The value of the specified component to add.
    /// - parameter date: The starting date.
    /// - parameter wrappingComponents: If `true`, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is `false`.
    /// - returns: A new date, or nil if a date could not be calculated with the given input.
    @available(iOS 8.0, *)
    public func date(byAdding component: Calendar.Component, value: Int, to date: Date, wrappingComponents: Bool = false) -> Date?

    /// Returns a sequence of `Date`s, calculated by adding a scaled amount of `Calendar.Component`s to a starting `Date`.
    /// If a range is supplied, the sequence terminates if the next result is not contained in the range. The starting point does not need to be contained in the range, but if the first result is outside of the range then the result will be an empty sequence.
    ///
    /// - parameter start: The starting point of the search.
    /// - parameter range: The range of dates to allow in the result. The sequence terminates if the next result is not contained in this range. If `nil`, all results are allowed.
    /// - parameter component: A component to add or subtract.
    /// - parameter value: The value of the specified component to add or subtract. The default value is `1`. The value can be negative, which causes subtraction.
    /// - parameter wrappingComponents: If `true`, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is `false`.
    /// - returns: A `Sequence` of `Date` values, or an empty sequence if no addition could be performed.
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public func dates(byAdding component: Calendar.Component, value: Int = 1, startingAt start: Date, in range: Range<Date>? = nil, wrappingComponents: Bool = false) -> some Sendable & Sequence<Date>


    /// Returns a sequence of `Date`s, calculated by repeatedly adding an amount of `DateComponents` to a starting `Date` and then to each subsequent result.
    /// If a range is supplied, the sequence terminates if the next result is not contained in the range. The starting point does not need to be contained in the range, but if the first result is outside of the range then the result will be an empty sequence.
    ///
    /// - parameter start: The starting point of the search.
    /// - parameter range: The range of dates to allow in the result. The sequence terminates if the next result is not contained in this range. If `nil`, all results are allowed.
    /// - parameter components: The components to add or subtract.
    /// - parameter wrappingComponents: If `true`, the component should be incremented and wrap around to zero/one on overflow, and should not cause higher components to be incremented. The default value is `false`.
    /// - returns: A `Sequence` of `Date` values, or an empty sequence if no addition could be performed.
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public func dates(byAdding components: DateComponents, startingAt start: Date, in range: Range<Date>? = nil, wrappingComponents: Bool = false) -> some Sendable & Sequence<Date>


    /// Returns a date created from the specified components.
    ///
    /// - parameter components: Used as input to the search algorithm for finding a corresponding date.
    /// - returns: A new `Date`, or nil if a date could not be found which matches the components.
    public func date(from components: DateComponents) -> Date?

    /// Returns all the date components of a date, using the calendar time zone.
    ///
    /// - note: If you want "date information in a given time zone" in order to display it, you should use `DateFormatter` to format the date.
    /// - parameter date: The `Date` to use.
    /// - returns: The date components of the specified date.
    public func dateComponents(_ components: Set<Calendar.Component>, from date: Date) -> DateComponents

    /// Returns all the date components of a date, as if in a given time zone (instead of the `Calendar` time zone).
    ///
    /// The time zone overrides the time zone of the `Calendar` for the purposes of this calculation.
    /// - note: If you want "date information in a given time zone" in order to display it, you should use `DateFormatter` to format the date.
    /// - parameter timeZone: The `TimeZone` to use.
    /// - parameter date: The `Date` to use.
    /// - returns: All components, calculated using the `Calendar` and `TimeZone`.
    @available(iOS 8.0, *)
    public func dateComponents(in timeZone: TimeZone, from date: Date) -> DateComponents

    /// Returns the difference between two dates.
    ///
    /// - parameter components: Which components to compare.
    /// - parameter start: The starting date.
    /// - parameter end: The ending date.
    /// - returns: The result of calculating the difference from start to end.
    public func dateComponents(_ components: Set<Calendar.Component>, from start: Date, to end: Date) -> DateComponents

    /// Returns the difference between two dates specified as `DateComponents`.
    ///
    /// For components which are not specified in each `DateComponents`, but required to specify an absolute date, the base value of the component is assumed.  For example, for an `DateComponents` with just a `year` and a `month` specified, a `day` of 1, and an `hour`, `minute`, `second`, and `nanosecond` of 0 are assumed.
    /// Calendrical calculations with unspecified `year` or `year` value prior to the start of a calendar are not advised.
    /// For each `DateComponents`, if its `timeZone` property is set, that time zone is used for it. If the `calendar` property is set, that is used rather than the receiving calendar, and if both the `calendar` and `timeZone` are set, the `timeZone` property value overrides the time zone of the `calendar` property.
    ///
    /// - parameter components: Which components to compare.
    /// - parameter start: The starting date components.
    /// - parameter end: The ending date components.
    /// - returns: The result of calculating the difference from start to end.
    @available(iOS 8.0, *)
    public func dateComponents(_ components: Set<Calendar.Component>, from start: DateComponents, to end: DateComponents) -> DateComponents

    /// Returns the value for one component of a date.
    ///
    /// - parameter component: The component to calculate.
    /// - parameter date: The date to use.
    /// - returns: The value for the component.
    @available(iOS 8.0, *)
    public func component(_ component: Calendar.Component, from date: Date) -> Int

    /// Returns the first moment of a given Date, as a Date.
    ///
    /// For example, pass in `Date()`, if you want the start of today.
    /// If there were two midnights, it returns the first.  If there was none, it returns the first moment that did exist.
    /// - parameter date: The date to search.
    /// - returns: The first moment of the given date.
    @available(iOS 8.0, *)
    public func startOfDay(for date: Date) -> Date

    /// Compares the given dates down to the given component, reporting them `orderedSame` if they are the same in the given component and all larger components, otherwise either `orderedAscending` or `orderedDescending`.
    ///
    /// - parameter date1: A date to compare.
    /// - parameter date2: A date to compare.
    /// - parameter: component: A granularity to compare. For example, pass `.hour` to check if two dates are in the same hour.
    @available(iOS 8.0, *)
    public func compare(_ date1: Date, to date2: Date, toGranularity component: Calendar.Component) -> ComparisonResult

    /// Compares the given dates down to the given component, reporting them equal if they are the same in the given component and all larger components.
    ///
    /// - parameter date1: A date to compare.
    /// - parameter date2: A date to compare.
    /// - parameter component: A granularity to compare. For example, pass `.hour` to check if two dates are in the same hour.
    /// - returns: `true` if the given date is within tomorrow.
    @available(iOS 8.0, *)
    public func isDate(_ date1: Date, equalTo date2: Date, toGranularity component: Calendar.Component) -> Bool

    /// Returns `true` if the given date is within the same day as another date, as defined by the calendar and calendar's locale.
    ///
    /// - parameter date1: A date to check for containment.
    /// - parameter date2: A date to check for containment.
    /// - returns: `true` if `date1` and `date2` are in the same day.
    @available(iOS 8.0, *)
    public func isDate(_ date1: Date, inSameDayAs date2: Date) -> Bool

    /// Returns `true` if the given date is within today, as defined by the calendar and calendar's locale.
    ///
    /// - parameter date: The specified date.
    /// - returns: `true` if the given date is within today.
    @available(iOS 8.0, *)
    public func isDateInToday(_ date: Date) -> Bool

    /// Returns `true` if the given date is within yesterday, as defined by the calendar and calendar's locale.
    ///
    /// - parameter date: The specified date.
    /// - returns: `true` if the given date is within yesterday.
    @available(iOS 8.0, *)
    public func isDateInYesterday(_ date: Date) -> Bool

    /// Returns `true` if the given date is within tomorrow, as defined by the calendar and calendar's locale.
    ///
    /// - parameter date: The specified date.
    /// - returns: `true` if the given date is within tomorrow.
    @available(iOS 8.0, *)
    public func isDateInTomorrow(_ date: Date) -> Bool

    /// Returns `true` if the given date is within a weekend period, as defined by the calendar and calendar's locale.
    ///
    /// - parameter date: The specified date.
    /// - returns: `true` if the given date is within a weekend.
    @available(iOS 8.0, *)
    public func isDateInWeekend(_ date: Date) -> Bool

    /// Finds the range of the weekend around the given date, and returns the starting date and duration of the weekend via two inout parameters.
    ///
    /// Note that a given entire day within a calendar is not necessarily all in a weekend or not; weekends can start in the middle of a day in some calendars and locales.
    /// - seealso: `dateIntervalOfWeekend(containing:)`
    /// - parameter date: The date at which to start the search.
    /// - parameter start: Upon return, the starting date of the weekend if found.
    /// - parameter interval: Upon return, the duration of the weekend if found.
    /// - returns: `true` if a date range could be found, and `false` if the date is not in a weekend.
    @available(iOS 8.0, *)
    public func dateIntervalOfWeekend(containing date: Date, start: inout Date, interval: inout TimeInterval) -> Bool

    /// Returns a `DateInterval` of the weekend contained by the given date, or nil if the date is not in a weekend.
    ///
    /// - parameter date: The date contained in the weekend.
    /// - returns: A `DateInterval`, or nil if the date is not in a weekend.
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public func dateIntervalOfWeekend(containing date: Date) -> DateInterval?

    /// Returns the range of the next weekend via two inout parameters. The weekend starts strictly after the given date.
    ///
    /// If `direction` is `.backward`, then finds the previous weekend range strictly before the given date.
    ///
    /// Note that a given entire Day within a calendar is not necessarily all in a weekend or not; weekends can start in the middle of a day in some calendars and locales.
    /// - parameter date: The date at which to begin the search.
    /// - parameter start: Upon return, the starting date of the next weekend if found.
    /// - parameter interval: Upon return, the duration of the next weekend if found.
    /// - parameter direction: Which direction in time to search. The default value is `.forward`.
    /// - returns: `true` if the next weekend is found.
    @available(iOS 8.0, *)
    public func nextWeekend(startingAfter date: Date, start: inout Date, interval: inout TimeInterval, direction: Calendar.SearchDirection = .forward) -> Bool

    /// Returns a `DateInterval` of the next weekend, which starts strictly after the given date.
    ///
    /// If `direction` is `.backward`, then finds the previous weekend range strictly before the given date.
    ///
    /// Note that a given entire Day within a calendar is not necessarily all in a weekend or not; weekends can start in the middle of a day in some calendars and locales.
    /// - parameter date: The date at which to begin the search.
    /// - parameter direction: Which direction in time to search. The default value is `.forward`.
    /// - returns: A `DateInterval`, or nil if weekends do not exist in the specific calendar or locale.
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public func nextWeekend(startingAfter date: Date, direction: Calendar.SearchDirection = .forward) -> DateInterval?

    /// The direction in time to search.
    public enum SearchDirection : Sendable {

        /// Search for a date later in time than the start date.
        case forward

        /// Search for a date earlier in time than the start date.
        case backward

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Calendar.SearchDirection, b: Calendar.SearchDirection) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Determines which result to use when a time is repeated on a day in a calendar (for example, during a daylight saving transition when the times between 2:00am and 3:00am may happen twice).
    public enum RepeatedTimePolicy : Sendable {

        /// If there are two or more matching times (all the components are the same, including isLeapMonth) before the end of the next instance of the next higher component to the highest specified component, then the algorithm will return the first occurrence.
        case first

        /// If there are two or more matching times (all the components are the same, including isLeapMonth) before the end of the next instance of the next higher component to the highest specified component, then the algorithm will return the last occurrence.
        case last

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Calendar.RepeatedTimePolicy, b: Calendar.RepeatedTimePolicy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A hint to the search algorithm to control the method used for searching for dates.
    public enum MatchingPolicy : Sendable, Equatable {

        /// If there is no matching time before the end of the next instance of the next higher component to the highest specified component in the `DateComponents` argument, the algorithm will return the next existing time which exists.
        ///
        /// For example, during a daylight saving transition there may be no 2:37am. The result would then be 3:00am, if that does exist.
        case nextTime

        /// If specified, and there is no matching time before the end of the next instance of the next higher component to the highest specified component in the `DateComponents` argument, the method will return the next existing value of the missing component and preserves the lower components' values (e.g., no 2:37am results in 3:37am, if that exists).
        case nextTimePreservingSmallerComponents

        /// If there is no matching time before the end of the next instance of the next higher component to the highest specified component in the `DateComponents` argument, the algorithm will return the previous existing value of the missing component and preserves the lower components' values.
        ///
        /// For example, during a daylight saving transition there may be no 2:37am. The result would then be 1:37am, if that does exist.
        case previousTimePreservingSmallerComponents

        /// If specified, the algorithm travels as far forward or backward as necessary looking for a match.
        ///
        /// For example, if searching for Feb 29 in the Gregorian calendar, the algorithm may choose March 1 instead (for example, if the year is not a leap year). If you wish to find the next Feb 29 without the algorithm adjusting the next higher component in the specified `DateComponents`, then use the `strict` option.
        /// - note: There are ultimately implementation-defined limits in how far distant the search will go.
        case strict

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Calendar.MatchingPolicy, b: Calendar.MatchingPolicy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Computes the dates which match (or most closely match) a given set of components, and calls the closure once for each of them, until the enumeration is stopped.
    ///
    /// There will be at least one intervening date which does not match all the components (or the given date itself must not match) between the given date and any result.
    ///
    /// If `direction` is set to `.backward`, this method finds the previous match before the given date. The intent is that the same matches as for a `.forward` search will be found (that is, if you are enumerating forwards or backwards for each hour with minute "27", the seconds in the date you will get in forwards search would obviously be 00, and the same will be true in a backwards search in order to implement this rule.  Similarly for DST backwards jumps which repeats times, you'll get the first match by default, where "first" is defined from the point of view of searching forwards.  So, when searching backwards looking for a particular hour, with no minute and second specified, you don't get a minute and second of 59:59 for the matching hour (which would be the nominal first match within a given hour, given the other rules here, when searching backwards).
    ///
    /// If an exact match is not possible, and requested with the `strict` option, nil is passed to the closure and the enumeration ends.  (Logically, since an exact match searches indefinitely into the future, if no match is found there's no point in continuing the enumeration.)
    ///
    /// Result dates have an integer number of seconds (as if 0 was specified for the nanoseconds property of the `DateComponents` matching parameter), unless a value was set in the nanoseconds property, in which case the result date will have that number of nanoseconds (or as close as possible with floating point numbers).
    ///
    /// The enumeration is stopped by setting `stop` to `true` in the closure and returning. It is not necessary to set `stop` to `false` to keep the enumeration going.
    /// - parameter start: The `Date` at which to start the search.
    /// - parameter components: The `DateComponents` to use as input to the search algorithm.
    /// - parameter matchingPolicy: Determines the behavior of the search algorithm when the input produces an ambiguous result.
    /// - parameter repeatedTimePolicy: Determines the behavior of the search algorithm when the input produces a time that occurs twice on a particular day.
    /// - parameter direction: Which direction in time to search. The default value is `.forward`, which means later in time.
    /// - parameter block: A closure that is called with search results.
    @available(iOS 8.0, *)
    public func enumerateDates(startingAfter start: Date, matching components: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward, using block: (_ result: Date?, _ exactMatch: Bool, _ stop: inout Bool) -> Void)

    /// Computes the dates which match (or most closely match) a given set of components, returned as a `Sequence`.
    ///
    /// If `direction` is set to `.backward`, this method finds the previous match before the start date. The intent is that the same matches as for a `.forward` search will be found. For example, if you are searching forwards or backwards for each hour with minute "27", the seconds in the date you will get in both a `.forward` and `.backward` search would be `00`.  Similarly, for DST backwards jumps which repeat times, you'll get the first match by default, where "first" is defined from the point of view of searching forwards. Therefore, when searching backwards looking for a particular hour, with no minute and second specified, you don't get a minute and second of `59:59` for the matching hour but instead `00:00`.
    ///
    /// If a range is supplied, the sequence terminates if the next result is not contained in the range. The starting point does not need to be contained in the range, but if the first result is outside of the range then the result will be an empty sequence.
    ///
    /// If an exact match is not possible, and requested with the `strict` option, the sequence ends.
    ///
    /// Result dates have an integer number of seconds (as if 0 was specified for the nanoseconds property of the `DateComponents` matching parameter), unless a value was set in the nanoseconds property, in which case the result date will have that number of nanoseconds, or as close as possible with floating point numbers.
    /// - parameter start: The `Date` at which to start the search.
    /// - parameter range: The range of dates to allow in the result. The sequence terminates if the next result is not contained in this range. If `nil`, all results are allowed.
    /// - parameter components: The `DateComponents` to use as input to the search algorithm.
    /// - parameter matchingPolicy: Determines the behavior of the search algorithm when the input produces an ambiguous result.
    /// - parameter repeatedTimePolicy: Determines the behavior of the search algorithm when the input produces a time that occurs twice on a particular day.
    /// - parameter direction: Which direction in time to search. The default value is `.forward`, which means later in time.
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public func dates(byMatching components: DateComponents, startingAt start: Date, in range: Range<Date>? = nil, matchingPolicy: Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward) -> some Sendable & Sequence<Date>


    /// Computes the next date which matches (or most closely matches) a given set of components.
    ///
    /// The general semantics follow those of the `enumerateDates` function.
    /// To compute a sequence of results, use the `enumerateDates` function, rather than looping and calling this method with the previous loop iteration's result.
    /// - parameter date: The starting date.
    /// - parameter components: The components to search for.
    /// - parameter matchingPolicy: Specifies the technique the search algorithm uses to find results. Default value is `.nextTime`.
    /// - parameter repeatedTimePolicy: Specifies the behavior when multiple matches are found. Default value is `.first`.
    /// - parameter direction: Specifies the direction in time to search. Default is `.forward`.
    /// - returns: A `Date` representing the result of the search, or `nil` if a result could not be found.
    @available(iOS 8.0, *)
    public func nextDate(after date: Date, matching components: DateComponents, matchingPolicy: Calendar.MatchingPolicy, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward) -> Date?

    /// Returns a new `Date` representing the date calculated by setting a specific component to a given time, and trying to keep lower components the same.  If the component already has that value, this may result in a date which is the same as the given date.
    ///
    /// Changing a component's value often will require higher or coupled components to change as well.  For example, setting the Weekday to Thursday usually will require the Day component to change its value, and possibly the Month and Year as well.
    /// If no such time exists, the next available time is returned (which could, for example, be in a different day, week, month, ... than the nominal target date).  Setting a component to something which would be inconsistent forces other components to change; for example, setting the Weekday to Thursday probably shifts the Day and possibly Month and Year.
    /// The exact behavior of this method is implementation-defined. For example, if changing the weekday to Thursday, does that move forward to the next, backward to the previous, or to the nearest Thursday? The algorithm will try to produce a result which is in the next-larger component to the one given (there's a table of this mapping at the top of this document).  So for the "set to Thursday" example, find the Thursday in the Week in which the given date resides (which could be a forwards or backwards move, and not necessarily the nearest Thursday). For more control over the exact behavior, use `nextDate(after:matching:matchingPolicy:behavior:direction:)`.
    @available(iOS 8.0, *)
    public func date(bySetting component: Calendar.Component, value: Int, of date: Date) -> Date?

    /// Returns a new `Date` representing the date calculated by setting hour, minute, and second to a given time on a specified `Date`.
    ///
    /// If no such time exists, the next available time is returned (which could, for example, be in a different day than the nominal target date).
    /// The intent is to return a date on the same day as the original date argument.  This may result in a date which is backward than the given date, of course.
    /// - parameter hour: A specified hour.
    /// - parameter minute: A specified minute.
    /// - parameter second: A specified second.
    /// - parameter date: The date to start calculation with.
    /// - parameter matchingPolicy: Specifies the technique the search algorithm uses to find results. Default value is `.nextTime`.
    /// - parameter repeatedTimePolicy: Specifies the behavior when multiple matches are found. Default value is `.first`.
    /// - parameter direction: Specifies the direction in time to search. Default is `.forward`.
    /// - returns: A `Date` representing the result of the search, or `nil` if a result could not be found.
    @available(iOS 8.0, *)
    public func date(bySettingHour hour: Int, minute: Int, second: Int, of date: Date, matchingPolicy: Calendar.MatchingPolicy = .nextTime, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, direction: Calendar.SearchDirection = .forward) -> Date?

    /// Determine if the `Date` has all of the specified `DateComponents`.
    ///
    /// It may be useful to test the return value of `nextDate(after:matching:matchingPolicy:behavior:direction:)` to find out if the components were obeyed or if the method had to fudge the result value due to missing time (for example, a daylight saving time transition).
    ///
    /// - returns: `true` if the date matches all of the components, otherwise `false`.
    @available(iOS 8.0, *)
    public func date(_ date: Date, matchesComponents components: DateComponents) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Calendar, rhs: Calendar) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar {

    /// A list of eras in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["BC", "AD"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var eraSymbols: [String] { get }

    /// A list of longer-named eras in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["Before Christ", "Anno Domini"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var longEraSymbols: [String] { get }

    /// A list of months in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var monthSymbols: [String] { get }

    /// A list of shorter-named months in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var shortMonthSymbols: [String] { get }

    /// A list of very-shortly-named months in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var veryShortMonthSymbols: [String] { get }

    /// A list of standalone months in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]`.
    /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var standaloneMonthSymbols: [String] { get }

    /// A list of shorter-named standalone months in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]`.
    /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var shortStandaloneMonthSymbols: [String] { get }

    /// A list of very-shortly-named standalone months in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]`.
    /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var veryShortStandaloneMonthSymbols: [String] { get }

    /// A list of weekdays in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var weekdaySymbols: [String] { get }

    /// A list of shorter-named weekdays in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var shortWeekdaySymbols: [String] { get }

    /// A list of very-shortly-named weekdays in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["S", "M", "T", "W", "T", "F", "S"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var veryShortWeekdaySymbols: [String] { get }

    /// A list of standalone weekday names in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]`.
    /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var standaloneWeekdaySymbols: [String] { get }

    /// A list of shorter-named standalone weekdays in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]`.
    /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var shortStandaloneWeekdaySymbols: [String] { get }

    /// A list of very-shortly-named weekdays in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["S", "M", "T", "W", "T", "F", "S"]`.
    /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var veryShortStandaloneWeekdaySymbols: [String] { get }

    /// A list of quarter names in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var quarterSymbols: [String] { get }

    /// A list of shorter-named quarters in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["Q1", "Q2", "Q3", "Q4"]`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var shortQuarterSymbols: [String] { get }

    /// A list of standalone quarter names in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]`.
    /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var standaloneQuarterSymbols: [String] { get }

    /// A list of shorter-named standalone quarters in this calendar, localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `["Q1", "Q2", "Q3", "Q4"]`.
    /// - note: Stand-alone properties are for use in places like calendar headers. Non-stand-alone properties are for use in context (for example, "Saturday, November 12th").
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var shortStandaloneQuarterSymbols: [String] { get }

    /// The symbol used to represent "AM", localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `"AM"`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var amSymbol: String { get }

    /// The symbol used to represent "PM", localized to the Calendar's `locale`.
    ///
    /// For example, for English in the Gregorian calendar, returns `"PM"`.
    ///
    /// - note: By default, Calendars have no locale set. If you wish to receive a localized answer, be sure to set the `locale` property first - most likely to `Locale.autoupdatingCurrent`.
    public var pmSymbol: String { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar : CustomDebugStringConvertible, CustomStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar : ReferenceConvertible {

    public typealias ReferenceType = NSCalendar
}

extension Calendar {

    /// A rule which specifies how often an event should repeat in the future
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public struct RecurrenceRule : Sendable, Equatable {

        /// The calendar in which the recurrence occurs
        public var calendar: Calendar

        /// What to do when a recurrence is not a valid date
        ///
        /// An occurrence may not be a valid date if it falls on a leap day or a
        /// leap hour when there is not one. When that happens, we can choose to
        /// ignore the occurrence (`.strict`), choose a later time which has the
        /// same components (`.nextTimePreservingSmallerComponents`), or find an
        /// earlier time (`.previousTimePreservingSmallerComponents`).
        ///
        /// For example, consider an event happening every year, starting on the
        /// 29th of February 2020. When the matching policy is set to `.strict`,
        /// it yields the following recurrences:
        /// - 2020-02-29
        /// - 2024-02-29
        /// - 2028-02-29
        /// - ...
        ///
        /// With `matchingPolicy` of `.previousTimePreservingSmallerComponents`,
        /// we get a result for each year:
        /// - 2020-02-29
        /// - 2021-02-28
        /// - 2022-02-28
        /// - 2023-02-28
        /// - 2024-02-29
        ///
        /// Lastly, a `matchingPolicy` of `.nextTimePreservingSmallerComponents`
        /// moves invalid occurrences to the day after February 29:
        /// - 2020-02-29
        /// - 2021-03-01
        /// - 2022-03-01
        /// - 2023-03-01
        /// - 2024-02-29
        ///
        /// The same logic applies for missing leap hours during daylight saving
        /// time switches. For example, consider an event repeating daily, which
        /// starts at March 9 2024, 01:30 PST. With a `.strict` matching policy,
        /// the event repeats on the following dates, and skips a day:
        /// - 2024-03-09 01:30 PST (09:30 UTC)
        ///   (on 2024-03-10, there is a missing hour between 1am and 2am)
        /// - 2024-03-11 01:30 PDT (08:30 UTC)
        /// - 2024-03-12 01:30 PDT (08:30 UTC)
        /// With `matchingPolicy` of `.previousTimePreservingSmallerComponents`,
        /// we get a result for each day:
        /// - 2024-03-09 01:30 PST (09:30 UTC)
        /// - 2024-03-10 02:30 PST (10:30 UTC)
        ///   (on 2024-03-10, there is a missing hour between 1am and 2am)
        /// - 2024-03-11 01:30 PDT (08:30 UTC)
        /// - 2024-03-12 01:30 PDT (08:30 UTC)
        /// Lastly, a `matchingPolicy` of `.nextTimePreservingSmallerComponents`
        /// moves invalid occurrences an hour forward:
        /// - 2024-03-09 01:30 PST (09:30 UTC)
        /// - 2024-03-10 00:30 PST (08:30 UTC)
        ///   (on 2024-03-10, there is a missing hour between 1am and 2am)
        /// - 2024-03-11 01:30 PDT (08:30 UTC)
        /// - 2024-03-12 01:30 PDT (08:30 UTC)
        ///
        /// Default value is `.nextTimePreservingSmallerComponents`
        public var matchingPolicy: Calendar.MatchingPolicy

        /// What to do when there are multiple recurrences occurring at the same
        /// time of the day but in different time zones due to a daylight saving
        /// transition.
        ///
        /// For example, an event with daily recurrence rule that starts at 1 am
        /// on November 2 in PDT will repeat on:
        ///
        /// - 2024-11-02 01:00 PDT (08:00 UTC)
        /// - 2024-11-03 01:00 PDT (08:00 UTC), if `repeatedTimePolicy = .first`
        ///   (Time zone switches from PST to PDT - clock jumps back one hour at
        ///    02:00 PDT)
        /// - 2024-11-03 01:00 PST (09:00 UTC), if `repeatedTimePolicy = .last`
        /// - 2024-11-04 01:00 PST (09:00 UTC)
        ///
        /// Due to the time zone switch on November 3, there are different times
        /// when the event might repeat.
        ///
        /// Default value is `.first`
        public var repeatedTimePolicy: Calendar.RepeatedTimePolicy

        /// How often a recurring event repeats
        public enum Frequency : Int, Sendable, Codable, Equatable {

            case minutely

            case hourly

            case daily

            case weekly

            case monthly

            case yearly

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: Int)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
            public typealias RawValue = Int

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: Int { get }
        }

        /// How often the event repeats
        public var frequency: Calendar.RecurrenceRule.Frequency

        /// At what interval to repeat
        ///
        /// Default value is `1`
        public var interval: Int

        /// When a recurring event stops recurring
        public struct End : Sendable, Equatable {

            /// The event stops repeating after a given number of times
            /// - Parameter count: how many times to repeat the event, including
            ///                    the first occurrence. `count` must be greater
            ///                    than `0`
            public static func afterOccurrences(_ count: Int) -> Calendar.RecurrenceRule.End

            /// The event stops repeating after a given date
            /// - Parameter date: the date on which the event may last occur. No
            ///                   further occurrences will be found after that
            public static func afterDate(_ date: Date) -> Calendar.RecurrenceRule.End

            /// The event repeats indefinitely
            public static var never: Calendar.RecurrenceRule.End { get }

            /// At most many times the event may occur
            /// This value is set when the struct was initialized with `.afterOccurrences()`
            @available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
            public var occurrences: Int? { get }

            /// The latest date when the event may occur
            /// This value is set when the struct was initialized with `.afterDate()`
            @available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
            public var date: Date? { get }

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Calendar.RecurrenceRule.End, b: Calendar.RecurrenceRule.End) -> Bool
        }

        /// For how long the event repeats
        ///
        /// Default value is `.never`
        public var end: Calendar.RecurrenceRule.End

        public enum Weekday : Sendable, Equatable {

            /// Repeat on every weekday
            case every(Locale.Weekday)

            /// Repeat on the n-th instance of the specified weekday in a month,
            /// if the recurrence has a monthly frequency. If the recurrence has
            /// a yearly frequency, repeat on the n-th week of the year.
            ///
            /// If n is negative, repeat on the n-to-last of the given weekday.
            case nth(Int, Locale.Weekday)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Calendar.RecurrenceRule.Weekday, b: Calendar.RecurrenceRule.Weekday) -> Bool
        }

        /// Uniquely identifies a month in any calendar system
        public struct Month : Sendable, ExpressibleByIntegerLiteral, Equatable {

            /// A type that represents an integer literal.
            ///
            /// The standard library integer and floating-point types are all valid types
            /// for `IntegerLiteralType`.
            public typealias IntegerLiteralType = Int

            public var index: Int

            public var isLeap: Bool

            public init(_ index: Int, isLeap: Bool = false)

            /// Creates an instance initialized to the specified integer value.
            ///
            /// Do not call this initializer directly. Instead, initialize a variable or
            /// constant using an integer literal. For example:
            ///
            ///     let x = 23
            ///
            /// In this example, the assignment to the `x` constant calls this integer
            /// literal initializer behind the scenes.
            ///
            /// - Parameter value: The value to create.
            public init(integerLiteral value: Int)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Calendar.RecurrenceRule.Month, b: Calendar.RecurrenceRule.Month) -> Bool
        }

        /// On which seconds of the minute the event should repeat. Valid values
        /// between 0 and 60
        public var seconds: [Int]

        /// On which minutes of the hour the event should repeat. Accepts values
        /// between 0 and 59
        public var minutes: [Int]

        /// On which hours of a 24-hour day the event should repeat.
        public var hours: [Int]

        /// On which days of the week the event should occur
        public var weekdays: [Calendar.RecurrenceRule.Weekday]

        /// On which days in the month the event should occur
        /// - 1 signifies the first day of the month.
        /// - Negative values point to a day counted backwards from the last day
        ///   of the month
        /// This field is unused when `frequency` is `.weekly`.
        public var daysOfTheMonth: [Int]

        /// On which days of the year the event may occur.
        /// - 1 signifies the first day of the year.
        /// - Negative values point to a day counted backwards from the last day
        ///   of the year
        /// This field is unused when `frequency` is any of `.daily`, `.weekly`,
        /// or `.monthly`.
        public var daysOfTheYear: [Int]

        /// On which months the event should occur.
        /// - 1 is the first month of the year (January in Gregorian calendars)
        public var months: [Calendar.RecurrenceRule.Month]

        /// On which weeks of the year the event should occur.
        /// - 1 is the first week of the year. `calendar.minimumDaysInFirstWeek`
        ///   defines which week is considered first.
        /// - Negative values refer to weeks if counting backwards from the last
        ///   week of the year. -1 is the last week of the year.
        /// This field is unused when `frequency` is other than `.yearly`.
        public var weeks: [Int]

        /// Which occurrences within every interval should be returned
        public var setPositions: [Int]

        public init(calendar: Calendar, frequency: Calendar.RecurrenceRule.Frequency, interval: Int = 1, end: Calendar.RecurrenceRule.End = .never, matchingPolicy: Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, months: [Calendar.RecurrenceRule.Month] = [], daysOfTheYear: [Int] = [], daysOfTheMonth: [Int] = [], weeks: [Int] = [], weekdays: [Calendar.RecurrenceRule.Weekday] = [], hours: [Int] = [], minutes: [Int] = [], seconds: [Int] = [], setPositions: [Int] = [])

        /// Find recurrences of the given date
        ///
        /// The calculations are implemented according to RFC-5545 and RFC-7529.
        ///
        /// - Parameter start: the date which defines the starting point for the
        ///   recurrence rule.
        /// - Parameter range: a range of dates which to search for recurrences.
        ///   If `nil`, return all recurrences of the event.
        /// - Returns: a sequence of dates conforming to the recurrence rule, in
        ///   the given `range`. An empty sequence if the rule doesn't match any
        ///   dates.
        /// A recurrence that repeats every `interval` minutes
        public func recurrences(of start: Date, in range: Range<Date>? = nil) -> some Sendable & Sequence<Date>


        /// A recurrence that repeats every `interval` minutes
        public static func minutely(calendar: Calendar, interval: Int = 1, end: Calendar.RecurrenceRule.End = .never, matchingPolicy: Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, months: [Calendar.RecurrenceRule.Month] = [], daysOfTheYear: [Int] = [], daysOfTheMonth: [Int] = [], weekdays: [Calendar.RecurrenceRule.Weekday] = [], hours: [Int] = [], minutes: [Int] = [], seconds: [Int] = [], setPositions: [Int] = []) -> Calendar.RecurrenceRule

        /// A recurrence that repeats every `interval` hours
        public static func hourly(calendar: Calendar, interval: Int = 1, end: Calendar.RecurrenceRule.End = .never, matchingPolicy: Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, months: [Calendar.RecurrenceRule.Month] = [], daysOfTheYear: [Int] = [], daysOfTheMonth: [Int] = [], weekdays: [Calendar.RecurrenceRule.Weekday] = [], hours: [Int] = [], minutes: [Int] = [], seconds: [Int] = [], setPositions: [Int] = []) -> Calendar.RecurrenceRule

        /// A recurrence that repeats every `interval` days
        public static func daily(calendar: Calendar, interval: Int = 1, end: Calendar.RecurrenceRule.End = .never, matchingPolicy: Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, months: [Calendar.RecurrenceRule.Month] = [], daysOfTheMonth: [Int] = [], weekdays: [Calendar.RecurrenceRule.Weekday] = [], hours: [Int] = [], minutes: [Int] = [], seconds: [Int] = [], setPositions: [Int] = []) -> Calendar.RecurrenceRule

        /// A recurrence that repeats every `interval` weeks
        public static func weekly(calendar: Calendar, interval: Int = 1, end: Calendar.RecurrenceRule.End = .never, matchingPolicy: Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, months: [Calendar.RecurrenceRule.Month] = [], weekdays: [Calendar.RecurrenceRule.Weekday] = [], hours: [Int] = [], minutes: [Int] = [], seconds: [Int] = [], setPositions: [Int] = []) -> Calendar.RecurrenceRule

        /// A recurrence that repeats every `interval` months
        public static func monthly(calendar: Calendar, interval: Int = 1, end: Calendar.RecurrenceRule.End = .never, matchingPolicy: Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, months: [Calendar.RecurrenceRule.Month] = [], daysOfTheMonth: [Int] = [], weekdays: [Calendar.RecurrenceRule.Weekday] = [], hours: [Int] = [], minutes: [Int] = [], seconds: [Int] = [], setPositions: [Int] = []) -> Calendar.RecurrenceRule

        /// A recurrence that repeats every `interval` years
        public static func yearly(calendar: Calendar, interval: Int = 1, end: Calendar.RecurrenceRule.End = .never, matchingPolicy: Calendar.MatchingPolicy = .nextTimePreservingSmallerComponents, repeatedTimePolicy: Calendar.RepeatedTimePolicy = .first, months: [Calendar.RecurrenceRule.Month] = [], daysOfTheYear: [Int] = [], daysOfTheMonth: [Int] = [], weeks: [Int] = [], weekdays: [Calendar.RecurrenceRule.Weekday] = [], hours: [Int] = [], minutes: [Int] = [], seconds: [Int] = [], setPositions: [Int] = []) -> Calendar.RecurrenceRule

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Calendar.RecurrenceRule, b: Calendar.RecurrenceRule) -> Bool
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Calendar {

    public struct CalendarDayChangedMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = Calendar

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> Calendar.CalendarDayChangedMessage?
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.Identifier : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.Identifier : Equatable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.Identifier : Hashable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.Component : Equatable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.Component : Hashable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.SearchDirection : Equatable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.SearchDirection : Hashable {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Calendar.RepeatedTimePolicy : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.RepeatedTimePolicy : Equatable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.RepeatedTimePolicy : Hashable {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Calendar.MatchingPolicy : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Calendar.MatchingPolicy : Hashable {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Calendar.RecurrenceRule : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
extension Calendar.RecurrenceRule : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Calendar.RecurrenceRule.Frequency : Hashable {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Calendar.RecurrenceRule.Frequency : RawRepresentable {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Calendar.RecurrenceRule.End : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
extension Calendar.RecurrenceRule.End : CustomStringConvertible, Hashable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Calendar.RecurrenceRule.Weekday : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
extension Calendar.RecurrenceRule.Weekday : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Calendar.RecurrenceRule.Month : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 15.2, iOS 18.2, tvOS 18.2, watchOS 11.2, *)
extension Calendar.RecurrenceRule.Month : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/**
 A `CharacterSet` represents a set of Unicode-compliant characters. Foundation types use `CharacterSet` to group characters together for searching operations, so that they can find any of a particular set of characters during a search.
 
 This type provides "copy-on-write" behavior, and is also bridged to the Objective-C `NSCharacterSet` class.
*/
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct CharacterSet : ReferenceConvertible, Equatable, Hashable, SetAlgebra {

    public typealias ReferenceType = NSCharacterSet

    /// Initialize an empty instance.
    public init()

    /// Initialize with a range of integers.
    ///
    /// It is the caller's responsibility to ensure that the values represent valid `Unicode.Scalar` values, if that is what is desired.
    public init(charactersIn range: Range<Unicode.Scalar>)

    /// Initialize with a closed range of integers.
    ///
    /// It is the caller's responsibility to ensure that the values represent valid `Unicode.Scalar` values, if that is what is desired.
    public init(charactersIn range: ClosedRange<Unicode.Scalar>)

    /// Initialize with the characters in the given string.
    ///
    /// - parameter string: The string content to inspect for characters.
    public init(charactersIn string: String)

    /// Initialize with a bitmap representation.
    ///
    /// This method is useful for creating a character set object with data from a file or other external data source.
    /// - parameter data: The bitmap representation.
    public init(bitmapRepresentation data: Data)

    /// Initialize with the contents of a file.
    ///
    /// Returns `nil` if there was an error reading the file.
    /// - parameter file: The file to read.
    public init?(contentsOfFile file: String)

    /// Returns a character set containing the characters in Unicode General Category Cc and Cf.
    public static var controlCharacters: CharacterSet { get }

    /// Returns a character set containing the characters in Unicode General Category Zs and `CHARACTER TABULATION (U+0009)`.
    public static var whitespaces: CharacterSet { get }

    /// Returns a character set containing characters in Unicode General Category Z*, `U+000A ~ U+000D`, and `U+0085`.
    public static var whitespacesAndNewlines: CharacterSet { get }

    /// Returns a character set containing the characters in the category of Decimal Numbers.
    public static var decimalDigits: CharacterSet { get }

    /// Returns a character set containing the characters in Unicode General Category L* & M*.
    public static var letters: CharacterSet { get }

    /// Returns a character set containing the characters in Unicode General Category Ll.
    public static var lowercaseLetters: CharacterSet { get }

    /// Returns a character set containing the characters in Unicode General Category Lu and Lt.
    public static var uppercaseLetters: CharacterSet { get }

    /// Returns a character set containing the characters in Unicode General Category M*.
    public static var nonBaseCharacters: CharacterSet { get }

    /// Returns a character set containing the characters in Unicode General Categories L*, M*, and N*.
    public static var alphanumerics: CharacterSet { get }

    /// Returns a character set containing individual Unicode characters that can also be represented as composed character sequences (such as for letters with accents), by the definition of "standard decomposition" in version 3.2 of the Unicode character encoding standard.
    public static var decomposables: CharacterSet { get }

    /// Returns a character set containing values in the category of Non-Characters or that have not yet been defined in version 3.2 of the Unicode standard.
    public static var illegalCharacters: CharacterSet { get }

    /// Returns a character set containing the characters in Unicode General Category P*.
    public static var punctuationCharacters: CharacterSet { get }

    /// Returns a character set containing the characters in Unicode General Category Lt.
    public static var capitalizedLetters: CharacterSet { get }

    /// Returns a character set containing the characters in Unicode General Category S*.
    public static var symbols: CharacterSet { get }

    /// Returns a character set containing the newline characters (`U+000A ~ U+000D`, `U+0085`, `U+2028`, and `U+2029`).
    public static var newlines: CharacterSet { get }

    /// Returns the character set for characters allowed in a user URL subcomponent.
    public static var urlUserAllowed: CharacterSet { get }

    /// Returns the character set for characters allowed in a password URL subcomponent.
    public static var urlPasswordAllowed: CharacterSet { get }

    /// Returns the character set for characters allowed in a host URL subcomponent.
    public static var urlHostAllowed: CharacterSet { get }

    /// Returns the character set for characters allowed in a path URL component.
    public static var urlPathAllowed: CharacterSet { get }

    /// Returns the character set for characters allowed in a query URL component.
    public static var urlQueryAllowed: CharacterSet { get }

    /// Returns the character set for characters allowed in a fragment URL component.
    public static var urlFragmentAllowed: CharacterSet { get }

    /// Returns a representation of the `CharacterSet` in binary format.
    @nonobjc public var bitmapRepresentation: Data { get }

    /// Returns an inverted copy of the receiver.
    @nonobjc public var inverted: CharacterSet { get }

    /// Returns true if the `CharacterSet` has a member in the specified plane.
    ///
    /// This method makes it easier to find the plane containing the members of the current character set. The Basic Multilingual Plane (BMP) is plane 0.
    public func hasMember(inPlane plane: UInt8) -> Bool

    /// Insert a range of integer values in the `CharacterSet`.
    ///
    /// It is the caller's responsibility to ensure that the values represent valid `Unicode.Scalar` values, if that is what is desired.
    public mutating func insert(charactersIn range: Range<Unicode.Scalar>)

    /// Insert a closed range of integer values in the `CharacterSet`.
    ///
    /// It is the caller's responsibility to ensure that the values represent valid `Unicode.Scalar` values, if that is what is desired.
    public mutating func insert(charactersIn range: ClosedRange<Unicode.Scalar>)

    /// Remove a range of integer values from the `CharacterSet`.
    public mutating func remove(charactersIn range: Range<Unicode.Scalar>)

    /// Remove a closed range of integer values from the `CharacterSet`.
    public mutating func remove(charactersIn range: ClosedRange<Unicode.Scalar>)

    /// Insert the values from the specified string into the `CharacterSet`.
    public mutating func insert(charactersIn string: String)

    /// Remove the values from the specified string from the `CharacterSet`.
    public mutating func remove(charactersIn string: String)

    /// Invert the contents of the `CharacterSet`.
    public mutating func invert()

    /// Insert a `Unicode.Scalar` representation of a character into the `CharacterSet`.
    ///
    /// `Unicode.Scalar` values are available on `Swift.String.UnicodeScalarView`.
    @discardableResult
    public mutating func insert(_ character: Unicode.Scalar) -> (inserted: Bool, memberAfterInsert: Unicode.Scalar)

    /// Insert a `Unicode.Scalar` representation of a character into the `CharacterSet`.
    ///
    /// `Unicode.Scalar` values are available on `Swift.String.UnicodeScalarView`.
    @discardableResult
    public mutating func update(with character: Unicode.Scalar) -> Unicode.Scalar?

    /// Remove a `Unicode.Scalar` representation of a character from the `CharacterSet`.
    ///
    /// `Unicode.Scalar` values are available on `Swift.String.UnicodeScalarView`.
    @discardableResult
    public mutating func remove(_ character: Unicode.Scalar) -> Unicode.Scalar?

    /// Test for membership of a particular `Unicode.Scalar` in the `CharacterSet`.
    public func contains(_ member: Unicode.Scalar) -> Bool

    /// Returns a union of the `CharacterSet` with another `CharacterSet`.
    public func union(_ other: CharacterSet) -> CharacterSet

    /// Sets the value to a union of the `CharacterSet` with another `CharacterSet`.
    public mutating func formUnion(_ other: CharacterSet)

    /// Returns an intersection of the `CharacterSet` with another `CharacterSet`.
    public func intersection(_ other: CharacterSet) -> CharacterSet

    /// Sets the value to an intersection of the `CharacterSet` with another `CharacterSet`.
    public mutating func formIntersection(_ other: CharacterSet)

    /// Returns a `CharacterSet` created by removing elements in `other` from `self`.
    public func subtracting(_ other: CharacterSet) -> CharacterSet

    /// Sets the value to a `CharacterSet` created by removing elements in `other` from `self`.
    public mutating func subtract(_ other: CharacterSet)

    /// Returns an exclusive or of the `CharacterSet` with another `CharacterSet`.
    public func symmetricDifference(_ other: CharacterSet) -> CharacterSet

    /// Sets the value to an exclusive or of the `CharacterSet` with another `CharacterSet`.
    public mutating func formSymmetricDifference(_ other: CharacterSet)

    /// Returns true if `self` is a superset of `other`.
    public func isSuperset(of other: CharacterSet) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns true if the two `CharacterSet`s are equal.
    public static func == (lhs: CharacterSet, rhs: CharacterSet) -> Bool

    /// The type of the elements of an array literal.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias ArrayLiteralElement = Unicode.Scalar

    /// A type for which the conforming type provides a containment test.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = Unicode.Scalar

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CharacterSet : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CharacterSet : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension CharacterSet : Sendable {
}

/// Describes errors within the Cocoa error domain, including errors that Foundation throws.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct CocoaError {

    /// The domain of the error.
    public static var errorDomain: String { get }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

extension CocoaError {

    /// The error code itself.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public struct Code : RawRepresentable, Hashable, Sendable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: Int

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias RawValue = Int
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CocoaError {

    /// The file path associated with the error, if any.
    public var filePath: String? { get }

    /// The string encoding associated with this error, if any.
    public var stringEncoding: String.Encoding? { get }

    /// The underlying error behind this error, if any.
    public var underlying: (any Error)? { get }

    /// A list of underlying errors, if any. It includes the values of both NSUnderlyingErrorKey and NSMultipleUnderlyingErrorsKey. If there are no underlying errors, returns an empty array.
    @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
    public var underlyingErrors: [any Error] { get }

    /// The URL associated with this error, if any.
    public var url: URL? { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CocoaError {

    public static func error(_ code: CocoaError.Code, userInfo: [AnyHashable : Any]? = nil, url: URL? = nil) -> any Error
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CocoaError {

    public static var fileNoSuchFile: CocoaError.Code { get }

    public static var fileLocking: CocoaError.Code { get }

    public static var fileReadUnknown: CocoaError.Code { get }

    public static var fileReadNoPermission: CocoaError.Code { get }

    public static var fileReadInvalidFileName: CocoaError.Code { get }

    public static var fileReadCorruptFile: CocoaError.Code { get }

    public static var fileReadNoSuchFile: CocoaError.Code { get }

    public static var fileReadInapplicableStringEncoding: CocoaError.Code { get }

    public static var fileReadUnsupportedScheme: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var fileReadTooLarge: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var fileReadUnknownStringEncoding: CocoaError.Code { get }

    public static var fileWriteUnknown: CocoaError.Code { get }

    public static var fileWriteNoPermission: CocoaError.Code { get }

    public static var fileWriteInvalidFileName: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var fileWriteFileExists: CocoaError.Code { get }

    public static var fileWriteInapplicableStringEncoding: CocoaError.Code { get }

    public static var fileWriteUnsupportedScheme: CocoaError.Code { get }

    public static var fileWriteOutOfSpace: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var fileWriteVolumeReadOnly: CocoaError.Code { get }

    public static var keyValueValidation: CocoaError.Code { get }

    public static var formatting: CocoaError.Code { get }

    public static var userCancelled: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var featureUnsupported: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableNotLoadable: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableArchitectureMismatch: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableRuntimeMismatch: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableLoad: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableLink: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListReadCorrupt: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListReadUnknownVersion: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListReadStream: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListWriteStream: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListWriteInvalid: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var xpcConnectionInterrupted: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var xpcConnectionInvalid: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var xpcConnectionReplyInvalid: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var ubiquitousFileUnavailable: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var ubiquitousFileNotUploadedDueToQuota: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var ubiquitousFileUbiquityServerNotAvailable: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var userActivityHandoffFailed: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var userActivityConnectionUnavailable: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var userActivityRemoteApplicationTimedOut: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var userActivityHandoffUserInfoTooLarge: CocoaError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    public static var coderReadCorrupt: CocoaError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    public static var coderValueNotFound: CocoaError.Code { get }

    public static var coderInvalidValue: CocoaError.Code { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CocoaError {

    @available(macOS 10.11, iOS 9.0, *)
    public var isCoderError: Bool { get }

    @available(macOS 10.10, iOS 8.0, *)
    public var isExecutableError: Bool { get }

    public var isFileError: Bool { get }

    public var isFormattingError: Bool { get }

    @available(macOS 10.10, iOS 8.0, *)
    public var isPropertyListError: Bool { get }

    public var isValidationError: Bool { get }

    @available(macOS 10.10, iOS 8.0, *)
    public var isUbiquitousFileError: Bool { get }

    @available(macOS 10.10, iOS 8.0, *)
    public var isUserActivityError: Bool { get }

    @available(macOS 10.10, iOS 8.0, *)
    public var isXPCConnectionError: Bool { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CocoaError {

    @available(*, deprecated, renamed: "fileNoSuchFile")
    public static var fileNoSuchFileError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileLocking")
    public static var fileLockingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadUnknown")
    public static var fileReadUnknownError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadNoPermission")
    public static var fileReadNoPermissionError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadInvalidFileName")
    public static var fileReadInvalidFileNameError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadCorruptFile")
    public static var fileReadCorruptFileError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadNoSuchFile")
    public static var fileReadNoSuchFileError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
    public static var fileReadInapplicableStringEncodingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
    public static var fileReadUnsupportedSchemeError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "fileReadTooLarge")
    public static var fileReadTooLargeError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
    public static var fileReadUnknownStringEncodingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteUnknown")
    public static var fileWriteUnknownError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteNoPermission")
    public static var fileWriteNoPermissionError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteInvalidFileName")
    public static var fileWriteInvalidFileNameError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "fileWriteFileExists")
    public static var fileWriteFileExistsError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
    public static var fileWriteInapplicableStringEncodingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
    public static var fileWriteUnsupportedSchemeError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteOutOfSpace")
    public static var fileWriteOutOfSpaceError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
    public static var fileWriteVolumeReadOnlyError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "keyValueValidation")
    public static var keyValueValidationError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "formatting")
    public static var formattingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "userCancelled")
    public static var userCancelledError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "featureUnsupported")
    public static var featureUnsupportedError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableNotLoadable")
    public static var executableNotLoadableError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableArchitectureMismatch")
    public static var executableArchitectureMismatchError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableRuntimeMismatch")
    public static var executableRuntimeMismatchError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableLoad")
    public static var executableLoadError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableLink")
    public static var executableLinkError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListReadCorrupt")
    public static var propertyListReadCorruptError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
    public static var propertyListReadUnknownVersionError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListReadStream")
    public static var propertyListReadStreamError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListWriteStream")
    public static var propertyListWriteStreamError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListWriteInvalid")
    public static var propertyListWriteInvalidError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
    public static var ubiquitousFileUnavailableError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
    public static var ubiquitousFileNotUploadedDueToQuotaError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "userActivityHandoffFailed")
    public static var userActivityHandoffFailedError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
    public static var userActivityConnectionUnavailableError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
    public static var userActivityRemoteApplicationTimedOutError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
    public static var userActivityHandoffUserInfoTooLargeError: CocoaError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    @available(*, deprecated, renamed: "coderReadCorrupt")
    public static var coderReadCorruptError: CocoaError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    @available(*, deprecated, renamed: "coderValueNotFound")
    public static var coderValueNotFoundError: CocoaError.Code { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CocoaError.Code {

    public static var fileNoSuchFile: CocoaError.Code { get }

    public static var fileLocking: CocoaError.Code { get }

    public static var fileReadUnknown: CocoaError.Code { get }

    public static var fileReadNoPermission: CocoaError.Code { get }

    public static var fileReadInvalidFileName: CocoaError.Code { get }

    public static var fileReadCorruptFile: CocoaError.Code { get }

    public static var fileReadNoSuchFile: CocoaError.Code { get }

    public static var fileReadInapplicableStringEncoding: CocoaError.Code { get }

    public static var fileReadUnsupportedScheme: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var fileReadTooLarge: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var fileReadUnknownStringEncoding: CocoaError.Code { get }

    public static var fileWriteUnknown: CocoaError.Code { get }

    public static var fileWriteNoPermission: CocoaError.Code { get }

    public static var fileWriteInvalidFileName: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var fileWriteFileExists: CocoaError.Code { get }

    public static var fileWriteInapplicableStringEncoding: CocoaError.Code { get }

    public static var fileWriteUnsupportedScheme: CocoaError.Code { get }

    public static var fileWriteOutOfSpace: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var fileWriteVolumeReadOnly: CocoaError.Code { get }

    public static var keyValueValidation: CocoaError.Code { get }

    public static var formatting: CocoaError.Code { get }

    public static var userCancelled: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var featureUnsupported: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableNotLoadable: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableArchitectureMismatch: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableRuntimeMismatch: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableLoad: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var executableLink: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListReadCorrupt: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListReadUnknownVersion: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListReadStream: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListWriteStream: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var propertyListWriteInvalid: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var xpcConnectionInterrupted: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var xpcConnectionInvalid: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var xpcConnectionReplyInvalid: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var ubiquitousFileUnavailable: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var ubiquitousFileNotUploadedDueToQuota: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var ubiquitousFileUbiquityServerNotAvailable: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var userActivityHandoffFailed: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var userActivityConnectionUnavailable: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var userActivityRemoteApplicationTimedOut: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var userActivityHandoffUserInfoTooLarge: CocoaError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    public static var coderReadCorrupt: CocoaError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    public static var coderValueNotFound: CocoaError.Code { get }

    public static var coderInvalidValue: CocoaError.Code { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CocoaError.Code {

    @available(*, deprecated, renamed: "fileNoSuchFile")
    public static var fileNoSuchFileError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileLocking")
    public static var fileLockingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadUnknown")
    public static var fileReadUnknownError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadNoPermission")
    public static var fileReadNoPermissionError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadInvalidFileName")
    public static var fileReadInvalidFileNameError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadCorruptFile")
    public static var fileReadCorruptFileError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadNoSuchFile")
    public static var fileReadNoSuchFileError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadInapplicableStringEncoding")
    public static var fileReadInapplicableStringEncodingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileReadUnsupportedScheme")
    public static var fileReadUnsupportedSchemeError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "fileReadTooLarge")
    public static var fileReadTooLargeError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "fileReadUnknownStringEncoding")
    public static var fileReadUnknownStringEncodingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteUnknown")
    public static var fileWriteUnknownError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteNoPermission")
    public static var fileWriteNoPermissionError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteInvalidFileName")
    public static var fileWriteInvalidFileNameError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "fileWriteFileExists")
    public static var fileWriteFileExistsError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteInapplicableStringEncoding")
    public static var fileWriteInapplicableStringEncodingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteUnsupportedScheme")
    public static var fileWriteUnsupportedSchemeError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "fileWriteOutOfSpace")
    public static var fileWriteOutOfSpaceError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "fileWriteVolumeReadOnly")
    public static var fileWriteVolumeReadOnlyError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "keyValueValidation")
    public static var keyValueValidationError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "formatting")
    public static var formattingError: CocoaError.Code { get }

    @available(*, deprecated, renamed: "userCancelled")
    public static var userCancelledError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "featureUnsupported")
    public static var featureUnsupportedError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableNotLoadable")
    public static var executableNotLoadableError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableArchitectureMismatch")
    public static var executableArchitectureMismatchError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableRuntimeMismatch")
    public static var executableRuntimeMismatchError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableLoad")
    public static var executableLoadError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "executableLink")
    public static var executableLinkError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListReadCorrupt")
    public static var propertyListReadCorruptError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListReadUnknownVersion")
    public static var propertyListReadUnknownVersionError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListReadStream")
    public static var propertyListReadStreamError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListWriteStream")
    public static var propertyListWriteStreamError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "propertyListWriteInvalid")
    public static var propertyListWriteInvalidError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "ubiquitousFileUnavailable")
    public static var ubiquitousFileUnavailableError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "ubiquitousFileNotUploadedDueToQuota")
    public static var ubiquitousFileNotUploadedDueToQuotaError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "userActivityHandoffFailed")
    public static var userActivityHandoffFailedError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "userActivityConnectionUnavailable")
    public static var userActivityConnectionUnavailableError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "userActivityRemoteApplicationTimedOut")
    public static var userActivityRemoteApplicationTimedOutError: CocoaError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    @available(*, deprecated, renamed: "userActivityHandoffUserInfoTooLarge")
    public static var userActivityHandoffUserInfoTooLargeError: CocoaError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    @available(*, deprecated, renamed: "coderReadCorrupt")
    public static var coderReadCorruptError: CocoaError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    @available(*, deprecated, renamed: "coderValueNotFound")
    public static var coderValueNotFoundError: CocoaError.Code { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public typealias CodableAttributedStringKey = DecodableAttributedStringKey & EncodableAttributedStringKey

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@propertyWrapper public struct CodableConfiguration<T, ConfigurationProvider> : Codable where T : DecodableWithConfiguration, T : EncodableWithConfiguration, ConfigurationProvider : DecodingConfigurationProviding, ConfigurationProvider : EncodingConfigurationProviding, T.DecodingConfiguration == ConfigurationProvider.DecodingConfiguration, T.EncodingConfiguration == ConfigurationProvider.EncodingConfiguration {

    public var wrappedValue: T

    public init(wrappedValue: T)

    public init(wrappedValue: T, from configurationProvider: ConfigurationProvider.Type)

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CodableConfiguration where ConfigurationProvider : AttributeScope {

    public init(wrappedValue: T, from keyPath: KeyPath<AttributeScopes, ConfigurationProvider.Type>)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CodableConfiguration : Sendable where T : Sendable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CodableConfiguration : Equatable where T : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: CodableConfiguration<T, ConfigurationProvider>, b: CodableConfiguration<T, ConfigurationProvider>) -> Bool
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension CodableConfiguration : Hashable where T : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public typealias CodableWithConfiguration = DecodableWithConfiguration & EncodableWithConfiguration

/// Compares `Comparable` types using their comparable implementation.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct ComparableComparator<Compared> : SortComparator, Sendable where Compared : Comparable {

    /// If the `SortComparator`s resulting order is forward or reverse.
    public var order: SortOrder

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public init(order: SortOrder = .forward)

    /// The relative ordering of lhs, and rhs.
    ///
    /// The result of comparisons should be flipped if the current `order`
    /// is `reverse`.
    ///
    /// If `compare(lhs, rhs)` is `.orderedAscending`, then `compare(rhs, lhs)`
    /// must be `.orderedDescending`. If `compare(lhs, rhs)` is
    /// `.orderedDescending`, then `compare(rhs, lhs)` must be
    /// `.orderedAscending`.
    ///
    /// - Parameters:
    ///     - lhs: A value to compare.
    ///     - rhs: A value to compare.
    public func compare(_ lhs: Compared, _ rhs: Compared) -> ComparisonResult

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ComparableComparator<Compared>, b: ComparableComparator<Compared>) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// Indicates that the conforming type is a contiguous collection of raw bytes
/// whose underlying storage is directly accessible by withUnsafeBytes.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol ContiguousBytes {

    /// Calls the given closure with the contents of underlying storage.
    ///
    /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
    ///         the same buffer pointer will be passed in every time.
    /// - warning: The buffer argument to the body should not be stored or used
    ///            outside of the lifetime of the call to the closure.
    func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum CurrencyFormatStyleConfiguration {

    public typealias Grouping = NumberFormatStyleConfiguration.Grouping

    public typealias Precision = NumberFormatStyleConfiguration.Precision

    public typealias DecimalSeparatorDisplayStrategy = NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy

    public typealias RoundingRule = NumberFormatStyleConfiguration.RoundingRule

    /// The type used to configure notation for currency format styles.
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public typealias Notation = NumberFormatStyleConfiguration.Notation

    public struct SignDisplayStrategy : Codable, Hashable, Sendable {

        public static var automatic: CurrencyFormatStyleConfiguration.SignDisplayStrategy { get }

        public static var never: CurrencyFormatStyleConfiguration.SignDisplayStrategy { get }

        public static func always(showZero: Bool = true) -> CurrencyFormatStyleConfiguration.SignDisplayStrategy

        public static var accounting: CurrencyFormatStyleConfiguration.SignDisplayStrategy { get }

        public static func accountingAlways(showZero: Bool = false) -> CurrencyFormatStyleConfiguration.SignDisplayStrategy

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: CurrencyFormatStyleConfiguration.SignDisplayStrategy, b: CurrencyFormatStyleConfiguration.SignDisplayStrategy) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct Presentation : Codable, Hashable, Sendable {

        public static var narrow: CurrencyFormatStyleConfiguration.Presentation { get }

        public static var standard: CurrencyFormatStyleConfiguration.Presentation { get }

        public static var isoCode: CurrencyFormatStyleConfiguration.Presentation { get }

        public static var fullName: CurrencyFormatStyleConfiguration.Presentation { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: CurrencyFormatStyleConfiguration.Presentation, b: CurrencyFormatStyleConfiguration.Presentation) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public protocol CustomLocalizedStringResourceConvertible {

    var localizedStringResource: LocalizedStringResource { get }
}

/// Describes an error type that specifically provides a domain, code,
/// and user-info dictionary.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol CustomNSError : Error {

    /// The domain of the error.
    static var errorDomain: String { get }

    /// The error code within the given domain.
    var errorCode: Int { get }

    /// The user-info dictionary.
    var errorUserInfo: [String : Any] { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CustomNSError {

    /// Default domain of the error.
    public static var errorDomain: String { get }

    /// The error code within the given domain.
    public var errorCode: Int { get }

    /// The default user-info dictionary.
    public var errorUserInfo: [String : Any] { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CustomNSError where Self : RawRepresentable, Self.RawValue : FixedWidthInteger {

    public var errorCode: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@frozen public struct Data : Equatable, Hashable, RandomAccessCollection, MutableCollection, RangeReplaceableCollection, MutableDataProtocol, ContiguousBytes, Sendable {

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = Range<Int>

    ///
    /// When creating a `Data` with the no-copy initializer, you may specify a `Data.Deallocator` to customize the behavior of how the backing store is deallocated.
    public enum Deallocator {

        case virtualMemory

        /// Use `munmap`.
        case unmap

        /// Use `free`.
        case free

        /// Do nothing upon deallocation.
        case none

        /// A custom deallocator.
        case custom((UnsafeMutableRawPointer, Int) -> Void)
    }

    /// Initialize a `Data` with copied memory content.
    ///
    /// - parameter bytes: A pointer to the memory. It will be copied.
    /// - parameter count: The number of bytes to copy.
    @inlinable public init(bytes: UnsafeRawPointer, count: Int)

    /// Initialize a `Data` with copied memory content.
    ///
    /// - parameter buffer: A buffer pointer to copy. The size is calculated from `SourceType` and `buffer.count`.
    @inlinable public init<SourceType>(buffer: UnsafeBufferPointer<SourceType>)

    /// Initialize a `Data` with copied memory content.
    ///
    /// - parameter buffer: A buffer pointer to copy. The size is calculated from `SourceType` and `buffer.count`.
    @inlinable public init<SourceType>(buffer: UnsafeMutableBufferPointer<SourceType>)

    /// Initialize a `Data` with a repeating byte pattern
    ///
    /// - parameter repeatedValue: A byte to initialize the pattern
    /// - parameter count: The number of bytes the data initially contains initialized to the repeatedValue
    @inlinable public init(repeating repeatedValue: UInt8, count: Int)

    /// Initialize a `Data` with the specified size.
    ///
    /// This initializer doesn't necessarily allocate the requested memory right away. `Data` allocates additional memory as needed, so `capacity` simply establishes the initial capacity. When it does allocate the initial memory, though, it allocates the specified amount.
    ///
    /// This method sets the `count` of the data to 0.
    ///
    /// If the capacity specified in `capacity` is greater than four memory pages in size, this may round the amount of requested memory up to the nearest full page.
    ///
    /// - parameter capacity: The size of the data.
    @inlinable public init(capacity: Int)

    /// Initialize a `Data` with the specified count of zeroed bytes.
    ///
    /// - parameter count: The number of bytes the data initially contains.
    @inlinable public init(count: Int)

    /// Initialize an empty `Data`.
    @inlinable public init()

    /// Initialize a `Data` without copying the bytes.
    ///
    /// If the result is mutated and is not a unique reference, then the `Data` will still follow copy-on-write semantics. In this case, the copy will use its own deallocator. Therefore, it is usually best to only use this initializer when you either enforce immutability with `let` or ensure that no other references to the underlying data are formed.
    /// - parameter bytes: A pointer to the bytes.
    /// - parameter count: The size of the bytes.
    /// - parameter deallocator: Specifies the mechanism to free the indicated buffer, or `.none`.
    @inlinable public init(bytesNoCopy bytes: UnsafeMutableRawPointer, count: Int, deallocator: Data.Deallocator)

    /// Creates a new instance of a collection containing the elements of a
    /// sequence.
    ///
    /// - Parameter elements: The sequence of elements for the new collection.
    ///   `elements` must be finite.
    @inlinable public init<S>(_ elements: S) where S : Sequence, S.Element == UInt8

    @available(swift 4.2)
    @available(swift, deprecated: 5, message: "use `init(_:)` instead")
    public init<S>(bytes elements: S) where S : Sequence, S.Element == UInt8

    public typealias ReadingOptions = NSData.ReadingOptions

    public typealias WritingOptions = NSData.WritingOptions

    /// Initialize a `Data` with the contents of a `URL`.
    ///
    /// - parameter url: The `URL` to read.
    /// - parameter options: Options for the read operation. Default value is `[]`.
    /// - throws: An error in the Cocoa domain, if `url` cannot be read.
    public init(contentsOf url: URL, options: Data.ReadingOptions = []) throws

    /// Prepares the collection to store the specified number of elements, when
    /// doing so is appropriate for the underlying type.
    ///
    /// If you are adding a known number of elements to a collection, use this
    /// method to avoid multiple reallocations. A type that conforms to
    /// `RangeReplaceableCollection` can choose how to respond when this method
    /// is called. Depending on the type, it may make sense to allocate more or
    /// less storage than requested, or to take no action at all.
    ///
    /// - Parameter n: The requested number of elements to store.
    @inlinable public mutating func reserveCapacity(_ minimumCapacity: Int)

    /// The number of bytes in the data.
    @inlinable public var count: Int

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    @inlinable public var regions: CollectionOfOne<Data> { get }

    /// Access the bytes in the data.
    ///
    /// - warning: The byte pointer argument should not be stored and used outside of the lifetime of the call to the closure.
    @available(swift, deprecated: 5, message: "use `withUnsafeBytes<R>(_: (UnsafeRawBufferPointer) throws -> R) rethrows -> R` instead")
    public func withUnsafeBytes<ResultType, ContentType>(_ body: (UnsafePointer<ContentType>) throws -> ResultType) rethrows -> ResultType

    /// Calls the given closure with the contents of underlying storage.
    ///
    /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
    ///         the same buffer pointer will be passed in every time.
    /// - warning: The buffer argument to the body should not be stored or used
    ///            outside of the lifetime of the call to the closure.
    @inlinable public func withUnsafeBytes<ResultType>(_ body: (UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType

    @available(macOS 10.14.4, iOS 12.2, watchOS 5.2, tvOS 12.2, visionOS 1.1, *)
    public var bytes: RawSpan { get }

    @available(macOS 10.14.4, iOS 12.2, watchOS 5.2, tvOS 12.2, visionOS 1.1, *)
    public var span: Span<UInt8> { get }

    @available(macOS 10.14.4, iOS 12.2, watchOS 5.2, tvOS 12.2, visionOS 1.1, *)
    public var mutableBytes: MutableRawSpan { mutating get }

    @available(macOS 10.14.4, iOS 12.2, watchOS 5.2, tvOS 12.2, visionOS 1.1, *)
    public var mutableSpan: MutableSpan<UInt8> { mutating get }

    /// Executes a closure on the sequence’s contiguous storage.
    ///
    /// This method calls `body(buffer)`, where `buffer` is a pointer to the
    /// collection’s contiguous storage. If the contiguous storage doesn't exist,
    /// the collection creates it. If the collection doesn’t support an internal
    /// representation in a form of contiguous storage, the method doesn’t call
    /// `body` --- it immediately returns `nil`.
    ///
    /// The optimizer can often eliminate bounds- and uniqueness-checking
    /// within an algorithm. When that fails, however, invoking the same
    /// algorithm on the `buffer` argument may let you trade safety for speed.
    ///
    /// Successive calls to this method may provide a different pointer on each
    /// call. Don't store `buffer` outside of this method.
    ///
    /// A `Collection` that provides its own implementation of this method
    /// must provide contiguous storage to its elements in the same order
    /// as they appear in the collection. This guarantees that it's possible to
    /// generate contiguous mutable storage to any of its subsequences by slicing
    /// `buffer` with a range formed from the distances to the subsequence's
    /// `startIndex` and `endIndex`, respectively.
    ///
    /// - Parameters:
    ///   - body: A closure that receives an `UnsafeBufferPointer` to the
    ///     sequence's contiguous storage.
    /// - Returns: The value returned from `body`, unless the sequence doesn't
    ///   support contiguous storage, in which case the method ignores `body` and
    ///   returns `nil`.
    public func withContiguousStorageIfAvailable<ResultType>(_ body: (_ buffer: UnsafeBufferPointer<UInt8>) throws -> ResultType) rethrows -> ResultType?

    /// Mutate the bytes in the data.
    ///
    /// This function assumes that you are mutating the contents.
    /// - warning: The byte pointer argument should not be stored and used outside of the lifetime of the call to the closure.
    @available(swift, deprecated: 5, message: "use `withUnsafeMutableBytes<R>(_: (UnsafeMutableRawBufferPointer) throws -> R) rethrows -> R` instead")
    public mutating func withUnsafeMutableBytes<ResultType, ContentType>(_ body: (UnsafeMutablePointer<ContentType>) throws -> ResultType) rethrows -> ResultType

    @inlinable public mutating func withUnsafeMutableBytes<ResultType>(_ body: (UnsafeMutableRawBufferPointer) throws -> ResultType) rethrows -> ResultType

    /// Copy the contents of the data to a pointer.
    ///
    /// - parameter pointer: A pointer to the buffer you wish to copy the bytes into.
    /// - parameter count: The number of bytes to copy.
    /// - warning: This method does not verify that the contents at pointer have enough space to hold `count` bytes.
    @inlinable public func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, count: Int)

    /// Copy a subset of the contents of the data to a pointer.
    ///
    /// - parameter pointer: A pointer to the buffer you wish to copy the bytes into.
    /// - parameter range: The range in the `Data` to copy.
    /// - warning: This method does not verify that the contents at pointer have enough space to hold the required number of bytes.
    @inlinable public func copyBytes(to pointer: UnsafeMutablePointer<UInt8>, from range: Range<Data.Index>)

    ///
    /// This function copies the bytes in `range` from the data into the buffer. If the count of the `range` is greater than `MemoryLayout<DestinationType>.stride * buffer.count` then the first N bytes will be copied into the buffer.
    /// - precondition: The range must be within the bounds of the data. Otherwise `fatalError` is called.
    /// - parameter buffer: A buffer to copy the data into.
    /// - parameter range: A range in the data to copy into the buffer. If the range is empty, this function will return 0 without copying anything. If the range is nil, as much data as will fit into `buffer` is copied.
    /// - returns: Number of bytes copied into the destination buffer.
    @inlinable public func copyBytes<DestinationType>(to buffer: UnsafeMutableBufferPointer<DestinationType>, from range: Range<Data.Index>? = nil) -> Int

    /// Enumerate the contents of the data.
    ///
    /// In some cases, (for example, a `Data` backed by a `dispatch_data_t`, the bytes may be stored discontinuously. In those cases, this function invokes the closure for each contiguous region of bytes.
    /// - parameter block: The closure to invoke for each region of data. You may stop the enumeration by setting the `stop` parameter to `true`.
    @available(swift, deprecated: 5, message: "use `regions` or `for-in` instead")
    public func enumerateBytes(_ block: (_ buffer: UnsafeBufferPointer<UInt8>, _ byteIndex: Data.Index, _ stop: inout Bool) -> Void)

    @inlinable public mutating func append(_ bytes: UnsafePointer<UInt8>, count: Int)

    public mutating func append(_ other: Data)

    /// Append a buffer of bytes to the data.
    ///
    /// - parameter buffer: The buffer of bytes to append. The size is calculated from `SourceType` and `buffer.count`.
    @inlinable public mutating func append<SourceType>(_ buffer: UnsafeBufferPointer<SourceType>)

    @inlinable public mutating func append(contentsOf bytes: [UInt8])

    /// Adds the elements of a sequence or collection to the end of this
    /// collection.
    ///
    /// The collection being appended to allocates any additional necessary
    /// storage to hold the new elements.
    ///
    /// The following example appends the elements of a `Range<Int>` instance to
    /// an array of integers:
    ///
    ///     var numbers = [1, 2, 3, 4, 5]
    ///     numbers.append(contentsOf: 10...15)
    ///     print(numbers)
    ///     // Prints "[1, 2, 3, 4, 5, 10, 11, 12, 13, 14, 15]"
    ///
    /// - Parameter newElements: The elements to append to the collection.
    ///
    /// - Complexity: O(*m*), where *m* is the length of `newElements`.
    @inlinable public mutating func append<S>(contentsOf elements: S) where S : Sequence, S.Element == UInt8

    /// Set a region of the data to `0`.
    ///
    /// If `range` exceeds the bounds of the data, then the data is resized to fit.
    /// - parameter range: The range in the data to set to `0`.
    @inlinable public mutating func resetBytes(in range: Range<Data.Index>)

    /// Replace a region of bytes in the data with new data.
    ///
    /// This will resize the data if required, to fit the entire contents of `data`.
    ///
    /// - precondition: The bounds of `subrange` must be valid indices of the collection.
    /// - parameter subrange: The range in the data to replace. If `subrange.lowerBound == data.count && subrange.count == 0` then this operation is an append.
    /// - parameter data: The replacement data.
    @inlinable public mutating func replaceSubrange(_ subrange: Range<Data.Index>, with data: Data)

    /// Replace a region of bytes in the data with new bytes from a buffer.
    ///
    /// This will resize the data if required, to fit the entire contents of `buffer`.
    ///
    /// - precondition: The bounds of `subrange` must be valid indices of the collection.
    /// - parameter subrange: The range in the data to replace.
    /// - parameter buffer: The replacement bytes.
    @inlinable public mutating func replaceSubrange<SourceType>(_ subrange: Range<Data.Index>, with buffer: UnsafeBufferPointer<SourceType>)

    /// Replace a region of bytes in the data with new bytes from a collection.
    ///
    /// This will resize the data if required, to fit the entire contents of `newElements`.
    ///
    /// - precondition: The bounds of `subrange` must be valid indices of the collection.
    /// - parameter subrange: The range in the data to replace.
    /// - parameter newElements: The replacement bytes.
    @inlinable public mutating func replaceSubrange<ByteCollection>(_ subrange: Range<Data.Index>, with newElements: ByteCollection) where ByteCollection : Collection, ByteCollection.Element == UInt8

    @inlinable public mutating func replaceSubrange(_ subrange: Range<Data.Index>, with bytes: UnsafeRawPointer, count cnt: Int)

    /// Return a new copy of the data in a specified range.
    ///
    /// - parameter range: The range to copy.
    public func subdata(in range: Range<Data.Index>) -> Data

    /// Write the contents of the `Data` to a location.
    ///
    /// - parameter url: The location to write the data into.
    /// - parameter options: Options for writing the data. Default value is `[]`.
    /// - throws: An error in the Cocoa domain, if there is an error writing to the `URL`.
    public func write(to url: URL, options: Data.WritingOptions = []) throws

    /// The hash value for the data.
    public func hash(into hasher: inout Hasher)

    public func advanced(by amount: Int) -> Data

    /// Sets or returns the byte at the specified index.
    @inlinable public subscript(index: Data.Index) -> UInt8

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    @inlinable public subscript(bounds: Range<Data.Index>) -> Data

    @inlinable public subscript<R>(rangeExpression: R) -> Data where R : RangeExpression, R.Bound : FixedWidthInteger

    /// The start `Index` in the data.
    @inlinable public var startIndex: Data.Index { get }

    /// The end `Index` into the data.
    ///
    /// This is the "one-past-the-end" position, and will always be equal to the `count`.
    @inlinable public var endIndex: Data.Index { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    @inlinable public func index(before i: Data.Index) -> Data.Index

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    @inlinable public func index(after i: Data.Index) -> Data.Index

    /// The indices that are valid for subscripting the collection, in ascending
    /// order.
    ///
    /// A collection's `indices` property can hold a strong reference to the
    /// collection itself, causing the collection to be nonuniquely referenced.
    /// If you mutate the collection while iterating over its indices, a strong
    /// reference can result in an unexpected copy of the collection. To avoid
    /// the unexpected copy, use the `index(after:)` method starting with
    /// `startIndex` to produce indices instead.
    ///
    ///     var c = MyFancyCollection([10, 20, 30, 40, 50])
    ///     var i = c.startIndex
    ///     while i != c.endIndex {
    ///         c[i] /= 5
    ///         i = c.index(after: i)
    ///     }
    ///     // c == MyFancyCollection([2, 4, 6, 8, 10])
    @inlinable public var indices: Range<Int> { get }

    /// An iterator over the contents of the data.
    ///
    /// The iterator will increment byte-by-byte.
    @inlinable public func makeIterator() -> Data.Iterator

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    public struct Iterator : IteratorProtocol, Sendable {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        public mutating func next() -> UInt8?

        /// The type of element traversed by the iterator.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias Element = UInt8
    }

    /// Find the given `Data` in the content of this `Data`.
    ///
    /// - parameter dataToFind: The data to be searched for.
    /// - parameter options: Options for the search. Default value is `[]`.
    /// - parameter range: The range of this data in which to perform the search. Default value is `nil`, which means the entire content of this data.
    /// - returns: A `Range` specifying the location of the found data, or nil if a match could not be found.
    /// - precondition: `range` must be in the bounds of the Data.
    public func range(of dataToFind: Data, options: Data.SearchOptions = [], in range: Range<Data.Index>? = nil) -> Range<Data.Index>?

    /// Returns `true` if the two `Data` arguments are equal.
    @inlinable public static func == (d1: Data, d2: Data) -> Bool

    /// A type representing the sequence's elements.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = UInt8

    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Regions = CollectionOfOne<Data>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias SubSequence = Data

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Data {

    public typealias SearchOptions = NSData.SearchOptions

    public typealias Base64EncodingOptions = NSData.Base64EncodingOptions

    public typealias Base64DecodingOptions = NSData.Base64DecodingOptions
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Data : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A human-readable description for the data.
    public var description: String { get }

    /// A human-readable debug description for the data.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Data : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Data {

    /// Initialize a `Data` from a Base-64 encoded String using the given options.
    ///
    /// Returns nil when the input is not recognized as valid Base-64.
    /// - parameter base64String: The string to parse.
    /// - parameter options: Encoding options. Default value is `[]`.
    public init?(base64Encoded base64String: String, options: Data.Base64DecodingOptions = [])

    /// Initialize a `Data` from a Base-64, UTF-8 encoded `Data`.
    ///
    /// Returns nil when the input is not recognized as valid Base-64.
    ///
    /// - parameter base64Data: Base-64, UTF-8 encoded input data.
    /// - parameter options: Decoding options. Default value is `[]`.
    public init?(base64Encoded base64Data: Data, options: Data.Base64DecodingOptions = [])

    /// Returns a Base-64 encoded string.
    ///
    /// - parameter options: The options to use for the encoding. Default value is `[]`.
    /// - returns: The Base-64 encoded string.
    public func base64EncodedString(options: Data.Base64EncodingOptions = []) -> String

    /// Returns a Base-64 encoded `Data`.
    ///
    /// - parameter options: The options to use for the encoding. Default value is `[]`.
    /// - returns: The Base-64 encoded data.
    public func base64EncodedData(options: Data.Base64EncodingOptions = []) -> Data
}

/// Provides bridging functionality for struct Data to class NSData and vice-versa.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Data : ReferenceConvertible {

    public typealias ReferenceType = NSData
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Data {

    /// Initialize a `Data` by adopting a reference type.
    ///
    /// You can use this initializer to create a `struct Data` that wraps a `class NSData`. `struct Data` will use the `class NSData` for all operations. Other initializers (including casting using `as Data`) may choose to hold a reference or not, based on a what is the most efficient representation.
    ///
    /// If the resulting value is mutated, then `Data` will invoke the `mutableCopy()` function on the reference to copy the contents. You may customize the behavior of that function if you wish to return a specialized mutable subclass.
    ///
    /// - parameter reference: The instance of `NSData` that you wish to wrap. This instance will be copied by `struct Data`.
    public init(referencing reference: NSData)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Data.InlineData : BitwiseCopyable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol DataProtocol : RandomAccessCollection where Self.Element == UInt8, Self.SubSequence : DataProtocol {

    associatedtype Regions : BidirectionalCollection where Self.Regions.Element : ContiguousBytes, Self.Regions.Element : DataProtocol, Self.Regions.Element.SubSequence : ContiguousBytes

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    var regions: Self.Regions { get }

    /// Returns the first found range of the given data buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    func firstRange<D, R>(of: D, in: R) -> Range<Self.Index>? where D : DataProtocol, R : RangeExpression, Self.Index == R.Bound

    /// Returns the last found range of the given data buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    func lastRange<D, R>(of: D, in: R) -> Range<Self.Index>? where D : DataProtocol, R : RangeExpression, Self.Index == R.Bound

    /// Copies `count` bytes from the start of the buffer to the destination
    /// buffer.
    ///
    /// A default implementation is given in terms of `copyBytes(to:from:)`.
    @discardableResult
    func copyBytes(to: UnsafeMutableRawBufferPointer, count: Int) -> Int

    /// Copies `count` bytes from the start of the buffer to the destination
    /// buffer.
    ///
    /// A default implementation is given in terms of `copyBytes(to:from:)`.
    @discardableResult
    func copyBytes<DestinationType>(to: UnsafeMutableBufferPointer<DestinationType>, count: Int) -> Int

    /// Copies the bytes from the given range to the destination buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    @discardableResult
    func copyBytes<R>(to: UnsafeMutableRawBufferPointer, from: R) -> Int where R : RangeExpression, Self.Index == R.Bound

    /// Copies the bytes from the given range to the destination buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    @discardableResult
    func copyBytes<DestinationType, R>(to: UnsafeMutableBufferPointer<DestinationType>, from: R) -> Int where R : RangeExpression, Self.Index == R.Bound
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension DataProtocol {

    public func firstRange<D>(of data: D) -> Range<Self.Index>? where D : DataProtocol

    public func lastRange<D>(of data: D) -> Range<Self.Index>? where D : DataProtocol

    @discardableResult
    public func copyBytes(to ptr: UnsafeMutableRawBufferPointer) -> Int

    @discardableResult
    public func copyBytes<DestinationType>(to ptr: UnsafeMutableBufferPointer<DestinationType>) -> Int

    /// Copies `count` bytes from the start of the buffer to the destination
    /// buffer.
    ///
    /// A default implementation is given in terms of `copyBytes(to:from:)`.
    @discardableResult
    public func copyBytes(to ptr: UnsafeMutableRawBufferPointer, count: Int) -> Int

    /// Copies `count` bytes from the start of the buffer to the destination
    /// buffer.
    ///
    /// A default implementation is given in terms of `copyBytes(to:from:)`.
    @discardableResult
    public func copyBytes<DestinationType>(to ptr: UnsafeMutableBufferPointer<DestinationType>, count: Int) -> Int

    /// Copies the bytes from the given range to the destination buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    @discardableResult
    public func copyBytes<R>(to ptr: UnsafeMutableRawBufferPointer, from range: R) -> Int where R : RangeExpression, Self.Index == R.Bound

    /// Copies the bytes from the given range to the destination buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    @discardableResult
    public func copyBytes<DestinationType, R>(to ptr: UnsafeMutableBufferPointer<DestinationType>, from range: R) -> Int where R : RangeExpression, Self.Index == R.Bound

    /// Returns the first found range of the given data buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    public func firstRange<D, R>(of data: D, in range: R) -> Range<Self.Index>? where D : DataProtocol, R : RangeExpression, Self.Index == R.Bound

    /// Returns the last found range of the given data buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    public func lastRange<D, R>(of data: D, in range: R) -> Range<Self.Index>? where D : DataProtocol, R : RangeExpression, Self.Index == R.Bound
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension DataProtocol where Self : ContiguousBytes {

    public func copyBytes<DestinationType, R>(to ptr: UnsafeMutableBufferPointer<DestinationType>, from range: R) where R : RangeExpression, Self.Index == R.Bound
}

/**
 `Date` represents a single point in time.

 A `Date` is independent of a particular calendar or time zone. To represent a `Date` to a user, you must interpret it in the context of a `Calendar`.
*/
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct Date : Comparable, Hashable, Equatable, Sendable {

    /// The number of seconds from 1 January 1970 to the reference date, 1 January 2001.
    public static let timeIntervalBetween1970AndReferenceDate: Double

    /// The interval between 00:00:00 UTC on 1 January 2001 and the current date and time.
    public static var timeIntervalSinceReferenceDate: TimeInterval { get }

    /// Returns a `Date` initialized to the current date and time.
    public init()

    /// Returns a `Date` initialized relative to the current date and time by a given number of seconds.
    public init(timeIntervalSinceNow: TimeInterval)

    /// Returns a `Date` initialized relative to 00:00:00 UTC on 1 January 1970 by a given number of seconds.
    public init(timeIntervalSince1970: TimeInterval)

    /**
        Returns a `Date` initialized relative to another given date by a given number of seconds.
    
        - Parameter timeInterval: The number of seconds to add to `date`. A negative value means the receiver will be earlier than `date`.
        - Parameter date: The reference date.
        */
    public init(timeInterval: TimeInterval, since date: Date)

    /// Returns a `Date` initialized relative to 00:00:00 UTC on 1 January 2001 by a given number of seconds.
    public init(timeIntervalSinceReferenceDate ti: TimeInterval)

    /**
        Returns the interval between the date object and 00:00:00 UTC on 1 January 2001.
    
        This property's value is negative if the date object is earlier than the system's absolute reference date (00:00:00 UTC on 1 January 2001).
        */
    public var timeIntervalSinceReferenceDate: TimeInterval { get }

    /**
        Returns the interval between the receiver and another given date.
    
        - Parameter another: The date with which to compare the receiver.
    
        - Returns: The interval between the receiver and the `another` parameter. If the receiver is earlier than `anotherDate`, the return value is negative. If `anotherDate` is `nil`, the results are undefined.
    
        - SeeAlso: `timeIntervalSince1970`
        - SeeAlso: `timeIntervalSinceNow`
        - SeeAlso: `timeIntervalSinceReferenceDate`
        */
    public func timeIntervalSince(_ date: Date) -> TimeInterval

    /**
        The time interval between the date and the current date and time.
    
        If the date is earlier than the current date and time, this property's value is negative.
    
        - SeeAlso: `timeIntervalSince(_:)`
        - SeeAlso: `timeIntervalSince1970`
        - SeeAlso: `timeIntervalSinceReferenceDate`
        */
    public var timeIntervalSinceNow: TimeInterval { get }

    /**
        The interval between the date object and 00:00:00 UTC on 1 January 1970.
    
        This property's value is negative if the date object is earlier than 00:00:00 UTC on 1 January 1970.
    
        - SeeAlso: `timeIntervalSince(_:)`
        - SeeAlso: `timeIntervalSinceNow`
        - SeeAlso: `timeIntervalSinceReferenceDate`
        */
    public var timeIntervalSince1970: TimeInterval { get }

    /// Return a new `Date` by adding a `TimeInterval` to this `Date`.
    ///
    /// - parameter timeInterval: The value to add, in seconds.
    /// - warning: This only adjusts an absolute value. If you wish to add calendrical concepts like hours, days, months then you must use a `Calendar`. That will take into account complexities like daylight saving time, months with different numbers of days, and more.
    public func addingTimeInterval(_ timeInterval: TimeInterval) -> Date

    /// Add a `TimeInterval` to this `Date`.
    ///
    /// - parameter timeInterval: The value to add, in seconds.
    /// - warning: This only adjusts an absolute value. If you wish to add calendrical concepts like hours, days, months then you must use a `Calendar`. That will take into account complexities like daylight saving time, months with different numbers of days, and more.
    public mutating func addTimeInterval(_ timeInterval: TimeInterval)

    /**
        Creates and returns a Date value representing a date in the distant future.
    
        The distant future is in terms of centuries.
        */
    public static let distantFuture: Date

    /**
        Creates and returns a Date value representing a date in the distant past.
    
        The distant past is in terms of centuries.
        */
    public static let distantPast: Date

    /// Returns a `Date` initialized to the current date and time.
    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public static var now: Date { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Compare two `Date` values.
    public func compare(_ other: Date) -> ComparisonResult

    /// Returns true if the two `Date` values represent the same point in time.
    public static func == (lhs: Date, rhs: Date) -> Bool

    /// Returns true if the left hand `Date` is earlier in time than the right hand `Date`.
    public static func < (lhs: Date, rhs: Date) -> Bool

    /// Returns true if the left hand `Date` is later in time than the right hand `Date`.
    public static func > (lhs: Date, rhs: Date) -> Bool

    /// Returns a `Date` with a specified amount of time added to it.
    public static func + (lhs: Date, rhs: TimeInterval) -> Date

    /// Returns a `Date` with a specified amount of time subtracted from it.
    public static func - (lhs: Date, rhs: TimeInterval) -> Date

    /// Add a `TimeInterval` to a `Date`.
    ///
    /// - warning: This only adjusts an absolute value. If you wish to add calendrical concepts like hours, days, months then you must use a `Calendar`. That will take into account complexities like daylight saving time, months with different numbers of days, and more.
    public static func += (lhs: inout Date, rhs: TimeInterval)

    /// Subtract a `TimeInterval` from a `Date`.
    ///
    /// - warning: This only adjusts an absolute value. If you wish to add calendrical concepts like hours, days, months then you must use a `Calendar`. That will take into account complexities like daylight saving time, months with different numbers of days, and more.
    public static func -= (lhs: inout Date, rhs: TimeInterval)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date {

    /// A relative format style that is detached from the system time, and instead
    /// formats an anchor date relative to the format input.
    public struct AnchoredRelativeFormatStyle : Codable, Hashable, Sendable {

        public typealias Presentation = Date.RelativeFormatStyle.Presentation

        public typealias UnitsStyle = Date.RelativeFormatStyle.UnitsStyle

        public typealias Field = Date.RelativeFormatStyle.Field

        /// The date the formatted output refers to from the perspective of the input values.
        public var anchor: Date

        public var presentation: Date.AnchoredRelativeFormatStyle.Presentation

        public var unitsStyle: Date.AnchoredRelativeFormatStyle.UnitsStyle

        public var capitalizationContext: FormatStyleCapitalizationContext

        public var locale: Locale

        public var calendar: Calendar

        /// The fields that can be used in the formatted output.
        public var allowedFields: Set<Date.AnchoredRelativeFormatStyle.Field>

        /// Create a relative format style that is detached from the system time, and instead
        /// formats an anchor date relative to the format input.
        ///
        /// - Parameter anchor: The date the formatted output is referring to.
        public init(anchor: Date, presentation: Date.AnchoredRelativeFormatStyle.Presentation = .numeric, unitsStyle: Date.AnchoredRelativeFormatStyle.UnitsStyle = .wide, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown)

        /// Create a relative format style that is detached from the system time, and instead
        /// formats an anchor date relative to the format input.
        ///
        /// - Parameter anchor: The date the formatted output is referring to.
        public init(anchor: Date, allowedFields: Set<Date.AnchoredRelativeFormatStyle.Field>, presentation: Date.AnchoredRelativeFormatStyle.Presentation = .numeric, unitsStyle: Date.AnchoredRelativeFormatStyle.UnitsStyle = .wide, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown)

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ input: Date) -> String

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Date.AnchoredRelativeFormatStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.AnchoredRelativeFormatStyle, b: Date.AnchoredRelativeFormatStyle) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

extension Date {

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public struct IntervalFormatStyle : Codable, Hashable, Sendable {

        public typealias DateStyle = Date.FormatStyle.DateStyle

        public typealias TimeStyle = Date.FormatStyle.TimeStyle

        public var locale: Locale

        public var timeZone: TimeZone

        public var calendar: Calendar

        /// Creates a new `FormatStyle` with the given configurations.
        /// - Parameters:
        ///   - date: The style for formatting the date part of the given date pairs. Note that if `.omitted` is specified, but the date interval spans more than one day, a locale-specific fallback will be used.
        ///   - time: The style for formatting the time part of the given date pairs.
        ///   - locale: The locale to use when formatting date and time values.
        ///   - calendar: The calendar to use for date values.
        ///   - timeZone: The time zone with which to specify date and time values.
        /// - Important: Always specify the date length, time length, or the date components to be included in the formatted string with the symbol modifiers. Otherwise, an empty string will be returned when you use the instance to format an object.
        /// - Note: If specifying the date fields, and the `DateInterval` range is larger than the specified units, a locale-specific fallback will be used.
        ///     - Example: for the range 2010-03-04 07:56 - 2010-03-08 16:11 (4 days, 8 hours, 15 minutes), specifying `.hour().minute()` will produce
        ///         - for en_US, "3/4/2010 7:56 AM - 3/8/2010 4:11 PM"
        ///         - for en_GB, "4/3/2010 7:56 - 8/3/2010 16:11"
        public init(date: Date.IntervalFormatStyle.DateStyle? = nil, time: Date.IntervalFormatStyle.TimeStyle? = nil, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, timeZone: TimeZone = .autoupdatingCurrent)

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ v: Range<Date>) -> String

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Date.IntervalFormatStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.IntervalFormatStyle, b: Date.IntervalFormatStyle) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

extension Date {

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public struct RelativeFormatStyle : Codable, Hashable, Sendable {

        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        public typealias Field = Date.ComponentsFormatStyle.Field

        public struct UnitsStyle : Codable, Hashable, Sendable {

            /// "2 months ago", "next Wednesday"
            public static var wide: Date.RelativeFormatStyle.UnitsStyle { get }

            /// "two months ago", "next Wednesday"
            public static var spellOut: Date.RelativeFormatStyle.UnitsStyle { get }

            /// "2 mo. ago", "next Wed."
            public static var abbreviated: Date.RelativeFormatStyle.UnitsStyle { get }

            /// "2 mo. ago", "next W"
            public static var narrow: Date.RelativeFormatStyle.UnitsStyle { get }

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.RelativeFormatStyle.UnitsStyle, b: Date.RelativeFormatStyle.UnitsStyle) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        public struct Presentation : Codable, Hashable, Sendable {

            /// "1 day ago", "2 days ago", "1 week ago", "in 1 week"
            public static var numeric: Date.RelativeFormatStyle.Presentation { get }

            /// "yesterday", "2 days ago", "last week", "next week"; falls back to the numeric style if no name is available.
            public static var named: Date.RelativeFormatStyle.Presentation { get }

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.RelativeFormatStyle.Presentation, b: Date.RelativeFormatStyle.Presentation) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        public var presentation: Date.RelativeFormatStyle.Presentation

        public var unitsStyle: Date.RelativeFormatStyle.UnitsStyle

        public var capitalizationContext: FormatStyleCapitalizationContext

        public var locale: Locale

        public var calendar: Calendar

        /// The fields that can be used in the formatted output.
        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        public var allowedFields: Set<Date.RelativeFormatStyle.Field>

        public init(presentation: Date.RelativeFormatStyle.Presentation = .numeric, unitsStyle: Date.RelativeFormatStyle.UnitsStyle = .wide, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown)

        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        public init(allowedFields: Set<Date.RelativeFormatStyle.Field>, presentation: Date.RelativeFormatStyle.Presentation = .numeric, unitsStyle: Date.RelativeFormatStyle.UnitsStyle = .wide, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown)

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ destDate: Date) -> String

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Date.RelativeFormatStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.RelativeFormatStyle, b: Date.RelativeFormatStyle) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {

    /// Formats a `Date` using the given format.
    public struct VerbatimFormatStyle : Sendable {

        public var timeZone: TimeZone

        public var calendar: Calendar

        /// Use system locale if nil or unspecified.
        public var locale: Locale?

        public init(format: Date.FormatString, locale: Locale? = nil, timeZone: TimeZone, calendar: Calendar)

        /// Returns a type erased attributed variant of this style.
        @available(macOS, introduced: 12, deprecated: 15, message: "Use attributedStyle instead")
        @available(iOS, introduced: 15, deprecated: 18, message: "Use attributedStyle instead")
        @available(tvOS, introduced: 15, deprecated: 18, message: "Use attributedStyle instead")
        @available(watchOS, introduced: 8, deprecated: 11, message: "Use attributedStyle instead")
        public var attributed: Date.AttributedStyle { get }

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ value: Date) -> String

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Date.VerbatimFormatStyle
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {

    /// Strategies for formatting a `Date`.
    public struct FormatStyle : Sendable {

        /// The locale to use when formatting date and time values.
        public var locale: Locale

        /// The time zone with which to specify date and time values.
        public var timeZone: TimeZone

        /// The calendar to use for date values.
        public var calendar: Calendar

        /// The capitalization formatting context used when formatting date and time values.
        public var capitalizationContext: FormatStyleCapitalizationContext

        /// Returns a type erased attributed variant of this style.
        @available(macOS, introduced: 12, deprecated: 15, message: "Use attributedStyle instead")
        @available(iOS, introduced: 15, deprecated: 18, message: "Use attributedStyle instead")
        @available(tvOS, introduced: 15, deprecated: 18, message: "Use attributedStyle instead")
        @available(watchOS, introduced: 8, deprecated: 11, message: "Use attributedStyle instead")
        public var attributed: Date.AttributedStyle { get }

        /// Creates a new `FormatStyle` with the given configurations.
        /// - Parameters:
        ///   - date:  The date style for formatting the date.
        ///   - time:  The time style for formatting the date.
        ///   - locale: The locale to use when formatting date and time values.
        ///   - calendar: The calendar to use for date values.
        ///   - timeZone: The time zone with which to specify date and time values.
        ///   - capitalizationContext: The capitalization formatting context used when formatting date and time values.
        /// - Note: Always specify the date style, time style, or the date components to be included in the formatted string with the symbol modifiers. Otherwise, an empty string will be returned when you use the instance to format a `Date`.
        public init(date: Date.FormatStyle.DateStyle? = nil, time: Date.FormatStyle.TimeStyle? = nil, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, timeZone: TimeZone = .autoupdatingCurrent, capitalizationContext: FormatStyleCapitalizationContext = .unknown)
    }

    @available(macOS, introduced: 12, deprecated: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(iOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(tvOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(watchOS, introduced: 8, deprecated: 11, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    public struct AttributedStyle : Sendable {

        /// Returns an attributed string with `AttributeScopes.FoundationAttributes.DateFieldAttribute`
        public func format(_ value: Date) -> AttributedString

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Date.AttributedStyle
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {

    public struct FormatString : Hashable, Sendable {

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatString, b: Date.FormatString) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {

    /// Converts `self` to its textual representation that contains both the date and time parts. The exact format depends on the user's preferences.
    /// - Parameters:
    ///   - date: The style for describing the date part.
    ///   - time: The style for describing the time part.
    /// - Returns: A `String` describing `self`.
    public func formatted(date: Date.FormatStyle.DateStyle, time: Date.FormatStyle.TimeStyle) -> String

    public func formatted() -> String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {

    /// Options for parsing string representations of dates to create a `Date` instance.
    public struct ParseStrategy : Hashable, Sendable {

        /// Indicates whether to use heuristics when parsing the representation.
        public var isLenient: Bool

        /// The earliest date that can be denoted by a two-digit year specifier.
        public var twoDigitStartDate: Date

        /// The locale to use when parsing date strings with the specified format.
        /// Use system locale if unspecified.
        public var locale: Locale?

        /// The time zone to use for creating the date.
        public var timeZone: TimeZone

        /// The calendar to use when parsing date strings and creating the date.
        public var calendar: Calendar

        /// The string representation of the fixed format conforming to Unicode Technical Standard #35.
        public var format: String { get }

        /// Creates a new `ParseStrategy` with the given configurations.
        /// - Parameters:
        ///   - format: A fixed format representing the pattern of the date string.
        ///   - locale: The locale of the fixed format.
        ///   - timeZone: The time zone to use for creating the date.
        ///   - isLenient: Whether to use heuristics when parsing the representation.
        ///   - twoDigitStartDate: The earliest date that can be denoted by a two-digit year specifier.
        public init(format: Date.FormatString, locale: Locale? = nil, timeZone: TimeZone, calendar: Calendar = Calendar(identifier: .gregorian), isLenient: Bool = true, twoDigitStartDate: Date = Date(timeIntervalSince1970: 0))

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.ParseStrategy, b: Date.ParseStrategy) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {

    public func formatted<F>(_ format: F) -> F.FormatOutput where F : FormatStyle, F.FormatInput == Date

    public init<T>(_ value: T.ParseInput, strategy: T) throws where T : ParseStrategy, T.ParseOutput == Date

    public init<T, Value>(_ value: Value, strategy: T) throws where T : ParseStrategy, Value : StringProtocol, T.ParseInput == String, T.ParseOutput == Date
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Date {

    /// Options for generating and parsing string representations of dates following the HTTP date format from [RFC 9110 § 5.6.7](https://www.rfc-editor.org/rfc/rfc9110.html#http.date).
    public struct HTTPFormatStyle : Sendable, Hashable, Codable, ParseableFormatStyle {

        public init()

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ date: Date) -> String

        /// Creates an instance of the `ParseOutput` type from `value`.
        public func parse(_ value: String) throws -> Date

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.HTTPFormatStyle, b: Date.HTTPFormatStyle) -> Bool

        @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
        public typealias Strategy = Date.HTTPFormatStyle

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {

    public func ISO8601Format(_ style: Date.ISO8601FormatStyle = .init()) -> String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date {

    /// Options for generating and parsing string representations of dates following the ISO 8601 standard.
    public struct ISO8601FormatStyle : Sendable {

        public enum TimeZoneSeparator : String, Codable, Sendable {

            case colon

            case omitted

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: String)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
            public typealias RawValue = String

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: String { get }
        }

        public enum DateSeparator : String, Codable, Sendable {

            case dash

            case omitted

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: String)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
            public typealias RawValue = String

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: String { get }
        }

        public enum TimeSeparator : String, Codable, Sendable {

            case colon

            case omitted

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: String)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
            public typealias RawValue = String

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: String { get }
        }

        public enum DateTimeSeparator : String, Codable, Sendable {

            case space

            case standard

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: String)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
            public typealias RawValue = String

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: String { get }
        }

        public var timeSeparator: Date.ISO8601FormatStyle.TimeSeparator { get }

        /// If set, the style includes fractional seconds when formatting.
        /// Before Swift 6.2, if true when parsing, fractional seconds must be present. If false when parsing, fractional seconds must not be present.
        /// After Swift 6.2, fractional seconds may be present in the String regardless of the setting of this property.
        public var includingFractionalSeconds: Bool { get }

        public var timeZoneSeparator: Date.ISO8601FormatStyle.TimeZoneSeparator { get }

        public var dateSeparator: Date.ISO8601FormatStyle.DateSeparator { get }

        public var dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator { get }

        /// The time zone to use to create and parse date representations.
        public var timeZone: TimeZone

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Date.ISO8601FormatStyle, rhs: Date.ISO8601FormatStyle) -> Bool

        public init(dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeZone: TimeZone = TimeZone(secondsFromGMT: 0)!)

        public init(dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted, includingFractionalSeconds: Bool = false, timeZone: TimeZone = TimeZone(secondsFromGMT: 0)!)
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Date : CustomDebugStringConvertible, CustomStringConvertible, CustomReflectable {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Date : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Date : ReferenceConvertible {

    public typealias ReferenceType = NSDate
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Date {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "Date.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Date {

    /// A type that represents the distance between two values.
    public typealias Stride = TimeInterval

    /// Returns the distance from this value to the given value, expressed as a 
    /// stride.
    ///
    /// If this type's `Stride` type conforms to `BinaryInteger`, then for two
    /// values `x` and `y`, and a distance `n = x.distance(to: y)`,
    /// `x.advanced(by: n) == y`. Using this method with types that have a
    /// noninteger `Stride` may result in an approximation.
    ///
    /// - Parameter other: The value to calculate the distance to.
    /// - Returns: The distance from this value to `other`.
    ///
    /// - Complexity: O(1)
    public func distance(to other: Date) -> TimeInterval

    /// Returns a value that is offset the specified distance from this value.
    ///
    /// Use the `advanced(by:)` method in generic code to offset a value by a
    /// specified distance. If you're working directly with numeric values, use
    /// the addition operator (`+`) instead of this method.
    ///
    ///     func addOne<T: Strideable>(to x: T) -> T
    ///         where T.Stride: ExpressibleByIntegerLiteral
    ///     {
    ///         return x.advanced(by: 1)
    ///     }
    ///
    ///     let x = addOne(to: 5)
    ///     // x == 6
    ///     let y = addOne(to: 3.5)
    ///     // y = 4.5
    ///
    /// If this type's `Stride` type conforms to `BinaryInteger`, then for a
    /// value `x`, a distance `n`, and a value `y = x.advanced(by: n)`,
    /// `x.distance(to: y) == n`. Using this method with types that have a
    /// noninteger `Stride` may result in an approximation. If the result of
    /// advancing by `n` is not representable as a value of this type, then a
    /// runtime error may occur.
    ///
    /// - Parameter n: The distance to advance this value.
    /// - Returns: A value that is offset from this value by `n`.
    ///
    /// - Complexity: O(1)
    public func advanced(by n: TimeInterval) -> Date
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Date : Strideable {
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Date {

    public struct SystemClockDidChangeMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = Date

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> Date.SystemClockDidChangeMessage?
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Date {

    /// The representation is useful for debugging only.
    /// There are a number of options to acquire a formatted string for a date including: date formatters
    /// (see [NSDateFormatter](//apple_ref/occ/cl/NSDateFormatter) and
    /// [Data Formatting Guide](//apple_ref/doc/uid/10000029i)), and the `Date`
    /// function `description(locale:)`.
    public var description: String { get }

    /**
         Returns a string representation of the receiver using the given
         locale.
    
         - Parameter locale: A `Locale`. If you pass `nil`, `Date` formats the date in the same way as the `description` property.
    
         - Returns: A string representation of the `Date`, using the given locale, or if the locale argument is `nil`, in the international format `YYYY-MM-DD HH:MM:SS ±HHMM`, where `±HHMM` represents the time zone offset in hours and minutes from UTC (for example, "`2001-03-24 10:45:32 +0600`").
         */
    public func description(with locale: Locale?) -> String
}

extension Date {

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public struct ComponentsFormatStyle : FormatStyle, Codable, Hashable, Sendable {

        public struct Field : Codable, Hashable, Sendable {

            public static var year: Date.ComponentsFormatStyle.Field { get }

            public static var month: Date.ComponentsFormatStyle.Field { get }

            public static var week: Date.ComponentsFormatStyle.Field { get }

            public static var day: Date.ComponentsFormatStyle.Field { get }

            public static var hour: Date.ComponentsFormatStyle.Field { get }

            public static var minute: Date.ComponentsFormatStyle.Field { get }

            public static var second: Date.ComponentsFormatStyle.Field { get }

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.ComponentsFormatStyle.Field, b: Date.ComponentsFormatStyle.Field) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        public struct Style : Codable, Hashable, Sendable {

            /// Shows the fields in their full spelling.
            /// For example, "2 hour, 10 minutes", "2小時10分鐘"
            public static var wide: Date.ComponentsFormatStyle.Style { get }

            /// Shows the fields in the abbreviation.
            /// For example, "2 hr, 10 min", "2小時10分鐘"
            public static var abbreviated: Date.ComponentsFormatStyle.Style { get }

            /// Uses the abbreviated form but condensed if possible.
            /// For example, "2hr 10min", "2小時10分鐘"
            public static var condensedAbbreviated: Date.ComponentsFormatStyle.Style { get }

            /// Shows the fields in the shortest form possible.
            /// For example, "2h 10m", "2時10分"
            public static var narrow: Date.ComponentsFormatStyle.Style { get }

            /// Values are spelled out and fields are displayed in their full name.
            /// For example, "two hours, ten minutes", "2小時10分鐘"
            public static var spellOut: Date.ComponentsFormatStyle.Style { get }

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.ComponentsFormatStyle.Style, b: Date.ComponentsFormatStyle.Style) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        public var style: Date.ComponentsFormatStyle.Style

        public var fields: Set<Date.ComponentsFormatStyle.Field>?

        public var calendar: Calendar

        public var locale: Locale

        /// Controls whether the format input is formatted as a positive or negative range.
        ///
        /// When the range is formatted as a positive value, the returned string describes the time
        /// from `lowerBound` to `upperBound`. When `isPositive` is set to `false`, the
        /// returned string describes the time from `upperBound` to `lowerBound`.
        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        public var isPositive: Bool

        /// Shows the date interval with the specified style and the specified date and time fields.
        /// - Parameters:
        ///   - style: The style for the field names.
        ///   - locale: The locale for formatting the date interval. May affect the language in which the formatted fields are displayed and how the individual fields are connected.
        ///   - calendar: The calendar to interpret date values.
        ///   - fields: The fields to be included in the output string. Chosen automatically based on the interval being formatted if unspecified. Fields with 0 value are dropped.
        public init(style: Date.ComponentsFormatStyle.Style, locale: Locale = .autoupdatingCurrent, calendar: Calendar = .autoupdatingCurrent, fields: Set<Date.ComponentsFormatStyle.Field>? = nil)

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ v: Range<Date>) -> String

        public func calendar(_ calendar: Calendar) -> Date.ComponentsFormatStyle

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Date.ComponentsFormatStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.ComponentsFormatStyle, b: Date.ComponentsFormatStyle) -> Bool

        /// The type of data to format.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatInput = Range<Date>

        /// The type of the formatted data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatOutput = String

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.AnchoredRelativeFormatStyle : DiscreteFormatStyle {

    /// The next discretization boundary before the given input.
    ///
    /// Use this function to determine the next "smaller" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce downwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(before: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "greatest" value "smaller" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "smaller" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(before input: Date) -> Date?

    /// The next discretization boundary after the given input.
    ///
    /// Use this function to determine the next "greater" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce upwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(after: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "smallest" value "greater" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "greater" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(after input: Date) -> Date?

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(before input: Date) -> Date?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(after input: Date) -> Date?

    /// The type of data to format.
    @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
    public typealias FormatInput = Date

    /// The type of the formatted data.
    @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.IntervalFormatStyle : FormatStyle {

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Range<Date>

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.IntervalFormatStyle {

    public typealias Symbol = Date.FormatStyle.Symbol

    public func year() -> Date.IntervalFormatStyle

    public func month(_ format: Date.IntervalFormatStyle.Symbol.Month = .abbreviated) -> Date.IntervalFormatStyle

    public func day() -> Date.IntervalFormatStyle

    public func weekday(_ format: Date.IntervalFormatStyle.Symbol.Weekday = .abbreviated) -> Date.IntervalFormatStyle

    public func hour(_ format: Date.IntervalFormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Date.IntervalFormatStyle

    public func minute() -> Date.IntervalFormatStyle

    public func second() -> Date.IntervalFormatStyle

    public func timeZone(_ format: Date.IntervalFormatStyle.Symbol.TimeZone = .genericName(.short)) -> Date.IntervalFormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.RelativeFormatStyle : FormatStyle {

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Date

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.VerbatimFormatStyle : FormatStyle {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Date.VerbatimFormatStyle, b: Date.VerbatimFormatStyle) -> Bool

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Date

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.VerbatimFormatStyle : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: Date.ParseStrategy { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = Date.ParseStrategy
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.VerbatimFormatStyle {

    /// The type preserving attributed variant of this style.
    ///
    /// This style attributes the formatted date with the `AttributeScopes.FoundationAttributes.DateFormatFieldAttribute`.
    @dynamicMemberLookup public struct Attributed : FormatStyle, Sendable {

        public subscript<T>(dynamicMember key: KeyPath<Date.VerbatimFormatStyle, T>) -> T { get }

        public subscript<T>(dynamicMember key: WritableKeyPath<Date.VerbatimFormatStyle, T>) -> T

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ value: Date) -> AttributedString

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Date.VerbatimFormatStyle.Attributed

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.VerbatimFormatStyle.Attributed, b: Date.VerbatimFormatStyle.Attributed) -> Bool

        /// The type of data to format.
        @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
        public typealias FormatInput = Date

        /// The type of the formatted data.
        @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
        public typealias FormatOutput = AttributedString

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Return the type preserving attributed variant of this style.
    ///
    /// This style attributes the formatted date with the `AttributeScopes.FoundationAttributes.DateFormatFieldAttribute`.
    public var attributedStyle: Date.VerbatimFormatStyle.Attributed { get }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Date.VerbatimFormatStyle : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Date

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Date)?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.VerbatimFormatStyle : DiscreteFormatStyle {

    /// The next discretization boundary before the given input.
    ///
    /// Use this function to determine the next "smaller" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce downwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(before: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "greatest" value "smaller" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "smaller" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(before input: Date) -> Date?

    /// The next discretization boundary after the given input.
    ///
    /// Use this function to determine the next "greater" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce upwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(after: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "smallest" value "greater" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "greater" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(after input: Date) -> Date?

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(before input: Date) -> Date?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(after input: Date) -> Date?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle {

    public struct Symbol : Hashable, Sendable {

        public struct Era : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Era, b: Date.FormatStyle.Symbol.Era) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct Year : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Year, b: Date.FormatStyle.Symbol.Year) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct YearForWeekOfYear : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.YearForWeekOfYear, b: Date.FormatStyle.Symbol.YearForWeekOfYear) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct CyclicYear : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.CyclicYear, b: Date.FormatStyle.Symbol.CyclicYear) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct Quarter : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Quarter, b: Date.FormatStyle.Symbol.Quarter) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct Month : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Month, b: Date.FormatStyle.Symbol.Month) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct Week : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Week, b: Date.FormatStyle.Symbol.Week) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct Day : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Day, b: Date.FormatStyle.Symbol.Day) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct DayOfYear : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.DayOfYear, b: Date.FormatStyle.Symbol.DayOfYear) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct Weekday : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Weekday, b: Date.FormatStyle.Symbol.Weekday) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct DayPeriod : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.DayPeriod, b: Date.FormatStyle.Symbol.DayPeriod) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct Hour : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Hour, b: Date.FormatStyle.Symbol.Hour) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct Minute : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Minute, b: Date.FormatStyle.Symbol.Minute) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct Second : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.Second, b: Date.FormatStyle.Symbol.Second) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct SecondFraction : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.SecondFraction, b: Date.FormatStyle.Symbol.SecondFraction) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct TimeZone : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.TimeZone, b: Date.FormatStyle.Symbol.TimeZone) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct StandaloneQuarter : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.StandaloneQuarter, b: Date.FormatStyle.Symbol.StandaloneQuarter) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct StandaloneMonth : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.StandaloneMonth, b: Date.FormatStyle.Symbol.StandaloneMonth) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct StandaloneWeekday : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.StandaloneWeekday, b: Date.FormatStyle.Symbol.StandaloneWeekday) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        public struct VerbatimHour : Hashable, Sendable {

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Date.FormatStyle.Symbol.VerbatimHour, b: Date.FormatStyle.Symbol.VerbatimHour) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatStyle.Symbol, b: Date.FormatStyle.Symbol) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle {

    /// The type preserving attributed variant of this style.
    ///
    /// This style attributes the formatted date with the `AttributeScopes.FoundationAttributes.DateFormatFieldAttribute`.
    @dynamicMemberLookup public struct Attributed : FormatStyle, Sendable {

        public subscript<T>(dynamicMember key: KeyPath<Date.FormatStyle, T>) -> T { get }

        public subscript<T>(dynamicMember key: WritableKeyPath<Date.FormatStyle, T>) -> T

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ value: Date) -> AttributedString

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Date.FormatStyle.Attributed

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatStyle.Attributed, b: Date.FormatStyle.Attributed) -> Bool

        /// The type of data to format.
        @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
        public typealias FormatInput = Date

        /// The type of the formatted data.
        @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
        public typealias FormatOutput = AttributedString

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Return the type preserving attributed variant of this style.
    ///
    /// This style attributes the formatted date with the `AttributeScopes.FoundationAttributes.DateFormatFieldAttribute`.
    public var attributedStyle: Date.FormatStyle.Attributed { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle {

    /// Change the representation of the era in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func era(_ format: Date.FormatStyle.Symbol.Era = .abbreviated) -> Date.FormatStyle

    /// Change the representation of the year in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func year(_ format: Date.FormatStyle.Symbol.Year = .defaultDigits) -> Date.FormatStyle

    /// Change the representation of the quarter in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func quarter(_ format: Date.FormatStyle.Symbol.Quarter = .abbreviated) -> Date.FormatStyle

    /// Change the representation of the month in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func month(_ format: Date.FormatStyle.Symbol.Month = .abbreviated) -> Date.FormatStyle

    /// Change the representation of the week in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func week(_ format: Date.FormatStyle.Symbol.Week = .defaultDigits) -> Date.FormatStyle

    /// Change the representation of the day of the month in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func day(_ format: Date.FormatStyle.Symbol.Day = .defaultDigits) -> Date.FormatStyle

    /// Change the representation of the day of the year in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func dayOfYear(_ format: Date.FormatStyle.Symbol.DayOfYear = .defaultDigits) -> Date.FormatStyle

    /// Change the representation of the weekday in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func weekday(_ format: Date.FormatStyle.Symbol.Weekday = .abbreviated) -> Date.FormatStyle

    /// Change the representation of the hour in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func hour(_ format: Date.FormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Date.FormatStyle

    /// Change the representation of the minute in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func minute(_ format: Date.FormatStyle.Symbol.Minute = .defaultDigits) -> Date.FormatStyle

    /// Change the representation of the second in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func second(_ format: Date.FormatStyle.Symbol.Second = .defaultDigits) -> Date.FormatStyle

    /// Change the representation of the second fraction in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func secondFraction(_ format: Date.FormatStyle.Symbol.SecondFraction) -> Date.FormatStyle

    /// Change the representation of the time zone in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func timeZone(_ format: Date.FormatStyle.Symbol.TimeZone = .specificName(.short)) -> Date.FormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : FormatStyle {

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: Date) -> String

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> Date.FormatStyle

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Date

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : ParseStrategy {

    /// Creates an instance of the `ParseOutput` type from `value`.
    public func parse(_ value: String) throws -> Date

    /// The type of the representation describing the data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseInput = String

    /// The type of the data type.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseOutput = Date
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : Codable, Hashable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Date.FormatStyle, b: Date.FormatStyle) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle {

    /// Predefined date styles varied in lengths or the components included. The exact format depends on the locale.
    public struct DateStyle : Codable, Hashable, Sendable {

        /// Excludes the date part.
        public static let omitted: Date.FormatStyle.DateStyle

        /// Shows date components in their numeric form. For example, "10/21/2015".
        public static let numeric: Date.FormatStyle.DateStyle

        /// Shows date components in their abbreviated form if possible. For example, "Oct 21, 2015".
        public static let abbreviated: Date.FormatStyle.DateStyle

        /// Shows date components in their long form if possible. For example, "October 21, 2015".
        public static let long: Date.FormatStyle.DateStyle

        /// Shows the complete day. For example, "Wednesday, October 21, 2015".
        public static let complete: Date.FormatStyle.DateStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatStyle.DateStyle, b: Date.FormatStyle.DateStyle) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Predefined time styles varied in lengths or the components included. The exact format depends on the locale.
    public struct TimeStyle : Codable, Hashable, Sendable {

        /// Excludes the time part.
        public static let omitted: Date.FormatStyle.TimeStyle

        /// For example, `04:29 PM`, `16:29`.
        public static let shortened: Date.FormatStyle.TimeStyle

        /// For example, `4:29:24 PM`, `16:29:24`.
        public static let standard: Date.FormatStyle.TimeStyle

        /// For example, `4:29:24 PM PDT`, `16:29:24 GMT`.
        public static let complete: Date.FormatStyle.TimeStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatStyle.TimeStyle, b: Date.FormatStyle.TimeStyle) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: Date.FormatStyle { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = Date.FormatStyle
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle : DiscreteFormatStyle {

    /// The next discretization boundary before the given input.
    ///
    /// Use this function to determine the next "smaller" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce downwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(before: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "greatest" value "smaller" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "smaller" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(before input: Date) -> Date?

    /// The next discretization boundary after the given input.
    ///
    /// Use this function to determine the next "greater" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce upwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(after: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "smallest" value "greater" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "greater" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(after input: Date) -> Date?

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(before input: Date) -> Date?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(after input: Date) -> Date?
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Date.FormatStyle : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Date

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Date)?
}

@available(macOS, introduced: 12, deprecated: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
@available(iOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
@available(tvOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
@available(watchOS, introduced: 8, deprecated: 11, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
extension Date.AttributedStyle : FormatStyle {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Date.AttributedStyle, b: Date.AttributedStyle) -> Bool

    /// The type of data to format.
    @available(iOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(tvOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(watchOS, introduced: 8, deprecated: 11, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(macOS, introduced: 12, deprecated: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    public typealias FormatInput = Date

    /// The type of the formatted data.
    @available(iOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(tvOS, introduced: 15, deprecated: 18, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(watchOS, introduced: 8, deprecated: 11, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    @available(macOS, introduced: 12, deprecated: 15, message: "Use Date.FormatStyle.Attributed or Date.VerbatimFormatStyle.Attributed instead")
    public typealias FormatOutput = AttributedString

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatString : ExpressibleByStringInterpolation {

    /// Creates an instance from a string interpolation.
    /// 
    /// Most `StringInterpolation` types will store information about the
    /// literals and interpolations appended to them in one or more properties.
    /// `init(stringInterpolation:)` should use these properties to initialize
    /// the instance.
    /// 
    /// - Parameter stringInterpolation: An instance of `StringInterpolation`
    ///             which has had each segment of the string literal appended
    ///             to it.
    public init(stringInterpolation: Date.FormatString.StringInterpolation)

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: String)

    /// The type each segment of a string literal containing interpolations
    /// should be appended to.
    ///
    /// The `StringLiteralType` of an interpolation type must match the
    /// `StringLiteralType` of the conforming type.
    public struct StringInterpolation : StringInterpolationProtocol, Sendable {

        /// The type that should be used for literal segments.
        public typealias StringLiteralType = String

        /// Creates an empty instance ready to be filled with string literal content.
        /// 
        /// Don't call this initializer directly. Instead, initialize a variable or
        /// constant using a string literal with interpolated expressions.
        /// 
        /// Swift passes this initializer a pair of arguments specifying the size of
        /// the literal segments and the number of interpolated segments. Use this
        /// information to estimate the amount of storage you will need.
        /// 
        /// - Parameter literalCapacity: The approximate size of all literal segments
        ///   combined. This is meant to be passed to `String.reserveCapacity(_:)`;
        ///   it may be slightly larger or smaller than the sum of the counts of each
        ///   literal segment.
        /// - Parameter interpolationCount: The number of interpolations which will be
        ///   appended. Use this value to estimate how much additional capacity will
        ///   be needed for the interpolated segments.
        public init(literalCapacity: Int, interpolationCount: Int)

        /// Appends a literal segment to the interpolation.
        /// 
        /// Don't call this method directly. Instead, initialize a variable or
        /// constant using a string literal with interpolated expressions.
        /// 
        /// Interpolated expressions don't pass through this method; instead, Swift
        /// selects an overload of `appendInterpolation`. For more information, see
        /// the top-level `StringInterpolationProtocol` documentation.
        /// 
        /// - Parameter literal: A string literal containing the characters
        ///   that appear next in the string literal.
        public mutating func appendLiteral(_ literal: String)

        public mutating func appendInterpolation(era: Date.FormatStyle.Symbol.Era)

        public mutating func appendInterpolation(year: Date.FormatStyle.Symbol.Year)

        public mutating func appendInterpolation(yearForWeekOfYear: Date.FormatStyle.Symbol.YearForWeekOfYear)

        public mutating func appendInterpolation(cyclicYear: Date.FormatStyle.Symbol.CyclicYear)

        public mutating func appendInterpolation(quarter: Date.FormatStyle.Symbol.Quarter)

        public mutating func appendInterpolation(standaloneQuarter: Date.FormatStyle.Symbol.StandaloneQuarter)

        public mutating func appendInterpolation(month: Date.FormatStyle.Symbol.Month)

        public mutating func appendInterpolation(standaloneMonth: Date.FormatStyle.Symbol.StandaloneMonth)

        public mutating func appendInterpolation(week: Date.FormatStyle.Symbol.Week)

        public mutating func appendInterpolation(day: Date.FormatStyle.Symbol.Day)

        public mutating func appendInterpolation(dayOfYear: Date.FormatStyle.Symbol.DayOfYear)

        public mutating func appendInterpolation(weekday: Date.FormatStyle.Symbol.Weekday)

        public mutating func appendInterpolation(standaloneWeekday: Date.FormatStyle.Symbol.StandaloneWeekday)

        public mutating func appendInterpolation(dayPeriod: Date.FormatStyle.Symbol.DayPeriod)

        public mutating func appendInterpolation(hour: Date.FormatStyle.Symbol.VerbatimHour)

        public mutating func appendInterpolation(minute: Date.FormatStyle.Symbol.Minute)

        public mutating func appendInterpolation(second: Date.FormatStyle.Symbol.Second)

        public mutating func appendInterpolation(secondFraction: Date.FormatStyle.Symbol.SecondFraction)

        public mutating func appendInterpolation(timeZone: Date.FormatStyle.Symbol.TimeZone)
    }

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ExtendedGraphemeClusterLiteralType = String

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias StringLiteralType = String

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias UnicodeScalarLiteralType = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ParseStrategy : ParseStrategy {

    /// Returns a `Date` of a given string interpreted using the current settings.
    /// - Parameter value: A string representation of a date.
    /// - Throws: Throws `NSFormattingError` if the string cannot be parsed.
    /// - Returns: A `Date` represented by `value`.
    public func parse(_ value: String) throws -> Date

    /// The type of the representation describing the data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseInput = String

    /// The type of the data type.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseOutput = Date

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Date.ParseStrategy : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Date

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Date)?
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Date.HTTPFormatStyle : ParseStrategy {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: Date.HTTPFormatStyle { get }

    /// The type of the representation describing the data.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias ParseInput = String

    /// The type of the data type.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias ParseOutput = Date
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Date.HTTPFormatStyle : FormatStyle {

    /// The type of data to format.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias FormatInput = Date

    /// The type of the formatted data.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias FormatOutput = String
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Date.HTTPFormatStyle : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Date

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Date)?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle {

    public func year() -> Date.ISO8601FormatStyle

    public func weekOfYear() -> Date.ISO8601FormatStyle

    public func month() -> Date.ISO8601FormatStyle

    public func day() -> Date.ISO8601FormatStyle

    public func time(includingFractionalSeconds: Bool) -> Date.ISO8601FormatStyle

    public func timeZone(separator: Date.ISO8601FormatStyle.TimeZoneSeparator) -> Date.ISO8601FormatStyle

    public func dateSeparator(_ separator: Date.ISO8601FormatStyle.DateSeparator) -> Date.ISO8601FormatStyle

    public func dateTimeSeparator(_ separator: Date.ISO8601FormatStyle.DateTimeSeparator) -> Date.ISO8601FormatStyle

    public func timeSeparator(_ separator: Date.ISO8601FormatStyle.TimeSeparator) -> Date.ISO8601FormatStyle

    public func timeZoneSeparator(_ separator: Date.ISO8601FormatStyle.TimeZoneSeparator) -> Date.ISO8601FormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle : FormatStyle {

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: Date) -> String

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Date

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle : ParseStrategy {

    /// Creates an instance of the `ParseOutput` type from `value`.
    public func parse(_ value: String) throws -> Date

    /// The type of the representation describing the data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseInput = String

    /// The type of the data type.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseOutput = Date
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: Date.ISO8601FormatStyle { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = Date.ISO8601FormatStyle
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Date.ISO8601FormatStyle : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Date

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Date)?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.ComponentsFormatStyle : DiscreteFormatStyle {

    /// The next discretization boundary before the given input.
    ///
    /// Use this function to determine the next smaller input that warrants updating the formatted output.
    /// If ``isPositive`` is true, the returned range has the same `lowerBound` as the `input`,
    /// but reduces the `upperBound` so that the returned range produces the next smaller output.
    /// If ``isPositive`` is false, the returned range has the same `upperBound` as the
    /// `input` and a smaller `lowerBound`.
    ///
    ///      let style = Date.ComponentsFormatStyle(style: .wide)
    ///      print(style.format(start..<end)) // "1 hour"
    ///      guard let next = style.discreteInput(before: start..<end) else {
    ///          return
    ///      }
    ///      print(style.format(next)) // "59 minutes, 59 seconds"
    ///
    /// - Returns: If ``isPositve`` is true, the range `input.lowerBound..<x`, where `x` is
    /// the greatest date that is smaller than `input.upperBound` for which this style might produce a
    /// different ``FormatStyle/FormatOutput``. The function may return `nil` if there is no such
    /// value greater or equal to `input.lowerBound`. If ``isPositive`` is false, the range
    /// `x..<input.upperBound`, where `x` is the greatest date that is smaller than
    /// `input.lowerBound` for which this style might produce a different
    /// ``FormatStyle/FormatOutput``.
    public func discreteInput(before input: Range<Date>) -> Range<Date>?

    /// The next discretization boundary after the given input.
    ///
    /// Use this function to determine the next greater input that warrants updating the formatted output.
    /// If ``isPositive`` is true, the returned range has the same `lowerBound` as the `input`,
    /// but increases the `upperBound` so that the returned range produces the next greater output.
    /// If ``isPositive`` is false, the returned range has the same `upperBound` as the `input`
    /// and a greater `lowerBound`.
    ///
    ///     let style = Date.ComponentsFormatStyle(style: .wide)
    ///     print(style.format(start..<end)) // "1 hour"
    ///     guard let next = style.discreteInput(after: start..<end) else {
    ///         return
    ///     }
    ///     print(style.format(next)) // "1 hour, 1 second"
    ///
    /// - Returns: If ``isPositive`` is true, the range `input.lowerBound..<x`, where `x` is
    /// the greatest date that is smaller than `input.upperBound` for which this style might produce a
    /// different ``FormatStyle/FormatOutput``. If ``isPositive`` is false, the range
    /// `x..<input.upperBound`, where `x` is the smallest date that is greater than
    /// `input.lowerBound` for which this style might produce a different
    /// ``FormatStyle/FormatOutput``. The function may return `nil` if there is no such
    /// value smaller or equal to `input.upperBound`.
    public func discreteInput(after input: Range<Date>) -> Range<Date>?

    /// The next input value before the given input.
    ///
    /// If ``isPositive`` is true, the next input value maintains the same `lowerBound` as
    /// `input`, but has a different`upperBound`. If ``isPositive`` is false, the next input value
    /// maintains the same `upperBound` as `input`, but as a different `lowerBound`.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    ///     guard let x = style.discreteInput(after: y) else {
    ///         return
    ///     }
    ///
    ///     let z = style.input(before: x) ?? y
    ///
    /// If the distance between the `upperBound`s of `z` and `x` is too large for the precision you
    /// require, you may want to manually probe ``format(_:)`` at a higher rate in that interval, as
    /// there is no guarantee for what the output will be in that interval.
    ///
    /// - Returns: If ``isPositive`` is true, the range `input.lowerBound..<x`, where `x` is
    /// the next smaller date that this style can differentiate, or `nil` if there is no such `x` greater or
    /// equal to `input.lowerBound`. If ``isPositive`` is false, the range
    /// `x..<input.upperBound`, where `x` is the next smaller date this style can differentiate.
    public func input(before input: Range<Date>) -> Range<Date>?

    /// The next input value after the given input.
    ///
    /// If ``isPositive`` is true, the next input value maintains the same `lowerBound` as
    /// `input`, but has a different`upperBound`. If ``isPositive`` is false, the next input value
    /// maintains the same `upperBound` as `input`, but as a different `lowerBound`.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    ///     guard let x = style.discreteInput(before: y) else {
    ///         return
    ///     }
    ///
    ///     let z = style.input(after: x) ?? y
    ///
    /// If the distance between the `upperBound`s of `x` and `z` is too large for the precision you
    /// require, you may want to manually probe ``format(_:)`` at a higher rate in that interval, as
    /// there is no guarantee for what the output will be in that interval.
    ///
    /// - Returns: If ``isPositive`` is true, the range `input.lowerBound..<x`, where `x` is
    /// the next larger date that this style can differentiate. If ``isPositive`` is false, the range
    /// `x..<input.upperBound`, where `x` is the next higher date this style can differentiate, or
    /// `nil` if there is no such `x`.
    public func input(after input: Range<Date>) -> Range<Date>?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.VerbatimFormatStyle.Attributed : DiscreteFormatStyle {

    /// The next discretization boundary before the given input.
    ///
    /// Use this function to determine the next "smaller" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce downwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(before: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "greatest" value "smaller" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "smaller" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(before input: Date) -> Date?

    /// The next discretization boundary after the given input.
    ///
    /// Use this function to determine the next "greater" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce upwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(after: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "smallest" value "greater" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "greater" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(after input: Date) -> Date?

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(before input: Date) -> Date?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(after input: Date) -> Date?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Attributed {

    /// Change the representation of the era in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func era(_ format: Date.FormatStyle.Symbol.Era = .abbreviated) -> Date.FormatStyle.Attributed

    /// Change the representation of the year in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func year(_ format: Date.FormatStyle.Symbol.Year = .defaultDigits) -> Date.FormatStyle.Attributed

    /// Change the representation of the quarter in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func quarter(_ format: Date.FormatStyle.Symbol.Quarter = .abbreviated) -> Date.FormatStyle.Attributed

    /// Change the representation of the month in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func month(_ format: Date.FormatStyle.Symbol.Month = .abbreviated) -> Date.FormatStyle.Attributed

    /// Change the representation of the week in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func week(_ format: Date.FormatStyle.Symbol.Week = .defaultDigits) -> Date.FormatStyle.Attributed

    /// Change the representation of the day of the month in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func day(_ format: Date.FormatStyle.Symbol.Day = .defaultDigits) -> Date.FormatStyle.Attributed

    /// Change the representation of the day of the year in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func dayOfYear(_ format: Date.FormatStyle.Symbol.DayOfYear = .defaultDigits) -> Date.FormatStyle.Attributed

    /// Change the representation of the weekday in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func weekday(_ format: Date.FormatStyle.Symbol.Weekday = .abbreviated) -> Date.FormatStyle.Attributed

    /// Change the representation of the hour in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func hour(_ format: Date.FormatStyle.Symbol.Hour = .defaultDigits(amPM: .abbreviated)) -> Date.FormatStyle.Attributed

    /// Change the representation of the minute in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func minute(_ format: Date.FormatStyle.Symbol.Minute = .defaultDigits) -> Date.FormatStyle.Attributed

    /// Change the representation of the second in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func second(_ format: Date.FormatStyle.Symbol.Second = .defaultDigits) -> Date.FormatStyle.Attributed

    /// Change the representation of the second fraction in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func secondFraction(_ format: Date.FormatStyle.Symbol.SecondFraction) -> Date.FormatStyle.Attributed

    /// Change the representation of the time zone in the format.
    ///
    /// - Parameter format: Set the symbol representation or pass `nil` to remove it.
    public func timeZone(_ format: Date.FormatStyle.Symbol.TimeZone = .specificName(.short)) -> Date.FormatStyle.Attributed
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Attributed : DiscreteFormatStyle {

    /// The next discretization boundary before the given input.
    ///
    /// Use this function to determine the next "smaller" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce downwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(before: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "greatest" value "smaller" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "smaller" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(before input: Date) -> Date?

    /// The next discretization boundary after the given input.
    ///
    /// Use this function to determine the next "greater" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce upwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(after: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "smallest" value "greater" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "greater" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    public func discreteInput(after input: Date) -> Date?

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(before input: Date) -> Date?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(after input: Date) -> Date?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeZoneSeparator : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeZoneSeparator : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeZoneSeparator : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateSeparator : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateSeparator : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateSeparator : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeSeparator : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeSeparator : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.TimeSeparator : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateTimeSeparator : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateTimeSeparator : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.ISO8601FormatStyle.DateTimeSeparator : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Era {

    /// Abbreviated Era name. For example, "AD", "Reiwa", "令和".
    public static var abbreviated: Date.FormatStyle.Symbol.Era { get }

    /// Wide era name. For example, "Anno Domini", "Reiwa", "令和".
    public static var wide: Date.FormatStyle.Symbol.Era { get }

    /// Narrow era name.
    /// For example, For example, "A", "R", "R".
    public static var narrow: Date.FormatStyle.Symbol.Era { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Era {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Era
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Year {

    /// Minimum number of digits that shows the full year.
    /// For example, `2`, `20`, `201`, `2017`, `20173`.
    public static var defaultDigits: Date.FormatStyle.Symbol.Year { get }

    /// Two low-order digits.
    /// Padded or truncated if necessary. For example, `02`, `20`, `01`, `17`, `73`.
    public static var twoDigits: Date.FormatStyle.Symbol.Year { get }

    /// Three or more digits.
    /// Padded if necessary. For example, `002`, `020`, `201`, `2017`, `20173`.
    public static func padded(_ length: Int) -> Date.FormatStyle.Symbol.Year

    /// Related Gregorian year.
    /// For non-Gregorian calendars, this corresponds to the extended Gregorian year in which the calendar’s year begins. Related Gregorian years are often displayed, for example, when formatting dates in the Japanese calendar — e.g. "2012(平成24)年1月15日" — or in the Chinese calendar — e.g. "2012壬辰年腊月初四".
    public static func relatedGregorian(minimumLength: Int = 1) -> Date.FormatStyle.Symbol.Year

    /// Extended year.
    /// This is a single number designating the year of this calendar system, encompassing all supra-year fields. For example, for the Julian calendar system, year numbers are positive, with an era of BCE or CE. An extended year value for the Julian calendar system assigns positive values to CE years and negative values to BCE years, with 1 BCE being year 0.
    public static func extended(minimumLength: Int = 1) -> Date.FormatStyle.Symbol.Year
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Year {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Year
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.YearForWeekOfYear {

    /// Minimum number of digits that shows the full year in "Week of Year"-based calendars.
    /// For example, `2`, `20`, `201`, `2017`, `20173`.
    public static var defaultDigits: Date.FormatStyle.Symbol.YearForWeekOfYear { get }

    /// Two low-order digits.  Padded or truncated if necessary.
    /// For example, `02`, `20`, `01`, `17`, `73`.
    public static var twoDigits: Date.FormatStyle.Symbol.YearForWeekOfYear { get }

    /// Three or more digits. Padded if necessary.
    /// For example, `002`, `020`, `201`, `2017`, `20173`.
    public static func padded(_ length: Int) -> Date.FormatStyle.Symbol.YearForWeekOfYear
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.YearForWeekOfYear {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.YearForWeekOfYear
}

/// Cyclic year symbols.
///
/// Calendars such as the Chinese lunar calendar (and related calendars) and the Hindu calendars use 60-year cycles of year names. If the calendar does not provide cyclic year name data, or if the year value to be formatted is out of the range of years for which cyclic name data is provided, then numeric formatting is used (behaves like `Year`).
///
/// Currently the data only provides abbreviated names, which will be used for all requested name widths.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.CyclicYear {

    /// Abbreviated cyclic year name.
    /// For example, "甲子".
    public static var abbreviated: Date.FormatStyle.Symbol.CyclicYear { get }

    /// Wide cyclic year name.
    /// For example, "甲子".
    public static var wide: Date.FormatStyle.Symbol.CyclicYear { get }

    /// Narrow cyclic year name.
    /// For example, "甲子".
    public static var narrow: Date.FormatStyle.Symbol.CyclicYear { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.CyclicYear {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.CyclicYear
}

/// Quarter symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Quarter {

    /// Numeric: one digit quarter. For example `2`.
    public static var oneDigit: Date.FormatStyle.Symbol.Quarter { get }

    /// Numeric: two digits with zero padding. For example `02`.
    public static var twoDigits: Date.FormatStyle.Symbol.Quarter { get }

    /// Abbreviated quarter. For example `Q2`.
    public static var abbreviated: Date.FormatStyle.Symbol.Quarter { get }

    /// The quarter spelled out in full, for example `2nd quarter`.
    public static var wide: Date.FormatStyle.Symbol.Quarter { get }

    /// Narrow quarter. For example `2`.
    public static var narrow: Date.FormatStyle.Symbol.Quarter { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Quarter {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Quarter
}

/// Month symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Month {

    /// Minimum number of digits that shows the numeric month. Intended to be used in conjunction with `Day.defaultDigits`.
    /// For example, `9`, `12`.
    public static var defaultDigits: Date.FormatStyle.Symbol.Month { get }

    /// 2 digits, zero pad if needed. For example, `09`, `12`.
    public static var twoDigits: Date.FormatStyle.Symbol.Month { get }

    /// Abbreviated month name. For example, "Sep".
    public static var abbreviated: Date.FormatStyle.Symbol.Month { get }

    /// Wide month name. For example, "September".
    public static var wide: Date.FormatStyle.Symbol.Month { get }

    /// Narrow month name. For example, "S".
    public static var narrow: Date.FormatStyle.Symbol.Month { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Month {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Month
}

/// Week symbols. Use with `YearForWeekOfYear` for the year field instead of `Year`.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Week {

    /// Numeric week of year. For example, `8`, `27`.
    public static var defaultDigits: Date.FormatStyle.Symbol.Week { get }

    /// Two-digit numeric week of year, zero padded as necessary. For example, `08`, `27`.
    public static var twoDigits: Date.FormatStyle.Symbol.Week { get }

    /// One-digit numeric week of month, starting from 1. For example, `1`.
    public static var weekOfMonth: Date.FormatStyle.Symbol.Week { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Week {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Week
}

/// Day symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Day {

    /// Minimum number of digits that shows the full numeric day of month. For example, `1`, `18`.
    public static var defaultDigits: Date.FormatStyle.Symbol.Day { get }

    /// Two-digit, zero-padded if necessary. For example, `01`, `18`.
    public static var twoDigits: Date.FormatStyle.Symbol.Day { get }

    /// Ordinal of day in month.
    /// For example, the 2nd Wed in July would yield `2`.
    public static var ordinalOfDayInMonth: Date.FormatStyle.Symbol.Day { get }

    /// The field length specifies the minimum number of digits, with zero-padding as necessary.
    /// This is different from the conventional Julian day number in two regards. First, it demarcates days at local zone midnight, rather than noon GMT. Second, it is a local number; that is, it depends on the local time zone. It can be thought of as a single number that encompasses all the date-related fields.
    /// For example, `2451334`.
    public static func julianModified(minimumLength: Int = 1) -> Date.FormatStyle.Symbol.Day
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Day {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Day
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.DayOfYear {

    /// Minimum number of digits that shows the full numeric day of year. For example, `7`, `33`, `345`.
    public static var defaultDigits: Date.FormatStyle.Symbol.DayOfYear { get }

    /// Two-digit day of year, with zero-padding as necessary. For example, `07`, `33`, `345`.
    public static var twoDigits: Date.FormatStyle.Symbol.DayOfYear { get }

    /// Three-digit day of year, with zero-padding as necessary. For example, `007`, `033`, `345`.
    public static var threeDigits: Date.FormatStyle.Symbol.DayOfYear { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.DayOfYear {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.DayOfYear
}

/// Week day name symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Weekday {

    /// Abbreviated day of week name. For example, "Tue".
    public static var abbreviated: Date.FormatStyle.Symbol.Weekday { get }

    /// Wide day of week name. For example, "Tuesday".
    public static var wide: Date.FormatStyle.Symbol.Weekday { get }

    /// Narrow day of week name. For example, "T".
    public static var narrow: Date.FormatStyle.Symbol.Weekday { get }

    /// Short day of week name. For example, "Tu".
    public static var short: Date.FormatStyle.Symbol.Weekday { get }

    /// Local day of week number/name. The value depends on the local starting day of the week.
    public static var oneDigit: Date.FormatStyle.Symbol.Weekday { get }

    /// Local day of week number/name, format style; two digits, zero-padded if necessary.
    public static var twoDigits: Date.FormatStyle.Symbol.Weekday { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Weekday {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Weekday
}

/// The time period (for example, "a.m." or "p.m."). May be upper or lower case depending on the locale and other options.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.DayPeriod {

    public enum Width : Sendable {

        case abbreviated

        case wide

        case narrow

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatStyle.Symbol.DayPeriod.Width, b: Date.FormatStyle.Symbol.DayPeriod.Width) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Standard day period. For example,
    /// Abbreviated: `12 am.`
    /// Wide: `12 am`
    /// Narrow: `12a`.
    public static func standard(_ width: Date.FormatStyle.Symbol.DayPeriod.Width) -> Date.FormatStyle.Symbol.DayPeriod

    /// Day period including designations for noon and midnight. For example,
    /// Abbreviated: `mid`
    /// Wide: `midnight`
    /// Narrow: `md`.
    public static func with12s(_ width: Date.FormatStyle.Symbol.DayPeriod.Width) -> Date.FormatStyle.Symbol.DayPeriod

    /// Conversational day period. For example,
    /// Abbreviated: `at night`, `nachm.`, `ip.`
    /// Wide: `at night`, `nachmittags`, `iltapäivällä`.
    /// Narrow: `at night`, `nachm.`, `iltap`.
    public static func conversational(_ width: Date.FormatStyle.Symbol.DayPeriod.Width) -> Date.FormatStyle.Symbol.DayPeriod
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.DayPeriod {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.DayPeriod
}

/// Hour symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Hour {

    public struct AMPMStyle : Codable, Hashable, Sendable {

        /// Hides the day period marker (AM/PM).
        /// For example, `8` (for 8 in the morning), `1` (for 1 in the afternoon) if used with `defaultDigits`.
        /// Or `08`, `01` if used with `twoDigits`.
        public static let omitted: Date.FormatStyle.Symbol.Hour.AMPMStyle

        /// Narrow day period if the locale prefers using day period with hour.
        /// For example, `8`, `8a`, `13`, `1p` if used with `defaultDigits`.
        /// Or `08`, `08a`, `13`, `01p` if used with `twoDigits`.
        public static let narrow: Date.FormatStyle.Symbol.Hour.AMPMStyle

        /// Abbreviated day period if the locale prefers using day period with hour.
        /// For example, `8`, `8 AM`, `13`, `1 PM` if used with `defaultDigits`.
        /// Or `08`, `08 AM`, `13`, `01 PM` if used with `twoDigits`.
        public static let abbreviated: Date.FormatStyle.Symbol.Hour.AMPMStyle

        /// Wide day period if the locale prefers using day period with hour.
        /// For example, `8`, `8 A.M.`, `13`, `1 P.M.` if used with `defaultDigits`.
        /// Or, `08`, `08 A.M.`, `13`, `01 P.M.` if used with `twoDigits`.
        public static let wide: Date.FormatStyle.Symbol.Hour.AMPMStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatStyle.Symbol.Hour.AMPMStyle, b: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// The preferred numeric hour format for the locale with minimum digits. Whether the period symbol (AM/PM) will be shown depends on the locale.
    public static func defaultDigits(amPM: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Date.FormatStyle.Symbol.Hour

    /// The preferred two-digit hour format for the locale, zero padded if necessary. Whether the period symbol (AM/PM) will be shown depends on the locale.
    public static func twoDigits(amPM: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Date.FormatStyle.Symbol.Hour

    /// Behaves like `defaultDigits`: the preferred numeric hour format for the locale with minimum digits. May also use conversational period formats.
    public static func conversationalDefaultDigits(amPM: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Date.FormatStyle.Symbol.Hour

    /// Behaves like `twoDigits`: two-digit hour format for the locale, zero padded if necessary. May also use conversational period formats.
    public static func conversationalTwoDigits(amPM: Date.FormatStyle.Symbol.Hour.AMPMStyle) -> Date.FormatStyle.Symbol.Hour

    @available(*, deprecated, renamed: "defaultDigits(amPM:)")
    public static var defaultDigitsNoAMPM: Date.FormatStyle.Symbol.Hour { get }

    @available(*, deprecated, renamed: "twoDigits(amPM:)")
    public static var twoDigitsNoAMPM: Date.FormatStyle.Symbol.Hour { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Hour {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Hour
}

/// Minute symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Minute {

    /// Minimum digits to show the numeric minute. Truncated, not rounded. For example, `8`, `59`.
    public static var defaultDigits: Date.FormatStyle.Symbol.Minute { get }

    /// Two-digit numeric, zero padded if needed. For example, `08`, `59`.
    public static var twoDigits: Date.FormatStyle.Symbol.Minute { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Minute {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Minute
}

/// Second symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.Second {

    /// Minimum digits to show the numeric second. Truncated, not rounded. For example, `8`, `12`.
    public static var defaultDigits: Date.FormatStyle.Symbol.Second { get }

    /// Two digits numeric, zero padded if needed, not rounded. For example, `08`, `12`.
    public static var twoDigits: Date.FormatStyle.Symbol.Second { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.Second {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.Second
}

/// Fractions of a second  symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.SecondFraction {

    /// Fractional second (numeric).
    /// Truncates, like other numeric time fields, but in this case to the number of digits specified by the associated `Int`.
    /// For example, specifying `4` for seconds value `12.34567` yields `12.3456`.
    public static func fractional(_ val: Int) -> Date.FormatStyle.Symbol.SecondFraction

    /// Milliseconds in day (numeric).
    /// The associated `Int` specifies the minimum number of digits, with zero-padding as necessary. The maximum number of digits is 9.
    /// This field behaves exactly like a composite of all time-related fields, not including the zone fields. As such, it also reflects discontinuities of those fields on DST transition days. On a day of DST onset, it will jump forward. On a day of DST cessation, it will jump backward. This reflects the fact that is must be combined with the offset field to obtain a unique local time value.
    public static func milliseconds(_ val: Int) -> Date.FormatStyle.Symbol.SecondFraction
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.SecondFraction {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.SecondFraction
}

/// Time zone symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.TimeZone {

    public enum Width : Sendable {

        case short

        case long

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatStyle.Symbol.TimeZone.Width, b: Date.FormatStyle.Symbol.TimeZone.Width) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Specific non-location format. Falls back to `shortLocalizedGMT` if unavailable. For example,
    /// short: "PDT"
    /// long: "Pacific Daylight Time".
    public static func specificName(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone

    /// Generic non-location format. Falls back to `genericLocation` if unavailable. For example,
    /// short: "PT". Fallback again to `localizedGMT(.short)` if `genericLocation(.short)` is unavailable.
    /// long: "Pacific Time"
    public static func genericName(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone

    /// The ISO8601 format with hours, minutes and optional seconds fields. For example,
    /// short: "-0800"
    /// long: "-08:00" or "-07:52:58".
    public static func iso8601(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone

    /// Short localized GMT format. For example,
    /// short: "GMT-8"
    /// long: "GMT-8:00"
    public static func localizedGMT(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone

    /// The time zone ID. For example,
    /// short: "uslax"
    /// long: "America/Los_Angeles".
    public static func identifier(_ width: Date.FormatStyle.Symbol.TimeZone.Width) -> Date.FormatStyle.Symbol.TimeZone

    /// The exemplar city (location) for the time zone. The localized exemplar city name for the special zone or unknown is used as the fallback if it is unavailable.
    /// For example, "Los Angeles".
    public static var exemplarLocation: Date.FormatStyle.Symbol.TimeZone { get }

    /// The generic location format. Falls back to `longLocalizedGMT` if unavailable. Recommends for presenting possible time zone choices for user selection.
    /// For example, "Los Angeles Time".
    public static var genericLocation: Date.FormatStyle.Symbol.TimeZone { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Date.FormatStyle.Symbol.TimeZone {

    /// The option for not including the symbol in the formatted output.
    public static let omitted: Date.FormatStyle.Symbol.TimeZone
}

/// Standalone quarter symbols.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.StandaloneQuarter {

    /// Standalone one-digit numeric quarter. For example `2`.
    public static var oneDigit: Date.FormatStyle.Symbol.StandaloneQuarter { get }

    /// Two-digit standalone numeric quarter with zero padding if necessary, for example `02`.
    public static var twoDigits: Date.FormatStyle.Symbol.StandaloneQuarter { get }

    /// Standalone abbreviated quarter. For example `Q2`.
    public static var abbreviated: Date.FormatStyle.Symbol.StandaloneQuarter { get }

    /// Standalone wide quarter. For example "2nd quarter".
    public static var wide: Date.FormatStyle.Symbol.StandaloneQuarter { get }

    /// Standalone narrow quarter. For example "2".
    public static var narrow: Date.FormatStyle.Symbol.StandaloneQuarter { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.StandaloneMonth {

    /// Stand-alone minimum digits numeric month. Number/name (intended to be used without `Day`).
    /// For example, `9`, `12`.
    public static var defaultDigits: Date.FormatStyle.Symbol.StandaloneMonth { get }

    /// Stand-alone two-digit numeric month.
    /// Two digits, zero pad if needed. For example, `09`, `12`.
    public static var twoDigits: Date.FormatStyle.Symbol.StandaloneMonth { get }

    /// Stand-alone abbreviated month.
    /// For example, "Sep".
    public static var abbreviated: Date.FormatStyle.Symbol.StandaloneMonth { get }

    /// Stand-alone wide month.
    /// For example, "September".
    public static var wide: Date.FormatStyle.Symbol.StandaloneMonth { get }

    /// Stand-alone narrow month.
    /// For example, "S".
    public static var narrow: Date.FormatStyle.Symbol.StandaloneMonth { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.StandaloneWeekday {

    /// Standalone local day of week number/name.
    public static var oneDigit: Date.FormatStyle.Symbol.StandaloneWeekday { get }

    /// Standalone local day of week number/name.
    /// For example, "Tue".
    public static var abbreviated: Date.FormatStyle.Symbol.StandaloneWeekday { get }

    /// Standalone wide local day of week number/name.
    /// For example, "Tuesday".
    public static var wide: Date.FormatStyle.Symbol.StandaloneWeekday { get }

    /// Standalone narrow local day of week number/name.
    /// For example, "T".
    public static var narrow: Date.FormatStyle.Symbol.StandaloneWeekday { get }

    /// Standalone short local day of week number/name.
    /// For example, "Tu".
    public static var short: Date.FormatStyle.Symbol.StandaloneWeekday { get }
}

/// Hour symbols that does not take users' preferences into account, and is displayed as-is.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.VerbatimHour {

    public struct HourCycle : Codable, Hashable, Sendable {

        /// The hour ranges from 0 to 11 in a 12-hour clock. Ranges from 0 to 23 in a 24-hour clock.
        public static let zeroBased: Date.FormatStyle.Symbol.VerbatimHour.HourCycle

        /// The hour ranges from 1 to 12 in the 12-hour clock. Ranges from 1 to 24 in a 24-hour clock.
        public static let oneBased: Date.FormatStyle.Symbol.VerbatimHour.HourCycle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatStyle.Symbol.VerbatimHour.HourCycle, b: Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct Clock : Codable, Hashable, Sendable {

        /// In a 12-hour clock system, the 24-hour day is divided into two periods, a.m. and p.m, and each period consists of 12 hours.
        /// - Note: Does not include the period marker (AM/PM). Specify a `PeriodSymbol` if that's desired.
        public static let twelveHour: Date.FormatStyle.Symbol.VerbatimHour.Clock

        /// In a 24-hour clock system, the day runs from midnight to midnight, dividing into 24 hours.
        /// - Note: If using `twentyFourHour` together with `PeriodSymbol`, the period is ignored.
        public static let twentyFourHour: Date.FormatStyle.Symbol.VerbatimHour.Clock

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Date.FormatStyle.Symbol.VerbatimHour.Clock, b: Date.FormatStyle.Symbol.VerbatimHour.Clock) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Minimum digits to show the numeric hour. For example, `1`, `12`.
    /// Or `23` if using the `twentyFourHour` clock.
    /// - Note: This format does not take user's locale preferences into account. Consider using `defaultDigits` if applicable.
    public static func defaultDigits(clock: Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Date.FormatStyle.Symbol.VerbatimHour

    /// Numeric two-digit hour, zero padded if necessary.
    /// For example, `01`, `12`.
    /// Or `23` if using the `twentyFourHour` clock.
    /// - Note: This format does not take user's locale preferences into account. Consider using `defaultDigits` if applicable.
    public static func twoDigits(clock: Date.FormatStyle.Symbol.VerbatimHour.Clock, hourCycle: Date.FormatStyle.Symbol.VerbatimHour.HourCycle) -> Date.FormatStyle.Symbol.VerbatimHour
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.DayPeriod.Width : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.DayPeriod.Width : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.TimeZone.Width : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Date.FormatStyle.Symbol.TimeZone.Width : Hashable {
}

/**
 `DateComponents` encapsulates the components of a date in an extendable, structured manner.

 It is used to specify a date by providing the temporal components that make up a date and time in a particular calendar: hour, minutes, seconds, day, month, year, and so on. It can also be used to specify a duration of time, for example, 5 hours and 16 minutes. A `DateComponents` is not required to define all the component fields.

 When a new instance of `DateComponents` is created, the date components are set to `nil`.
*/
@available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct DateComponents : Hashable, Equatable, Sendable {

    /// Initialize a `DateComponents`, optionally specifying values for its fields.
    public init(calendar: Calendar? = nil, timeZone: TimeZone? = nil, era: Int? = nil, year: Int? = nil, month: Int? = nil, day: Int? = nil, hour: Int? = nil, minute: Int? = nil, second: Int? = nil, nanosecond: Int? = nil, weekday: Int? = nil, weekdayOrdinal: Int? = nil, quarter: Int? = nil, weekOfMonth: Int? = nil, weekOfYear: Int? = nil, yearForWeekOfYear: Int? = nil)

    /// The `Calendar` used to interpret the other values in this structure.
    ///
    /// - note: API which uses `DateComponents` may have different behavior if this value is `nil`. For example, assuming the current calendar or ignoring certain values.
    public var calendar: Calendar?

    /// A time zone.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var timeZone: TimeZone?

    /// An era or count of eras.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var era: Int?

    /// A year or count of years.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var year: Int?

    /// A month or count of months.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var month: Int?

    /// A day or count of days.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var day: Int?

    /// An hour or count of hours.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var hour: Int?

    /// A minute or count of minutes.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var minute: Int?

    /// A second or count of seconds.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var second: Int?

    /// A nanosecond or count of nanoseconds.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var nanosecond: Int?

    /// A weekday or count of weekdays.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var weekday: Int?

    /// A weekday ordinal or count of weekday ordinals.
    /// Weekday ordinal units represent the position of the weekday within the next larger calendar unit, such as the month. For example, 2 is the weekday ordinal unit for the second Friday of the month.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var weekdayOrdinal: Int?

    /// A quarter or count of quarters.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var quarter: Int?

    /// A week of the month or a count of weeks of the month.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var weekOfMonth: Int?

    /// A week of the year or count of the weeks of the year.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var weekOfYear: Int?

    /// A day of the year.
    /// For example, in the Gregorian calendar, can go from 1 to 365 or 1 to 366 in leap years.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public var dayOfYear: Int?

    /// The ISO 8601 week-numbering year of the receiver.
    ///
    /// The Gregorian calendar defines a week to have 7 days, and a year to have 365 days, or 366 in a leap year. However, neither 365 or 366 divide evenly into a 7 day week, so it is often the case that the last week of a year ends on a day in the next year, and the first week of a year begins in the preceding year. To reconcile this, ISO 8601 defines a week-numbering year, consisting of either 52 or 53 full weeks (364 or 371 days), such that the first week of a year is designated to be the week containing the first Thursday of the year.
    ///
    /// You can use the yearForWeekOfYear property with the weekOfYear and weekday properties to get the date corresponding to a particular weekday of a given week of a year. For example, the 6th day of the 53rd week of the year 2005 (ISO 2005-W53-6) corresponds to Sat 1 January 2005 on the Gregorian calendar.
    /// - note: This value is interpreted in the context of the calendar in which it is used.
    public var yearForWeekOfYear: Int?

    /// Set to true if these components represent a leap month.
    public var isLeapMonth: Bool?

    /// Set to true if these components represent a repeated day.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public var isRepeatedDay: Bool?

    /// Returns a `Date` calculated from the current components using the `calendar` property.
    public var date: Date? { get }

    /// Set the value of one of the properties, using an enumeration value instead of a property name.
    ///
    /// The calendar, timeZone, isLeapMonth, and isRepeatedDay properties cannot be set by this method.
    @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public mutating func setValue(_ value: Int?, for component: Calendar.Component)

    /// Returns the value of one of the properties, using an enumeration value instead of a property name.
    ///
    /// The calendar, timeZone, isLeapMonth, and isRepeatedDay property values cannot be retrieved by this method.
    @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func value(for component: Calendar.Component) -> Int?

    /// Returns true if the combination of properties which have been set in the receiver is a date which exists in the `calendar` property.
    ///
    /// This method is not appropriate for use on `DateComponents` values which are specifying relative quantities of calendar components.
    ///
    /// Except for some trivial cases (e.g., 'seconds' should be 0 - 59 in any calendar), this method is not necessarily cheap.
    ///
    /// If the time zone property is set in the `DateComponents`, it is used.
    ///
    /// The calendar property must be set, or the result is always `false`.
    @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var isValidDate: Bool { get }

    /// Returns true if the combination of properties which have been set in the receiver is a date which exists in the specified `Calendar`.
    ///
    /// This method is not appropriate for use on `DateComponents` values which are specifying relative quantities of calendar components.
    ///
    /// Except for some trivial cases (e.g., 'seconds' should be 0 - 59 in any calendar), this method is not necessarily cheap.
    ///
    /// If the time zone property is set in the `DateComponents`, it is used.
    @available(macOS 10.9, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func isValidDate(in calendar: Calendar) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: DateComponents, rhs: DateComponents) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents {

    /// Converts `self` to its textual representation.
    /// - Parameter format: The format for formatting `self`.
    /// - Returns: A representation of `self` using the given `format`. The type of the representation is specified by `FormatStyle.FormatOutput`.
    public func formatted<F>(_ format: F) -> F.FormatOutput where F : FormatStyle, F.FormatInput == DateComponents

    /// Creates a new `DateComponents` by parsing the given representation.
    /// - Parameter value: A representation of a date. The type of the representation is specified by `ParseStrategy.ParseInput`.
    /// - Parameters:
    ///   - value: A representation of a date. The type of the representation is specified by `ParseStrategy.ParseInput`.
    ///   - strategy: The parse strategy to parse `value` whose `ParseOutput` is `DateComponents`.
    public init<T>(_ value: T.ParseInput, strategy: T) throws where T : ParseStrategy, T.ParseOutput == DateComponents

    /// Creates a new `DateComponents` by parsing the given string representation.
    public init<T, Value>(_ value: Value, strategy: T) throws where T : ParseStrategy, Value : StringProtocol, T.ParseInput == String, T.ParseOutput == DateComponents
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension DateComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension DateComponents : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension DateComponents : ReferenceConvertible {

    public typealias ReferenceType = NSDateComponents
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents {

    /// Converts `DateComponents` into RFC 9110-compatible "HTTP date" `String`, and parses in the reverse direction.
    /// This parser does not do validation on the individual values of the components. An optional date can be created from the result using `Calendar(identifier: .gregorian).date(from: ...)`.
    /// When formatting, missing or invalid fields are filled with default values: `Sun`, `01`, `Jan`, `2000`, `00:00:00`, `GMT`. Note that missing fields may result in an invalid date or time. Other values in the `DateComponents` are ignored.
    public struct HTTPFormatStyle : Sendable, Hashable, Codable, ParseableFormatStyle {

        public init()

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ components: DateComponents) -> String

        /// Creates an instance of the `ParseOutput` type from `value`.
        public func parse(_ value: String) throws -> DateComponents

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: DateComponents.HTTPFormatStyle, b: DateComponents.HTTPFormatStyle) -> Bool

        @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
        public typealias Strategy = DateComponents.HTTPFormatStyle

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents {

    /// Options for generating and parsing string representations of dates following the ISO 8601 standard.
    public struct ISO8601FormatStyle : Hashable, Sendable, Codable {

        public var timeSeparator: Date.ISO8601FormatStyle.TimeSeparator { get }

        /// If set, fractional seconds will be present in formatted output. Fractional seconds may be present in parsing regardless of the setting of this property.
        public var includingFractionalSeconds: Bool { get }

        public var timeZoneSeparator: Date.ISO8601FormatStyle.TimeZoneSeparator { get }

        public var dateSeparator: Date.ISO8601FormatStyle.DateSeparator { get }

        public var dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: DateComponents.ISO8601FormatStyle, rhs: DateComponents.ISO8601FormatStyle) -> Bool

        /// The time zone to use to create and parse date representations.
        public var timeZone: TimeZone

        public init(dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted, includingFractionalSeconds: Bool = false, timeZone: TimeZone = TimeZone(secondsFromGMT: 0)!)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents.HTTPFormatStyle : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = DateComponents

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: DateComponents)?
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents.HTTPFormatStyle : FormatStyle {

    /// The type of data to format.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias FormatInput = DateComponents

    /// The type of the formatted data.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias FormatOutput = String
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents.HTTPFormatStyle : ParseStrategy {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: DateComponents.HTTPFormatStyle { get }

    /// The type of the representation describing the data.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias ParseInput = String

    /// The type of the data type.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias ParseOutput = DateComponents
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents.ISO8601FormatStyle {

    public func year() -> DateComponents.ISO8601FormatStyle

    public func weekOfYear() -> DateComponents.ISO8601FormatStyle

    public func month() -> DateComponents.ISO8601FormatStyle

    public func day() -> DateComponents.ISO8601FormatStyle

    public func time(includingFractionalSeconds: Bool) -> DateComponents.ISO8601FormatStyle

    public func timeZone(separator: Date.ISO8601FormatStyle.TimeZoneSeparator) -> DateComponents.ISO8601FormatStyle

    public func dateSeparator(_ separator: Date.ISO8601FormatStyle.DateSeparator) -> DateComponents.ISO8601FormatStyle

    public func dateTimeSeparator(_ separator: Date.ISO8601FormatStyle.DateTimeSeparator) -> DateComponents.ISO8601FormatStyle

    public func timeSeparator(_ separator: Date.ISO8601FormatStyle.TimeSeparator) -> DateComponents.ISO8601FormatStyle

    public func timeZoneSeparator(_ separator: Date.ISO8601FormatStyle.TimeZoneSeparator) -> DateComponents.ISO8601FormatStyle
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents.ISO8601FormatStyle : FormatStyle {

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: DateComponents) -> String

    /// The type of data to format.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias FormatInput = DateComponents

    /// The type of the formatted data.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias FormatOutput = String
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents.ISO8601FormatStyle : ParseStrategy {

    /// Creates an instance of the `ParseOutput` type from `value`.
    public func parse(_ value: String) throws -> DateComponents

    /// The type of the representation describing the data.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias ParseInput = String

    /// The type of the data type.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias ParseOutput = DateComponents
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents.ISO8601FormatStyle : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: DateComponents.ISO8601FormatStyle { get }

    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias Strategy = DateComponents.ISO8601FormatStyle
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DateComponents.ISO8601FormatStyle : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = DateComponents

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: DateComponents)?
}

/// DateInterval represents a closed date interval in the form of [startDate, endDate].  It is possible for the start and end dates to be the same with a duration of 0.  DateInterval does not support reverse intervals i.e. intervals where the duration is less than 0 and the end date occurs earlier in time than the start date.
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct DateInterval : Comparable, Hashable, Codable, Sendable {

    /// The start date.
    public var start: Date

    /// The end date.
    ///
    /// - precondition: `end >= start`
    public var end: Date

    /// The duration.
    ///
    /// - precondition: `duration >= 0`
    public var duration: TimeInterval

    /// Initializes a `DateInterval` with start and end dates set to the current date and the duration set to `0`.
    public init()

    /// Initialize a `DateInterval` with the specified start and end date.
    ///
    /// - precondition: `end >= start`
    public init(start: Date, end: Date)

    /// Initialize a `DateInterval` with the specified start date and duration.
    ///
    /// - precondition: `duration >= 0`
    public init(start: Date, duration: TimeInterval)

    /**
         Compare two DateIntervals.
    
         This method prioritizes ordering by start date. If the start dates are equal, then it will order by duration.
         e.g. Given intervals a and b
         ```
         a.   |-----|
         b.      |-----|
         ```
    
         `a.compare(b)` would return `.OrderedAscending` because a's start date is earlier in time than b's start date.
    
         In the event that the start dates are equal, the compare method will attempt to order by duration.
         e.g. Given intervals c and d
         ```
         c.  |-----|
         d.  |---|
         ```
         `c.compare(d)` would result in `.OrderedDescending` because c is longer than d.
    
         If both the start dates and the durations are equal, then the intervals are considered equal and `.OrderedSame` is returned as the result.
        */
    public func compare(_ dateInterval: DateInterval) -> ComparisonResult

    /// Returns `true` if `self` intersects the `dateInterval`.
    public func intersects(_ dateInterval: DateInterval) -> Bool

    /// Returns a DateInterval that represents the interval where the given date interval and the current instance intersect.
    ///
    /// In the event that there is no intersection, the method returns nil.
    public func intersection(with dateInterval: DateInterval) -> DateInterval?

    /// Returns `true` if `self` contains `date`.
    public func contains(_ date: Date) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    public static func == (lhs: DateInterval, rhs: DateInterval) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
    public static func < (lhs: DateInterval, rhs: DateInterval) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension DateInterval : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension DateInterval : ReferenceConvertible {

    public typealias ReferenceType = NSDateInterval
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodableAttributedStringKey : AttributedStringKey {

    static func decode(from decoder: any Decoder) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension DecodableAttributedStringKey where Self.Value : Decodable {

    public static func decode(from decoder: any Decoder) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension DecodableAttributedStringKey where Self.Value : NSObject, Self.Value : NSSecureCoding {

    public static func decode(from decoder: any Decoder) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodableWithConfiguration {

    associatedtype DecodingConfiguration

    init(from decoder: any Decoder, configuration: Self.DecodingConfiguration) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol DecodingConfigurationProviding {

    associatedtype DecodingConfiguration

    static var decodingConfiguration: Self.DecodingConfiguration { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum DescriptiveNumberFormatConfiguration {

    public typealias CapitalizationContext = FormatStyleCapitalizationContext

    public struct Presentation : Codable, Hashable, Sendable {

        public static var spellOut: DescriptiveNumberFormatConfiguration.Presentation { get }

        public static var ordinal: DescriptiveNumberFormatConfiguration.Presentation { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: DescriptiveNumberFormatConfiguration.Presentation, b: DescriptiveNumberFormatConfiguration.Presentation) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

/// A discontiguous portion of an attributed string.
@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
@dynamicMemberLookup public struct DiscontiguousAttributedSubstring : Sendable {
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DiscontiguousAttributedSubstring {

    /// The underlying attributed string that the discontiguous attributed substring derives from.
    public var base: AttributedString { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DiscontiguousAttributedSubstring : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DiscontiguousAttributedSubstring : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: DiscontiguousAttributedSubstring, rhs: DiscontiguousAttributedSubstring) -> Bool
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DiscontiguousAttributedSubstring : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DiscontiguousAttributedSubstring : AttributedStringAttributeMutation {

    public mutating func setAttributes(_ attributes: AttributeContainer)

    public mutating func mergeAttributes(_ attributes: AttributeContainer, mergePolicy: AttributedString.AttributeMergePolicy = .keepNew)

    public mutating func replaceAttributes(_ attributes: AttributeContainer, with others: AttributeContainer)

    /// Returns a discontiguous substring of this discontiguous attributed string using a range to indicate the discontiguous substring bounds.
    /// - Parameter bounds: A range that indicates the bounds of the discontiguous substring to return.
    public subscript(bounds: some RangeExpression<AttributedString.Index>) -> DiscontiguousAttributedSubstring { get }

    /// Returns a discontiguous substring of this discontiguous attributed string using a set of ranges to indicate the discontiguous substring bounds.
    /// - Parameter bounds: A set of ranges that indicate the bounds of the discontiguous substring to return.
    public subscript(bounds: RangeSet<AttributedString.Index>) -> DiscontiguousAttributedSubstring { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DiscontiguousAttributedSubstring {

    /// The characters of the discontiguous attributed string, as a view into the underlying string.
    public var characters: DiscontiguousSlice<AttributedString.CharacterView> { get }

    /// The Unicode scalars of the discontiguous attributed string, as a view into the underlying string.
    public var unicodeScalars: DiscontiguousSlice<AttributedString.UnicodeScalarView> { get }

    /// The attributed runs of the discontiguous attributed string, as a view into the underlying string.
    public var runs: AttributedString.Runs { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension DiscontiguousAttributedSubstring {

    /// Returns an attribute value that corresponds to an attributed string key.
    ///
    /// This subscript returns `nil` unless the specified attribute exists, and is present and identical for the entire discontiguous attributed substring. To find portions of an attributed string with consistent attributes, use the `runs` property.
    /// Getting or setting stringwide attributes with this subscript has `O(n)` behavior in the worst case, where n is the number of runs.
    public subscript<K>(_: K.Type) -> K.Value? where K : AttributedStringKey, K.Value : Sendable

    /// Returns an attribute value that a key path indicates.
    ///
    /// This subscript returns `nil` unless the specified attribute exists, and is present and identical for the entire discontiguous attributed substring. To find portions of an attributed string with consistent attributes, use the `runs` property.
    /// Getting or setting stringwide attributes with this subscript has `O(n)` behavior in the worst case, where n is the number of runs.
    @inlinable public subscript<K>(dynamicMember keyPath: KeyPath<AttributeDynamicLookup, K>) -> K.Value? where K : AttributedStringKey, K.Value : Sendable

    /// Returns a scoped attribute container that a key path indicates.
    public subscript<S>(dynamicMember keyPath: KeyPath<AttributeScopes, S.Type>) -> ScopedAttributeContainer<S> where S : AttributeScope
}

/// A format style that transforms a continuous input into a discrete output and provides
/// information about its discretization boundaries.
///
/// Use this protocol to keep displays up to date if input changes continuously, or to iterate
/// over all possible outputs of a ``FormatStyle`` by obtaining the next discrete input in either direction
/// from ``discreteInput(before:)`` or ``discreteInput(after:)``.
///
/// ## Ordering of Inputs
///
/// The ordering over ``FormatStyle/FormatInput``
/// defined by ``discreteInput(before:)`` / ``discreteInput(after:)`` must be
/// consistent between the two functions. If ``FormatStyle/FormatInput`` conforms to the
/// `Comparable` protocol, the format style's ordering _should_ be consistent with the canonical ordering
/// defined via the `Comparable` conformance, i.e. it should hold that
/// `discreteInput(before: x)! < x < discreteInput(after: x)!` where discrete inputs
/// are not nil.
///
/// ## Stepping through Discrete Input/Output Pairs
///
/// One use case of this protocol is enumerating all discrete inputs of a format style and their respective
/// outputs.
///
/// While the ``discreteInput(before:)`` and ``discreteInput(after:)``
/// functions are the right tool for that, they do not give a guarantee that their respective return values
/// actually produce an output that is different from the output produced by formatting the `input` value
/// used when calling ``discreteInput(before:)`` / ``discreteInput(after:)``, they only
/// provide a value that produces a different output for _most_ inputs. E.g. when formatting a floating point
/// value as an integer, we can get the next discrete input after `x` by calculating `floor(x + 1)`.
/// However, when rounding toward zero, the whole interval (-1;1) formats as zero. It would be ok for a
/// discrete format style to ignore that edge case and return `0` for the ``discreteInput(after:)`` a
/// negative value greater than `-1`. Therefore, to enumerate all discrete input/output pairs, adjacent
/// outputs must be deduplicated in order to guarantee no adjacent outputs are the same.
///
/// The following example produces all discrete input/output pairs for inputs in a given `range` making
/// sure adjacent outputs are unequal:
///
/// ```swift
/// extension DiscreteFormatStyle
///     where FormatInput : Comparable, FormatOutput : Equatable
/// {
///         func enumerated(
///         in range: ClosedRange<FormatInput>
///     ) -> [(input: FormatInput, output: FormatOutput)] {
///         var input = range.lowerBound
///         var output = format(input)
///
///         var pairs = [(input: FormatInput, output: FormatOutput)]()
///         pairs.append((input, output))
///
///         // get the next discretization bound
///         while let nextInput = discreteInput(after: input),
///               // check that it is still in the requested `range`
///               nextInput <= range.upperBound {
///             // get the respective formatted output
///             let nextOutput = format(nextInput)
///             // deduplicate based on the formatted output
///             if nextOutput != output {
///                 pairs.append((nextInput, nextOutput))
///             }
///                 input = nextInput
///             output = nextOutput
///         }
///
///         return pairs
///     }
/// }
/// ```
///
/// ## Imperfect Discretization Boundaries
///
/// In some scenarios, a format style cannot provide precise discretization boundaries in
/// a performant manner. In those cases it must override ``input(before:)`` and
/// ``input(after:)`` to reflect that. For any discretization boundary `x` returned by either
/// ``discreteInput(before:)`` or ``discreteInput(after:)`` based on the
/// original input `y`, all values representable in the ``FormatStyle/FormatInput``strictly  between
/// `x` and the return value of `input(after: x)` or `input(before: x)`, respectively, are not
/// guaranteed to produce the same formatted output as `y`.
///
/// The following schematic shows an overview of the guarantees given by the protocol:
///
///     xB = discreteInput(before: y)       y      xA = discreteInput(after: y)
///           |                             |                             |
///     <-----+---+-------------------------+-------------------------+---+--->
///               |                                                   |
///      zB = input(after: xB)                          zA = input(before: xA)
///
/// - the formatted output for everything in `zB...zA` (including bounds) is **guaranteed** to be equal
///   to `format(y)`
/// - the formatted output for `xB` and lower is **most likely** different from `format(y)`
/// - the formatted output for `xA` and higher is **most likely** different from `format(y)`
/// - the  formatted output between `xB` and `zB`, as well as `zA` and `xA` (excluding bounds) cannot
///   be predicted
@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
public protocol DiscreteFormatStyle<FormatInput, FormatOutput> : FormatStyle {

    /// The next discretization boundary before the given input.
    ///
    /// Use this function to determine the next "smaller" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce downwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(before: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "greatest" value "smaller" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "smaller" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    func discreteInput(before input: Self.FormatInput) -> Self.FormatInput?

    /// The next discretization boundary after the given input.
    ///
    /// Use this function to determine the next "greater" input that warrants updating the formatted output.
    /// The following example prints all possible outputs the format style can produce upwards starting
    /// from the `startInput`:
    ///
    /// ```swift
    /// var previousInput = startInput
    /// while let nextInput = style.discreteInput(after: previousInput) {
    ///     print(style.format(nextInput))
    ///     previousInput = nextInput
    /// }
    /// ```
    ///
    /// - Returns: For most `input`s, the method returns the "smallest" value "greater" than
    /// `input` for which the style produces a different ``FormatStyle/FormatOutput``, or `nil`
    /// if no such value exists. For some input values, the function may also return a value "greater" than
    /// `input` for which the style still produces the same ``FormatStyle/FormatOutput`` as for
    /// `input`.
    func discreteInput(after input: Self.FormatInput) -> Self.FormatInput?

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    func input(before input: Self.FormatInput) -> Self.FormatInput?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    func input(after input: Self.FormatInput) -> Self.FormatInput?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension DiscreteFormatStyle where Self.FormatInput : FloatingPoint {

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(before input: Self.FormatInput) -> Self.FormatInput?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(after input: Self.FormatInput) -> Self.FormatInput?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension DiscreteFormatStyle where Self.FormatInput : FixedWidthInteger {

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(before input: Self.FormatInput) -> Self.FormatInput?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(after input: Self.FormatInput) -> Self.FormatInput?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension DiscreteFormatStyle where Self.FormatInput == Date {

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(before input: Self.FormatInput) -> Self.FormatInput?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(after input: Self.FormatInput) -> Self.FormatInput?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension DiscreteFormatStyle where Self.FormatInput == Duration {

    /// The next input value before the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(after:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(after: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(before: x) ?? y
    /// ```
    ///
    /// If the distance between `z` and `x` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "smalller" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(before input: Self.FormatInput) -> Self.FormatInput?

    /// The next input value after the given input.
    ///
    /// Use this function to determine if the return value provided by ``discreteInput(before:)`` is
    /// precise enough for your use case for any input `y`:
    ///
    /// ```swift
    /// guard let x = style.discreteInput(before: y) else {
    ///     return
    /// }
    ///
    /// let z = style.input(after: x) ?? y
    /// ```
    ///
    /// If the distance between `x` and `z` is too large for the precision you require, you may want
    /// to manually probe ``FormatStyle/format(_:)`` at a higher rate in that interval, as there is
    /// no guarantee for what the output will be in that interval.
    ///
    /// - Returns: The next "greater" input value that can be represented by
    /// ``FormatStyle/FormatInput`` or an underlying representation the format style uses
    /// internally.
    public func input(after input: Self.FormatInput) -> Self.FormatInput?
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodableAttributedStringKey : AttributedStringKey {

    static func encode(_ value: Self.Value, to encoder: any Encoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension EncodableAttributedStringKey where Self.Value : Encodable {

    public static func encode(_ value: Self.Value, to encoder: any Encoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension EncodableAttributedStringKey where Self.Value : NSObject, Self.Value : NSSecureCoding {

    public static func encode(_ value: Self.Value, to encoder: any Encoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodableWithConfiguration {

    associatedtype EncodingConfiguration

    func encode(to encoder: any Encoder, configuration: Self.EncodingConfiguration) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol EncodingConfigurationProviding {

    associatedtype EncodingConfiguration

    static var encodingConfiguration: Self.EncodingConfiguration { get }
}

public typealias ErrorPointer = NSErrorPointer

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct ErrorUserInfoKey : RawRepresentable, Equatable, Hashable, Sendable {

    /// Creates a new instance with the specified raw value.
    ///
    /// If there is no value of the type that corresponds with the specified raw
    /// value, this initializer returns `nil`. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     print(PaperSize(rawValue: "Legal"))
    ///     // Prints "Optional(PaperSize.Legal)"
    ///
    ///     print(PaperSize(rawValue: "Tabloid"))
    ///     // Prints "nil"
    ///
    /// - Parameter rawValue: The raw value to use for the new instance.
    public init(rawValue: String)

    /// The corresponding value of the raw type.
    ///
    /// A new instance initialized with `rawValue` will be equivalent to this
    /// instance. For example:
    ///
    ///     enum PaperSize: String {
    ///         case A4, A5, Letter, Legal
    ///     }
    ///
    ///     let selectedSize = PaperSize.Letter
    ///     print(selectedSize.rawValue)
    ///     // Prints "Letter"
    ///
    ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
    ///     // Prints "true"
    public var rawValue: String

    /// The raw type that can be used to represent all values of the conforming
    /// type.
    ///
    /// Every distinct value of the conforming type has a corresponding unique
    /// value of the `RawValue` type, but there may be values of the `RawValue`
    /// type that don't have a corresponding value of the conforming type.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias RawValue = String
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension ErrorUserInfoKey {

    @available(*, deprecated, renamed: "NSUnderlyingErrorKey")
    public static let underlyingErrorKey: ErrorUserInfoKey

    @available(*, deprecated, renamed: "NSLocalizedDescriptionKey")
    public static let localizedDescriptionKey: ErrorUserInfoKey

    @available(*, deprecated, renamed: "NSLocalizedFailureReasonErrorKey")
    public static let localizedFailureReasonErrorKey: ErrorUserInfoKey

    @available(*, deprecated, renamed: "NSLocalizedRecoverySuggestionErrorKey")
    public static let localizedRecoverySuggestionErrorKey: ErrorUserInfoKey

    @available(*, deprecated, renamed: "NSLocalizedRecoveryOptionsErrorKey")
    public static let localizedRecoveryOptionsErrorKey: ErrorUserInfoKey

    @available(*, deprecated, renamed: "NSRecoveryAttempterErrorKey")
    public static let recoveryAttempterErrorKey: ErrorUserInfoKey

    @available(*, deprecated, renamed: "NSHelpAnchorErrorKey")
    public static let helpAnchorErrorKey: ErrorUserInfoKey

    @available(*, deprecated, renamed: "NSStringEncodingErrorKey")
    public static let stringEncodingErrorKey: ErrorUserInfoKey

    @available(*, deprecated, renamed: "NSURLErrorKey")
    public static let NSURLErrorKey: ErrorUserInfoKey

    @available(*, deprecated, renamed: "NSFilePathErrorKey")
    public static let filePathErrorKey: ErrorUserInfoKey
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
public struct Expression<each Input, Output> : Sendable {

    public let expression: any StandardPredicateExpression<Output>

    public let variable: (repeat PredicateExpressions.Variable<each Input>)

    public init(_ builder: (repeat PredicateExpressions.Variable<each Input>) -> any StandardPredicateExpression<Output>)

    public func evaluate(_ input: repeat each Input) throws -> Output
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Expression : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Expression : CodableWithConfiguration {

    public typealias EncodingConfiguration = PredicateCodableConfiguration

    public typealias DecodingConfiguration = PredicateCodableConfiguration

    public func encode(to encoder: any Encoder, configuration: Expression<repeat each Input, Output>.EncodingConfiguration) throws

    public init(from decoder: any Decoder, configuration: Expression<repeat each Input, Output>.DecodingConfiguration) throws
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Expression : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Expression : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
@freestanding(expression) public macro Expression<each Input, Output>(_ body: (repeat each Input) -> Output) -> Expression<repeat each Input, Output> = #externalMacro(module: "FoundationMacros", type: "ExpressionMacro")

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FloatingPointFormatStyle<Value> : Codable, Hashable, Sendable where Value : BinaryFloatingPoint {

    public var locale: Locale

    public init(locale: Locale = .autoupdatingCurrent)

    public var attributed: FloatingPointFormatStyle<Value>.Attributed { get }

    public typealias Configuration = NumberFormatStyleConfiguration

    public func grouping(_ group: FloatingPointFormatStyle<Value>.Configuration.Grouping) -> FloatingPointFormatStyle<Value>

    public func precision(_ p: FloatingPointFormatStyle<Value>.Configuration.Precision) -> FloatingPointFormatStyle<Value>

    public func sign(strategy: FloatingPointFormatStyle<Value>.Configuration.SignDisplayStrategy) -> FloatingPointFormatStyle<Value>

    public func decimalSeparator(strategy: FloatingPointFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> FloatingPointFormatStyle<Value>

    public func rounded(rule: FloatingPointFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Double? = nil) -> FloatingPointFormatStyle<Value>

    public func scale(_ multiplicand: Double) -> FloatingPointFormatStyle<Value>

    public func notation(_ notation: FloatingPointFormatStyle<Value>.Configuration.Notation) -> FloatingPointFormatStyle<Value>

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: FloatingPointFormatStyle<Value>, b: FloatingPointFormatStyle<Value>) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle {

    public struct Percent : Codable, Hashable, Sendable {

        public var locale: Locale

        public init(locale: Locale = .autoupdatingCurrent)

        public var attributed: FloatingPointFormatStyle<Value>.Attributed { get }

        public typealias Configuration = NumberFormatStyleConfiguration

        public func grouping(_ group: FloatingPointFormatStyle<Value>.Percent.Configuration.Grouping) -> FloatingPointFormatStyle<Value>.Percent

        public func precision(_ p: FloatingPointFormatStyle<Value>.Percent.Configuration.Precision) -> FloatingPointFormatStyle<Value>.Percent

        public func sign(strategy: FloatingPointFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> FloatingPointFormatStyle<Value>.Percent

        public func decimalSeparator(strategy: FloatingPointFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> FloatingPointFormatStyle<Value>.Percent

        public func rounded(rule: FloatingPointFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Double? = nil) -> FloatingPointFormatStyle<Value>.Percent

        public func scale(_ multiplicand: Double) -> FloatingPointFormatStyle<Value>.Percent

        public func notation(_ notation: FloatingPointFormatStyle<Value>.Percent.Configuration.Notation) -> FloatingPointFormatStyle<Value>.Percent

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: FloatingPointFormatStyle<Value>.Percent, b: FloatingPointFormatStyle<Value>.Percent) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public struct Currency : Codable, Hashable, Sendable {

        public var locale: Locale

        public let currencyCode: String

        public typealias Configuration = CurrencyFormatStyleConfiguration

        public init(code: String, locale: Locale = .autoupdatingCurrent)

        public var attributed: FloatingPointFormatStyle<Value>.Attributed { get }

        public func grouping(_ group: FloatingPointFormatStyle<Value>.Currency.Configuration.Grouping) -> FloatingPointFormatStyle<Value>.Currency

        public func precision(_ p: FloatingPointFormatStyle<Value>.Currency.Configuration.Precision) -> FloatingPointFormatStyle<Value>.Currency

        public func sign(strategy: FloatingPointFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> FloatingPointFormatStyle<Value>.Currency

        public func decimalSeparator(strategy: FloatingPointFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> FloatingPointFormatStyle<Value>.Currency

        public func rounded(rule: FloatingPointFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Double? = nil) -> FloatingPointFormatStyle<Value>.Currency

        public func scale(_ multiplicand: Double) -> FloatingPointFormatStyle<Value>.Currency

        public func presentation(_ p: FloatingPointFormatStyle<Value>.Currency.Configuration.Presentation) -> FloatingPointFormatStyle<Value>.Currency

        /// Modifies the format style to use the specified notation.
        ///
        /// - Parameter notation: The notation to apply to the format style.
        /// - Returns: A floating-point currency format style modified to use the specified notation.
        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        public func notation(_ notation: FloatingPointFormatStyle<Value>.Currency.Configuration.Notation) -> FloatingPointFormatStyle<Value>.Currency

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: FloatingPointFormatStyle<Value>.Currency, b: FloatingPointFormatStyle<Value>.Currency) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle : FormatStyle {

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: Value) -> String

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> FloatingPointFormatStyle<Value>

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Value

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: FloatingPointParseStrategy<FloatingPointFormatStyle<Value>> { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = FloatingPointParseStrategy<FloatingPointFormatStyle<Value>>
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle {

    public struct Attributed : Codable, Hashable, FormatStyle, Sendable {

        /// Returns an attributed string with `NumberFormatAttributes.SymbolAttribute` and `NumberFormatAttributes.NumberPartAttribute`.
        public func format(_ value: Value) -> AttributedString

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> FloatingPointFormatStyle<Value>.Attributed

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: FloatingPointFormatStyle<Value>.Attributed, b: FloatingPointFormatStyle<Value>.Attributed) -> Bool

        /// The type of data to format.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatInput = Value

        /// The type of the formatted data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatOutput = AttributedString

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FloatingPointFormatStyle : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Value

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Value)?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Percent : FormatStyle {

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: Value) -> String

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> FloatingPointFormatStyle<Value>.Percent

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Value

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Percent : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: FloatingPointParseStrategy<FloatingPointFormatStyle<Value>.Percent> { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = FloatingPointParseStrategy<FloatingPointFormatStyle<Value>.Percent>
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FloatingPointFormatStyle.Percent : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Value

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Value)?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Currency : FormatStyle {

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: Value) -> String

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> FloatingPointFormatStyle<Value>.Currency

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Value

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointFormatStyle.Currency : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: FloatingPointParseStrategy<FloatingPointFormatStyle<Value>.Currency> { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = FloatingPointParseStrategy<FloatingPointFormatStyle<Value>.Currency>
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FloatingPointFormatStyle.Currency : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Value

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Value)?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FloatingPointParseStrategy<Format> : Codable, Hashable where Format : FormatStyle, Format.FormatInput : BinaryFloatingPoint {

    public var formatStyle: Format

    public var lenient: Bool

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: FloatingPointParseStrategy<Format>, b: FloatingPointParseStrategy<Format>) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointParseStrategy : Sendable where Format : Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointParseStrategy : ParseStrategy {

    /// Creates an instance of the `ParseOutput` type from `value`.
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public func parse(_ value: String) throws -> Format.FormatInput

    /// The type of the representation describing the data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseInput = String

    /// The type of the data type.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseOutput = Format.FormatInput
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointParseStrategy {

    public init<Value>(format: Format, lenient: Bool = true) where Format == FloatingPointFormatStyle<Value>, Value : BinaryFloatingPoint
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointParseStrategy {

    public init<Value>(format: Format, lenient: Bool = true) where Format == FloatingPointFormatStyle<Value>.Currency, Value : BinaryFloatingPoint
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointParseStrategy {

    public init<Value>(format: Format, lenient: Bool = true) where Format == FloatingPointFormatStyle<Value>.Percent, Value : BinaryFloatingPoint
}

/// A type that can convert a given data type into a representation.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol FormatStyle<FormatInput, FormatOutput> : Decodable, Encodable, Hashable {

    /// The type of data to format.
    associatedtype FormatInput

    /// The type of the formatted data.
    associatedtype FormatOutput

    /// Creates a `FormatOutput` instance from `value`.
    func format(_ value: Self.FormatInput) -> Self.FormatOutput

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    func locale(_ locale: Locale) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.IntervalFormatStyle {

    public static var interval: Date.IntervalFormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.RelativeFormatStyle {

    public static func relative(presentation: Date.RelativeFormatStyle.Presentation, unitsStyle: Date.RelativeFormatStyle.UnitsStyle = .wide) -> Self
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FormatStyle where Self == Date.VerbatimFormatStyle {

    public static func verbatim(_ format: Date.FormatString, locale: Locale? = nil, timeZone: TimeZone, calendar: Calendar) -> Date.VerbatimFormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.FormatStyle {

    public static var dateTime: Date.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Decimal.FormatStyle {

    public static var number: Decimal.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Decimal.FormatStyle.Percent {

    public static var percent: Decimal.FormatStyle.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Decimal.FormatStyle.Currency {

    public static func currency(code: String) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Double> {

    public static var number: FloatingPointFormatStyle<Double> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Float> {

    public static var number: FloatingPointFormatStyle<Float> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Double>.Percent {

    public static var percent: FloatingPointFormatStyle<Double>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Float>.Percent {

    public static var percent: FloatingPointFormatStyle<Float>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {

    public static func currency<Value>(code: String) -> Self where Self == FloatingPointFormatStyle<Value>.Currency, Value : BinaryFloatingPoint
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Float16> {

    public static var number: FloatingPointFormatStyle<Float16> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == FloatingPointFormatStyle<Float16>.Percent {

    public static var percent: FloatingPointFormatStyle<Float16>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int> {

    public static var number: IntegerFormatStyle<Int> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int16> {

    public static var number: IntegerFormatStyle<Int16> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int32> {

    public static var number: IntegerFormatStyle<Int32> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int64> {

    public static var number: IntegerFormatStyle<Int64> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int8> {

    public static var number: IntegerFormatStyle<Int8> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt> {

    public static var number: IntegerFormatStyle<UInt> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt16> {

    public static var number: IntegerFormatStyle<UInt16> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt32> {

    public static var number: IntegerFormatStyle<UInt32> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt64> {

    public static var number: IntegerFormatStyle<UInt64> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt8> {

    public static var number: IntegerFormatStyle<UInt8> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int>.Percent {

    public static var percent: IntegerFormatStyle<Int>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int16>.Percent {

    public static var percent: IntegerFormatStyle<Int16>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int32>.Percent {

    public static var percent: IntegerFormatStyle<Int32>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int64>.Percent {

    public static var percent: IntegerFormatStyle<Int64>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<Int8>.Percent {

    public static var percent: IntegerFormatStyle<Int8>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt>.Percent {

    public static var percent: IntegerFormatStyle<UInt>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt16>.Percent {

    public static var percent: IntegerFormatStyle<UInt16>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt32>.Percent {

    public static var percent: IntegerFormatStyle<UInt32>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt64>.Percent {

    public static var percent: IntegerFormatStyle<UInt64>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == IntegerFormatStyle<UInt8>.Percent {

    public static var percent: IntegerFormatStyle<UInt8>.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {

    public static func currency<V>(code: String) -> Self where Self == IntegerFormatStyle<V>.Currency, V : BinaryInteger
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == ByteCountFormatStyle {

    public static func byteCount(style: ByteCountFormatStyle.Style, allowedUnits: ByteCountFormatStyle.Units = .all, spellsOutZero: Bool = true, includesActualByteCount: Bool = false) -> Self
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FormatStyle where Self == Duration.TimeFormatStyle {

    /// A factory variable to create a time format style to format a duration.
    /// - Parameter pattern: A `Pattern` to specify the units to include in the displayed string and the behavior of the units.
    /// - Returns: A format style to format a duration.
    public static func time(pattern: Duration.TimeFormatStyle.Pattern) -> Self
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FormatStyle where Self == Duration.UnitsFormatStyle {

    /// A factory function to create a units format style to format a duration.
    /// - Parameters:
    ///   - units: The units that may be included in the output string.
    ///   - width: The width of the unit and the spacing between the value and the unit.
    ///   - maximumUnitCount: The maximum number of time units to include in the output string.
    ///   - zeroValueUnits: The strategy for how zero-value units are handled.
    ///   - valueLength: The padding or truncating behavior of the unit value.
    ///   - fractionalPart: The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
    /// - Returns: A format style to format a duration.
    public static func units(allowed units: Set<Duration.UnitsFormatStyle.Unit> = [.hours, .minutes, .seconds], width: Duration.UnitsFormatStyle.UnitWidth = .abbreviated, maximumUnitCount: Int? = nil, zeroValueUnits: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLength: Int? = nil, fractionalPart: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) -> Self

    /// A factory function to create a units format style to format a duration.
    /// - Parameters:
    ///   - allowedUnits: The units that may be included in the output string.
    ///   - width: The width of the unit and the spacing between the value and the unit.
    ///   - maximumUnitCount: The maximum number of time units to include in the output string.
    ///   - zeroValueUnits: The strategy for how zero-value units are handled.
    ///   - valueLengthLimits: The padding or truncating behavior of the unit value.
    ///   - fractionalPart: The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
    ///   - Returns: A format style to format a duration.
    public static func units<ValueRange>(allowed units: Set<Duration.UnitsFormatStyle.Unit> = [.hours, .minutes, .seconds], width: Duration.UnitsFormatStyle.UnitWidth = .abbreviated, maximumUnitCount: Int? = nil, zeroValueUnits: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLengthLimits: ValueRange, fractionalPart: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) -> Self where ValueRange : RangeExpression, ValueRange.Bound == Int
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {

    public static func list<MemberStyle, Base>(memberStyle: MemberStyle, type: ListFormatStyle<MemberStyle, Base>.ListType, width: ListFormatStyle<MemberStyle, Base>.Width = .standard) -> Self where Self == ListFormatStyle<MemberStyle, Base>, MemberStyle : FormatStyle, Base : Sequence, MemberStyle.FormatInput == Base.Element, MemberStyle.FormatOutput == String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {

    public static func list<Base>(type: ListFormatStyle<StringStyle, Base>.ListType, width: ListFormatStyle<StringStyle, Base>.Width = .standard) -> Self where Self == ListFormatStyle<StringStyle, Base>, Base : Sequence, Base.Element == String
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension FormatStyle where Self == Date.HTTPFormatStyle {

    public static var http: Date.HTTPFormatStyle { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension FormatStyle where Self == DateComponents.HTTPFormatStyle {

    public static var http: DateComponents.HTTPFormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.ISO8601FormatStyle {

    public static var iso8601: Date.ISO8601FormatStyle { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension FormatStyle where Self == DateComponents.ISO8601FormatStyle {

    public static var iso8601: DateComponents.ISO8601FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> Self
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FormatStyle where Self == URL.FormatStyle {

    public static var url: URL.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle {

    public static func measurement<UnitType>(width: Measurement<UnitType>.FormatStyle.UnitWidth, usage: MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: FloatingPointFormatStyle<Double>? = nil) -> Self where Self == Measurement<UnitType>.FormatStyle, UnitType : Dimension

    public static func measurement(width: Measurement<UnitTemperature>.FormatStyle.UnitWidth = .abbreviated, usage: MeasurementFormatUnitUsage<UnitTemperature> = .general, hidesScaleName: Bool = false, numberFormatStyle: FloatingPointFormatStyle<Double>? = nil) -> Self where Self == Measurement<UnitTemperature>.FormatStyle
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension FormatStyle where Self == Measurement<UnitInformationStorage>.FormatStyle.ByteCount {

    public static func byteCount(style: Measurement<UnitInformationStorage>.FormatStyle.ByteCount.Style, allowedUnits: Measurement<UnitInformationStorage>.FormatStyle.ByteCount.Units = .all, spellsOutZero: Bool = true, includesActualByteCount: Bool = false) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == PersonNameComponents.FormatStyle {

    public static func name(style: PersonNameComponents.FormatStyle.Style) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FormatStyle where Self == Date.ComponentsFormatStyle {

    public static func components(style: Date.ComponentsFormatStyle.Style, fields: Set<Date.ComponentsFormatStyle.Field>? = nil) -> Self

    /// A pre-defined style for showing an interval using combinations of time fields: hours, minutes, and seconds.
    /// Units may be omitted if they are not needed to represent the time interval.
    /// For example, "02:10:03".
    public static var timeDuration: Date.ComponentsFormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct FormatStyleCapitalizationContext : Codable, Hashable, Sendable {

    public static var unknown: FormatStyleCapitalizationContext { get }

    /// For stand-alone usage, such as an isolated name on a calendar page.
    public static var standalone: FormatStyleCapitalizationContext { get }

    /// For use in a UI list or menu item.
    public static var listItem: FormatStyleCapitalizationContext { get }

    public static var beginningOfSentence: FormatStyleCapitalizationContext { get }

    public static var middleOfSentence: FormatStyleCapitalizationContext { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: FormatStyleCapitalizationContext, b: FormatStyleCapitalizationContext) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/**
 `IndexPath` represents the path to a specific node in a tree of nested array collections.
 
 Each index in an index path represents the index into an array of children from one node in the tree to another, deeper, node.
 */
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct IndexPath : Equatable, Hashable, MutableCollection, RandomAccessCollection, Comparable, ExpressibleByArrayLiteral, Sendable {

    /// A type representing the sequence's elements.
    public typealias Element = Int

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    public typealias Index = Array<Int>.Index

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    public typealias Indices = DefaultIndices<IndexPath>

    /// Initialize an empty index path.
    public init()

    /// Initialize with a sequence of integers.
    public init<ElementSequence>(indexes: ElementSequence) where ElementSequence : Sequence, ElementSequence.Element == Int

    /// Initialize with an array literal.
    public init(arrayLiteral indexes: IndexPath.Element...)

    /// Initialize with an array of elements.
    public init(indexes: [IndexPath.Element])

    /// Initialize with a single element.
    public init(index: IndexPath.Element)

    /// Return a new `IndexPath` containing all but the last element.
    public func dropLast() -> IndexPath

    /// Append an `IndexPath` to `self`.
    public mutating func append(_ other: IndexPath)

    /// Append a single element to `self`.
    public mutating func append(_ other: IndexPath.Element)

    /// Append an array of elements to `self`.
    public mutating func append(_ other: [IndexPath.Element])

    /// Return a new `IndexPath` containing the elements in self and the elements in `other`.
    public func appending(_ other: IndexPath.Element) -> IndexPath

    /// Return a new `IndexPath` containing the elements in self and the elements in `other`.
    public func appending(_ other: IndexPath) -> IndexPath

    /// Return a new `IndexPath` containing the elements in self and the elements in `other`.
    public func appending(_ other: [IndexPath.Element]) -> IndexPath

    /// Accesses the element at the specified position.
    ///
    /// For example, you can replace an element of an array by using its
    /// subscript.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     streets[1] = "Butler"
    ///     print(streets[1])
    ///     // Prints "Butler"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one
    /// past the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: IndexPath.Index) -> IndexPath.Element

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     streets[index!] = "Eustace"
    ///     print(streets[index!])
    ///     // Prints "Eustace"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(range: Range<IndexPath.Index>) -> IndexPath

    /// Returns an iterator over the elements of the collection.
    public func makeIterator() -> IndexingIterator<IndexPath>

    /// The number of elements in the collection.
    ///
    /// To check whether a collection is empty, use its `isEmpty` property
    /// instead of comparing `count` to zero. Unless the collection guarantees
    /// random-access performance, calculating `count` can be an O(*n*)
    /// operation.
    ///
    /// - Complexity: O(1) if the collection conforms to
    ///   `RandomAccessCollection`; otherwise, O(*n*), where *n* is the length
    ///   of the collection.
    public var count: Int { get }

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: IndexPath.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: IndexPath.Index { get }

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: IndexPath.Index) -> IndexPath.Index

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: IndexPath.Index) -> IndexPath.Index

    /// Sorting an array of `IndexPath` using this comparison results in an array representing nodes in depth-first traversal order.
    public func compare(_ other: IndexPath) -> ComparisonResult

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: IndexPath, rhs: IndexPath) -> Bool

    public static func + (lhs: IndexPath, rhs: IndexPath) -> IndexPath

    public static func += (lhs: inout IndexPath, rhs: IndexPath)

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: IndexPath, rhs: IndexPath) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: IndexPath, rhs: IndexPath) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: IndexPath, rhs: IndexPath) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: IndexPath, rhs: IndexPath) -> Bool

    /// The type of the elements of an array literal.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias ArrayLiteralElement = IndexPath.Element

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Iterator = IndexingIterator<IndexPath>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias SubSequence = IndexPath

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexPath : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexPath : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexPath : ReferenceConvertible {

    public typealias ReferenceType = NSIndexPath
}

/// Manages a `Set` of integer values, which are commonly used as an index type in Cocoa API.
///
/// The range of valid integer values is 0..<INT_MAX-1. Anything outside this range is an error.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct IndexSet : ReferenceConvertible, Equatable, BidirectionalCollection, SetAlgebra {

    /// An view of the contents of an IndexSet, organized by range.
    ///
    /// For example, if an IndexSet is composed of:
    ///  `[1..<5]` and `[7..<10]` and `[13]`
    /// then calling `next()` on this view's iterator will produce 3 ranges before returning nil.
    public struct RangeView : Equatable, BidirectionalCollection {

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        public typealias Index = Int

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public let startIndex: IndexSet.RangeView.Index

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public let endIndex: IndexSet.RangeView.Index

        /// Returns an iterator over the elements of the collection.
        public func makeIterator() -> IndexingIterator<IndexSet.RangeView>

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(index: IndexSet.RangeView.Index) -> Range<IndexSet.Element> { get }

        /// Accesses a contiguous subrange of the collection's elements.
        ///
        /// The accessed slice uses the same indices for the same elements as the
        /// original collection uses. Always use the slice's `startIndex` property
        /// instead of assuming that its indices start at a particular value.
        ///
        /// This example demonstrates getting a slice of an array of strings, finding
        /// the index of one of the strings in the slice, and then using that index
        /// in the original array.
        ///
        ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     let streetsSlice = streets[2 ..< streets.endIndex]
        ///     print(streetsSlice)
        ///     // Prints "["Channing", "Douglas", "Evarts"]"
        ///
        ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
        ///     print(streets[index!])
        ///     // Prints "Evarts"
        ///
        /// - Parameter bounds: A range of the collection's indices. The bounds of
        ///   the range must be valid indices of the collection.
        ///
        /// - Complexity: O(1)
        public subscript(bounds: Range<IndexSet.RangeView.Index>) -> Slice<IndexSet.RangeView> { get }

        /// Returns the position immediately after the given index.
        ///
        /// The successor of an index must be well defined. For an index `i` into a
        /// collection `c`, calling `c.index(after: i)` returns the same index every
        /// time.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be less than
        ///   `endIndex`.
        /// - Returns: The index value immediately after `i`.
        public func index(after i: IndexSet.RangeView.Index) -> IndexSet.RangeView.Index

        /// Returns the position immediately before the given index.
        ///
        /// - Parameter i: A valid index of the collection. `i` must be greater than
        ///   `startIndex`.
        /// - Returns: The index value immediately before `i`.
        public func index(before i: IndexSet.RangeView.Index) -> IndexSet.RangeView.Index

        /// A type representing the sequence's elements.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias Element = Range<IndexSet.Element>

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias Indices = DefaultIndices<IndexSet.RangeView>

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias Iterator = IndexingIterator<IndexSet.RangeView>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias SubSequence = Slice<IndexSet.RangeView>
    }

    /// The mechanism for accessing the integers stored in an IndexSet.
    public struct Index : CustomStringConvertible, Comparable, Sendable {

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }
    }

    public typealias ReferenceType = NSIndexSet

    /// A type for which the conforming type provides a containment test.
    public typealias Element = Int

    /// Initialize an `IndexSet` with a range of integers.
    public init(integersIn range: Range<IndexSet.Element>)

    /// Initialize an `IndexSet` with a range of integers.
    public init<R>(integersIn range: R) where R : RangeExpression, R.Bound == Int

    /// Initialize an `IndexSet` with a single integer.
    public init(integer: IndexSet.Element)

    /// Initialize an empty `IndexSet`.
    public init()

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns the number of integers in `self`.
    public var count: Int { get }

    /// Returns an iterator over the elements of the collection.
    public func makeIterator() -> IndexingIterator<IndexSet>

    /// Returns a `Range`-based view of the entire contents of `self`.
    ///
    /// - seealso: rangeView(of:)
    public var rangeView: IndexSet.RangeView { get }

    /// Returns a `Range`-based view of `self`.
    ///
    /// - parameter range: A subrange of `self` to view.
    public func rangeView(of range: Range<IndexSet.Element>) -> IndexSet.RangeView

    /// Returns a `Range`-based view of `self`.
    ///
    /// - parameter range: A subrange of `self` to view.
    public func rangeView<R>(of range: R) -> IndexSet.RangeView where R : RangeExpression, R.Bound == Int

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    public var startIndex: IndexSet.Index { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    public var endIndex: IndexSet.Index { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    public subscript(index: IndexSet.Index) -> IndexSet.Element { get }

    /// Accesses a contiguous subrange of the collection's elements.
    ///
    /// The accessed slice uses the same indices for the same elements as the
    /// original collection uses. Always use the slice's `startIndex` property
    /// instead of assuming that its indices start at a particular value.
    ///
    /// This example demonstrates getting a slice of an array of strings, finding
    /// the index of one of the strings in the slice, and then using that index
    /// in the original array.
    ///
    ///     let streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     let streetsSlice = streets[2 ..< streets.endIndex]
    ///     print(streetsSlice)
    ///     // Prints "["Channing", "Douglas", "Evarts"]"
    ///
    ///     let index = streetsSlice.firstIndex(of: "Evarts")    // 4
    ///     print(streets[index!])
    ///     // Prints "Evarts"
    ///
    /// - Parameter bounds: A range of the collection's indices. The bounds of
    ///   the range must be valid indices of the collection.
    ///
    /// - Complexity: O(1)
    public subscript(bounds: Range<IndexSet.Index>) -> Slice<IndexSet> { get }

    /// Returns the first integer in `self`, or nil if `self` is empty.
    public var first: IndexSet.Element? { get }

    /// Returns the last integer in `self`, or nil if `self` is empty.
    public var last: IndexSet.Element? { get }

    /// Returns an integer contained in `self` which is greater than `integer`, or `nil` if a result could not be found.
    public func integerGreaterThan(_ integer: IndexSet.Element) -> IndexSet.Element?

    /// Returns an integer contained in `self` which is less than `integer`, or `nil` if a result could not be found.
    public func integerLessThan(_ integer: IndexSet.Element) -> IndexSet.Element?

    /// Returns an integer contained in `self` which is greater than or equal to `integer`, or `nil` if a result could not be found.
    public func integerGreaterThanOrEqualTo(_ integer: IndexSet.Element) -> IndexSet.Element?

    /// Returns an integer contained in `self` which is less than or equal to `integer`, or `nil` if a result could not be found.
    public func integerLessThanOrEqualTo(_ integer: IndexSet.Element) -> IndexSet.Element?

    /// Return a `Range<IndexSet.Index>` which can be used to subscript the index set.
    ///
    /// The resulting range is the range of the intersection of the integers in `range` with the index set. The resulting range will be `isEmpty` if the intersection is empty.
    ///
    /// - parameter range: The range of integers to include.
    public func indexRange(in range: Range<IndexSet.Element>) -> Range<IndexSet.Index>

    /// Return a `Range<IndexSet.Index>` which can be used to subscript the index set.
    ///
    /// The resulting range is the range of the intersection of the integers in `range` with the index set.
    ///
    /// - parameter range: The range of integers to include.
    public func indexRange<R>(in range: R) -> Range<IndexSet.Index> where R : RangeExpression, R.Bound == Int

    /// Returns the count of integers in `self` that intersect `range`.
    public func count(in range: Range<IndexSet.Element>) -> Int

    /// Returns the count of integers in `self` that intersect `range`.
    public func count<R>(in range: R) -> Int where R : RangeExpression, R.Bound == Int

    /// Returns `true` if `self` contains `integer`.
    public func contains(_ integer: IndexSet.Element) -> Bool

    /// Returns `true` if `self` contains all of the integers in `range`.
    public func contains(integersIn range: Range<IndexSet.Element>) -> Bool

    /// Returns `true` if `self` contains all of the integers in `range`.
    public func contains<R>(integersIn range: R) -> Bool where R : RangeExpression, R.Bound == Int

    /// Returns `true` if `self` contains all of the integers in `indexSet`.
    public func contains(integersIn indexSet: IndexSet) -> Bool

    /// Returns `true` if `self` intersects any of the integers in `range`.
    public func intersects(integersIn range: Range<IndexSet.Element>) -> Bool

    /// Returns `true` if `self` intersects any of the integers in `range`.
    public func intersects<R>(integersIn range: R) -> Bool where R : RangeExpression, R.Bound == Int

    /// Returns the position immediately after the given index.
    ///
    /// The successor of an index must be well defined. For an index `i` into a
    /// collection `c`, calling `c.index(after: i)` returns the same index every
    /// time.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    /// - Returns: The index value immediately after `i`.
    public func index(after i: IndexSet.Index) -> IndexSet.Index

    /// Replaces the given index with its successor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be less than
    ///   `endIndex`.
    public func formIndex(after i: inout IndexSet.Index)

    /// Returns the position immediately before the given index.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    /// - Returns: The index value immediately before `i`.
    public func index(before i: IndexSet.Index) -> IndexSet.Index

    /// Replaces the given index with its predecessor.
    ///
    /// - Parameter i: A valid index of the collection. `i` must be greater than
    ///   `startIndex`.
    public func formIndex(before i: inout IndexSet.Index)

    /// Union the `IndexSet` with `other`.
    public mutating func formUnion(_ other: IndexSet)

    /// Union the `IndexSet` with `other`.
    public func union(_ other: IndexSet) -> IndexSet

    /// Exclusive or the `IndexSet` with `other`.
    public func symmetricDifference(_ other: IndexSet) -> IndexSet

    /// Exclusive or the `IndexSet` with `other`.
    public mutating func formSymmetricDifference(_ other: IndexSet)

    /// Intersect the `IndexSet` with `other`.
    public func intersection(_ other: IndexSet) -> IndexSet

    /// Intersect the `IndexSet` with `other`.
    public mutating func formIntersection(_ other: IndexSet)

    /// Insert an integer into the `IndexSet`.
    @discardableResult
    public mutating func insert(_ integer: IndexSet.Element) -> (inserted: Bool, memberAfterInsert: IndexSet.Element)

    /// Insert an integer into the `IndexSet`.
    @discardableResult
    public mutating func update(with integer: IndexSet.Element) -> IndexSet.Element?

    /// Remove an integer from the `IndexSet`.
    @discardableResult
    public mutating func remove(_ integer: IndexSet.Element) -> IndexSet.Element?

    /// Remove all values from the `IndexSet`.
    public mutating func removeAll()

    /// Insert a range of integers into the `IndexSet`.
    public mutating func insert(integersIn range: Range<IndexSet.Element>)

    /// Insert a range of integers into the `IndexSet`.
    public mutating func insert<R>(integersIn range: R) where R : RangeExpression, R.Bound == Int

    /// Remove a range of integers from the `IndexSet`.
    public mutating func remove(integersIn range: Range<IndexSet.Element>)

    /// Remove a range of integers from the `IndexSet`.
    public mutating func remove(integersIn range: ClosedRange<IndexSet.Element>)

    /// Returns `true` if self contains no values.
    public var isEmpty: Bool { get }

    /// Returns an IndexSet filtered according to the result of `includeInteger`.
    ///
    /// - parameter range: A range of integers. For each integer in the range that intersects the integers in the IndexSet, then the `includeInteger` predicate will be invoked.
    /// - parameter includeInteger: The predicate which decides if an integer will be included in the result or not.
    public func filteredIndexSet(in range: Range<IndexSet.Element>, includeInteger: (IndexSet.Element) throws -> Bool) rethrows -> IndexSet

    /// Returns an IndexSet filtered according to the result of `includeInteger`.
    ///
    /// - parameter range: A range of integers. For each integer in the range that intersects the integers in the IndexSet, then the `includeInteger` predicate will be invoked.
    /// - parameter includeInteger: The predicate which decides if an integer will be included in the result or not.
    public func filteredIndexSet(in range: ClosedRange<IndexSet.Element>, includeInteger: (IndexSet.Element) throws -> Bool) rethrows -> IndexSet

    /// Returns an IndexSet filtered according to the result of `includeInteger`.
    ///
    /// - parameter includeInteger: The predicate which decides if an integer will be included in the result or not.
    public func filteredIndexSet(includeInteger: (IndexSet.Element) throws -> Bool) rethrows -> IndexSet

    /// For a positive delta, shifts the indexes in [index, INT_MAX] to the right, thereby inserting an "empty space" [index, delta], for a negative delta, shifts the indexes in [index, INT_MAX] to the left, thereby deleting the indexes in the range [index - delta, delta].
    public mutating func shift(startingAt integer: IndexSet.Element, by delta: Int)

    /// The type of the elements of an array literal.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias ArrayLiteralElement = IndexSet.Element

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Indices = DefaultIndices<IndexSet>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Iterator = IndexingIterator<IndexSet>

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias SubSequence = Slice<IndexSet>

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexSet : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexSet {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: IndexSet, rhs: IndexSet) -> Bool
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexSet : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension IndexSet : Sendable {
}

@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension IndexSet {

    public init?(integersIn indices: RangeSet<Int>)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexSet.RangeView {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: IndexSet.RangeView, rhs: IndexSet.RangeView) -> Bool
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension IndexSet.RangeView : Sendable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension IndexSet.Index {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func <= (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func > (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is greater than or equal to that of the second argument.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func >= (lhs: IndexSet.Index, rhs: IndexSet.Index) -> Bool
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public enum InflectionConcept : Sendable, Hashable, Equatable, Codable {

    /// List of preferred terms of address for a grammatical entity
    case termsOfAddress([TermOfAddress])

    /// A string phrase that affects the inflection of a string, but is not
    /// interpolated in it like replacements
    case localizedPhrase(String)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: InflectionConcept, b: InflectionConcept) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public enum InflectionRule : Sendable {

    case automatic

    case explicit(Morphology)

    public init(morphology: Morphology)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension InflectionRule : Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: InflectionRule, b: InflectionRule) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension InflectionRule : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension InflectionRule {

    public static func canInflect(language: String) -> Bool

    public static var canInflectPreferredLocalization: Bool { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct IntegerFormatStyle<Value> : Codable, Hashable, Sendable where Value : BinaryInteger {

    public typealias Configuration = NumberFormatStyleConfiguration

    public var locale: Locale

    public init(locale: Locale = .autoupdatingCurrent)

    public var attributed: IntegerFormatStyle<Value>.Attributed { get }

    public func grouping(_ group: IntegerFormatStyle<Value>.Configuration.Grouping) -> IntegerFormatStyle<Value>

    public func precision(_ p: IntegerFormatStyle<Value>.Configuration.Precision) -> IntegerFormatStyle<Value>

    public func sign(strategy: IntegerFormatStyle<Value>.Configuration.SignDisplayStrategy) -> IntegerFormatStyle<Value>

    public func decimalSeparator(strategy: IntegerFormatStyle<Value>.Configuration.DecimalSeparatorDisplayStrategy) -> IntegerFormatStyle<Value>

    public func rounded(rule: IntegerFormatStyle<Value>.Configuration.RoundingRule = .toNearestOrEven, increment: Int? = nil) -> IntegerFormatStyle<Value>

    public func scale(_ multiplicand: Double) -> IntegerFormatStyle<Value>

    public func notation(_ notation: IntegerFormatStyle<Value>.Configuration.Notation) -> IntegerFormatStyle<Value>

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: IntegerFormatStyle<Value>, b: IntegerFormatStyle<Value>) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle {

    public struct Percent : Codable, Hashable, Sendable {

        public typealias Configuration = NumberFormatStyleConfiguration

        public var locale: Locale

        public init(locale: Locale = .autoupdatingCurrent)

        public var attributed: IntegerFormatStyle<Value>.Attributed { get }

        public func grouping(_ group: IntegerFormatStyle<Value>.Percent.Configuration.Grouping) -> IntegerFormatStyle<Value>.Percent

        public func precision(_ p: IntegerFormatStyle<Value>.Percent.Configuration.Precision) -> IntegerFormatStyle<Value>.Percent

        public func sign(strategy: IntegerFormatStyle<Value>.Percent.Configuration.SignDisplayStrategy) -> IntegerFormatStyle<Value>.Percent

        public func decimalSeparator(strategy: IntegerFormatStyle<Value>.Percent.Configuration.DecimalSeparatorDisplayStrategy) -> IntegerFormatStyle<Value>.Percent

        public func rounded(rule: IntegerFormatStyle<Value>.Percent.Configuration.RoundingRule = .toNearestOrEven, increment: Int? = nil) -> IntegerFormatStyle<Value>.Percent

        public func scale(_ multiplicand: Double) -> IntegerFormatStyle<Value>.Percent

        public func notation(_ notation: IntegerFormatStyle<Value>.Percent.Configuration.Notation) -> IntegerFormatStyle<Value>.Percent

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: IntegerFormatStyle<Value>.Percent, b: IntegerFormatStyle<Value>.Percent) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public struct Currency : Codable, Hashable, Sendable {

        public typealias Configuration = CurrencyFormatStyleConfiguration

        public var locale: Locale

        public let currencyCode: String

        public init(code: String, locale: Locale = .autoupdatingCurrent)

        public var attributed: IntegerFormatStyle<Value>.Attributed { get }

        public func grouping(_ group: IntegerFormatStyle<Value>.Currency.Configuration.Grouping) -> IntegerFormatStyle<Value>.Currency

        public func precision(_ p: IntegerFormatStyle<Value>.Currency.Configuration.Precision) -> IntegerFormatStyle<Value>.Currency

        public func sign(strategy: IntegerFormatStyle<Value>.Currency.Configuration.SignDisplayStrategy) -> IntegerFormatStyle<Value>.Currency

        public func decimalSeparator(strategy: IntegerFormatStyle<Value>.Currency.Configuration.DecimalSeparatorDisplayStrategy) -> IntegerFormatStyle<Value>.Currency

        public func rounded(rule: IntegerFormatStyle<Value>.Currency.Configuration.RoundingRule = .toNearestOrEven, increment: Int? = nil) -> IntegerFormatStyle<Value>.Currency

        public func scale(_ multiplicand: Double) -> IntegerFormatStyle<Value>.Currency

        public func presentation(_ p: IntegerFormatStyle<Value>.Currency.Configuration.Presentation) -> IntegerFormatStyle<Value>.Currency

        /// Modifies the format style to use the specified notation.
        ///
        /// - Parameter notation: The notation to apply to the format style.
        /// - Returns: An integer currency format style modified to use the specified notation.
        @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
        public func notation(_ notation: IntegerFormatStyle<Value>.Currency.Configuration.Notation) -> IntegerFormatStyle<Value>.Currency

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: IntegerFormatStyle<Value>.Currency, b: IntegerFormatStyle<Value>.Currency) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle : FormatStyle {

    /// Returns a localized string for the given value. Supports up to 64-bit signed integer precision. Values not representable by `Int64` are clamped.
    /// - Parameter value: The value to be formatted.
    /// - Returns: A localized string for the given value.
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public func format(_ value: Value) -> String

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> IntegerFormatStyle<Value>

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Value

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: IntegerParseStrategy<IntegerFormatStyle<Value>> { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = IntegerParseStrategy<IntegerFormatStyle<Value>>
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle {

    public struct Attributed : Codable, Hashable, FormatStyle, Sendable {

        /// Returns an attributed string with `NumberFormatAttributes.SymbolAttribute` and `NumberFormatAttributes.NumberPartAttribute`. Values not representable by `Int64` are clamped.
        /// - Parameter value: The value to be formatted.
        /// - Returns: A localized attributed string for the given value.
        public func format(_ value: Value) -> AttributedString

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> IntegerFormatStyle<Value>.Attributed

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: IntegerFormatStyle<Value>.Attributed, b: IntegerFormatStyle<Value>.Attributed) -> Bool

        /// The type of data to format.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatInput = Value

        /// The type of the formatted data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatOutput = AttributedString

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension IntegerFormatStyle : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Value

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Value)?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle.Percent : FormatStyle {

    /// Returns a localized string for the given value in percentage. Supports up to 64-bit signed integer precision. Values not representable by `Int64` are clamped.
    /// - Parameter value: The value to be formatted.
    /// - Returns: A localized string for the given value in percentage.
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public func format(_ value: Value) -> String

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> IntegerFormatStyle<Value>.Percent

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Value

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle.Percent : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: IntegerParseStrategy<IntegerFormatStyle<Value>.Percent> { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = IntegerParseStrategy<IntegerFormatStyle<Value>.Percent>
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension IntegerFormatStyle.Percent : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Value

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Value)?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle.Currency : FormatStyle {

    /// Returns a localized currency string for the given value. Supports up to 64-bit signed integer precision. Values not representable by `Int64` are clamped.
    /// - Parameter value: The value to be formatted.
    /// - Returns: A localized currency string for the given value.
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public func format(_ value: Value) -> String

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> IntegerFormatStyle<Value>.Currency

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Value

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerFormatStyle.Currency : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: IntegerParseStrategy<IntegerFormatStyle<Value>.Currency> { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = IntegerParseStrategy<IntegerFormatStyle<Value>.Currency>
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension IntegerFormatStyle.Currency : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = Value

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: Value)?
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct IntegerParseStrategy<Format> : Codable, Hashable where Format : FormatStyle, Format.FormatInput : BinaryInteger {

    public var formatStyle: Format

    public var lenient: Bool

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: IntegerParseStrategy<Format>, b: IntegerParseStrategy<Format>) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy : Sendable where Format : Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy : ParseStrategy {

    /// Creates an instance of the `ParseOutput` type from `value`.
    public func parse(_ value: String) throws -> Format.FormatInput

    /// The type of the representation describing the data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseInput = String

    /// The type of the data type.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias ParseOutput = Format.FormatInput
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy {

    public init<Value>(format: Format, lenient: Bool = true) where Format == IntegerFormatStyle<Value>, Value : BinaryInteger
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy {

    public init<Value>(format: Format, lenient: Bool = true) where Format == IntegerFormatStyle<Value>.Percent, Value : BinaryInteger
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension IntegerParseStrategy {

    public init<Value>(format: Format, lenient: Bool = true) where Format == IntegerFormatStyle<Value>.Currency, Value : BinaryInteger
}

/// `JSONDecoder` facilitates the decoding of JSON into semantic `Decodable` types.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
open class JSONDecoder {

    /// The strategy to use for decoding `Date` values.
    public enum DateDecodingStrategy : Sendable {

        /// Defer to `Date` for decoding. This is the default strategy.
        case deferredToDate

        /// Decode the `Date` as a UNIX timestamp from a JSON number.
        case secondsSince1970

        /// Decode the `Date` as UNIX millisecond timestamp from a JSON number.
        case millisecondsSince1970

        /// Decode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).
        @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
        case iso8601

        /// Decode the `Date` as a string parsed by the given formatter.
        case formatted(DateFormatter)

        /// Decode the `Date` as a custom value decoded by the given closure.
        @preconcurrency case custom(@Sendable (_ decoder: any Decoder) throws -> Date)
    }

    /// The strategy to use for decoding `Data` values.
    public enum DataDecodingStrategy : Sendable {

        /// Defer to `Data` for decoding.
        case deferredToData

        /// Decode the `Data` from a Base64-encoded string. This is the default strategy.
        case base64

        /// Decode the `Data` as a custom value decoded by the given closure.
        @preconcurrency case custom(@Sendable (_ decoder: any Decoder) throws -> Data)
    }

    /// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN).
    public enum NonConformingFloatDecodingStrategy : Sendable {

        /// Throw upon encountering non-conforming values. This is the default strategy.
        case `throw`

        /// Decode the values from the given representation strings.
        case convertFromString(positiveInfinity: String, negativeInfinity: String, nan: String)
    }

    /// The strategy to use for automatically changing the value of keys before decoding.
    public enum KeyDecodingStrategy : Sendable {

        /// Use the keys specified by each type. This is the default strategy.
        case useDefaultKeys

        /// Convert from "snake_case_keys" to "camelCaseKeys" before attempting to match a key with the one specified by each type.
        ///
        /// The conversion to upper case uses `Locale.system`, also known as the ICU "root" locale. This means the result is consistent regardless of the current user's locale and language preferences.
        ///
        /// Converting from snake case to camel case:
        /// 1. Capitalizes the word starting after each `_`
        /// 2. Removes all `_`
        /// 3. Preserves starting and ending `_` (as these are often used to indicate private variables or other metadata).
        /// For example, `one_two_three` becomes `oneTwoThree`. `_one_two_three_` becomes `_oneTwoThree_`.
        ///
        /// - Note: Using a key decoding strategy has a nominal performance cost, as each string key has to be inspected for the `_` character.
        case convertFromSnakeCase

        /// Provide a custom conversion from the key in the encoded JSON to the keys specified by the decoded types.
        /// The full path to the current decoding position is provided for context (in case you need to locate this key within the payload). The returned key is used in place of the last component in the coding path before decoding.
        /// If the result of the conversion is a duplicate key, then only one value will be present in the container for the type to decode from.
        @preconcurrency case custom(@Sendable (_ codingPath: [any CodingKey]) -> any CodingKey)
    }

    /// The strategy to use in decoding dates. Defaults to `.deferredToDate`.
    open var dateDecodingStrategy: JSONDecoder.DateDecodingStrategy

    /// The strategy to use in decoding binary data. Defaults to `.base64`.
    open var dataDecodingStrategy: JSONDecoder.DataDecodingStrategy

    /// The strategy to use in decoding non-conforming numbers. Defaults to `.throw`.
    open var nonConformingFloatDecodingStrategy: JSONDecoder.NonConformingFloatDecodingStrategy

    /// The strategy to use for decoding keys. Defaults to `.useDefaultKeys`.
    open var keyDecodingStrategy: JSONDecoder.KeyDecodingStrategy

    /// Contextual user-provided information for use during decoding.
    @preconcurrency open var userInfo: [CodingUserInfoKey : any Sendable]

    /// Set to `true` to allow parsing of JSON5. Defaults to `false`.
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    open var allowsJSON5: Bool

    /// Set to `true` to assume the data is a top level Dictionary (no surrounding "{ }" required). Defaults to `false`. Compatible with both JSON5 and non-JSON5 mode.
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    open var assumesTopLevelDictionary: Bool

    /// Initializes `self` with default strategies.
    public init()

    /// Decodes a top-level value of the given type from the given JSON representation.
    ///
    /// - parameter type: The type of the value to decode.
    /// - parameter data: The data to decode from.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.dataCorrupted` if values requested from the payload are corrupted, or if the given data is not valid JSON.
    /// - throws: An error if any value throws an error during decoding.
    open func decode<T>(_ type: T.Type, from data: Data) throws -> T where T : Decodable

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func decode<T>(_ type: T.Type, from data: Data, configuration: T.DecodingConfiguration) throws -> T where T : DecodableWithConfiguration

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func decode<T, C>(_ type: T.Type, from data: Data, configuration: C.Type) throws -> T where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration

    @objc deinit
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension JSONDecoder : @unchecked Sendable {
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension JSONDecoder : TopLevelDecoder {

    /// The type this decoder accepts.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Input = Data
}

/// `JSONEncoder` facilitates the encoding of `Encodable` values into JSON.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
open class JSONEncoder {

    /// The formatting of the output JSON data.
    public struct OutputFormatting : OptionSet, Sendable {

        /// The format's default value.
        public let rawValue: UInt

        /// Creates an OutputFormatting value with the given raw value.
        public init(rawValue: UInt)

        /// Produce human-readable JSON with indented output.
        public static let prettyPrinted: JSONEncoder.OutputFormatting

        /// Produce JSON with dictionary keys sorted in lexicographic order.
        @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
        public static let sortedKeys: JSONEncoder.OutputFormatting

        /// By default slashes get escaped ("/" → "\/", "http://apple.com/" → "http:\/\/apple.com\/")
        /// for security reasons, allowing outputted JSON to be safely embedded within HTML/XML.
        /// In contexts where this escaping is unnecessary, the JSON is known to not be embedded,
        /// or is intended only for display, this option avoids this escaping.
        @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
        public static let withoutEscapingSlashes: JSONEncoder.OutputFormatting

        /// The type of the elements of an array literal.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias ArrayLiteralElement = JSONEncoder.OutputFormatting

        /// The element type of the option set.
        ///
        /// To inherit all the default implementations from the `OptionSet` protocol,
        /// the `Element` type must be `Self`, the default.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias Element = JSONEncoder.OutputFormatting

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias RawValue = UInt
    }

    /// The strategy to use for encoding `Date` values.
    public enum DateEncodingStrategy : Sendable {

        /// Defer to `Date` for choosing an encoding. This is the default strategy.
        case deferredToDate

        /// Encode the `Date` as a UNIX timestamp (as a JSON number).
        case secondsSince1970

        /// Encode the `Date` as UNIX millisecond timestamp (as a JSON number).
        case millisecondsSince1970

        /// Encode the `Date` as an ISO-8601-formatted string (in RFC 3339 format).
        @available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
        case iso8601

        /// Encode the `Date` as a string formatted by the given formatter.
        case formatted(DateFormatter)

        /// Encode the `Date` as a custom value encoded by the given closure.
        ///
        /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty automatic container in its place.
        @preconcurrency case custom(@Sendable (Date, any Encoder) throws -> Void)
    }

    /// The strategy to use for encoding `Data` values.
    public enum DataEncodingStrategy : Sendable {

        /// Defer to `Data` for choosing an encoding.
        case deferredToData

        /// Encoded the `Data` as a Base64-encoded string. This is the default strategy.
        case base64

        /// Encode the `Data` as a custom value encoded by the given closure.
        ///
        /// If the closure fails to encode a value into the given encoder, the encoder will encode an empty automatic container in its place.
        @preconcurrency case custom(@Sendable (Data, any Encoder) throws -> Void)
    }

    /// The strategy to use for non-JSON-conforming floating-point values (IEEE 754 infinity and NaN).
    public enum NonConformingFloatEncodingStrategy : Sendable {

        /// Throw upon encountering non-conforming values. This is the default strategy.
        case `throw`

        /// Encode the values using the given representation strings.
        case convertToString(positiveInfinity: String, negativeInfinity: String, nan: String)
    }

    /// The strategy to use for automatically changing the value of keys before encoding.
    public enum KeyEncodingStrategy : Sendable {

        /// Use the keys specified by each type. This is the default strategy.
        case useDefaultKeys

        /// Convert from "camelCaseKeys" to "snake_case_keys" before writing a key to JSON payload.
        ///
        /// Capital characters are determined by testing membership in Unicode General Categories Lu and Lt.
        /// The conversion to lower case uses `Locale.system`, also known as the ICU "root" locale. This means the result is consistent regardless of the current user's locale and language preferences.
        ///
        /// Converting from camel case to snake case:
        /// 1. Splits words at the boundary of lower-case to upper-case
        /// 2. Inserts `_` between words
        /// 3. Lowercases the entire string
        /// 4. Preserves starting and ending `_`.
        ///
        /// For example, `oneTwoThree` becomes `one_two_three`. `_oneTwoThree_` becomes `_one_two_three_`.
        ///
        /// - Note: Using a key encoding strategy has a nominal performance cost, as each string key has to be converted.
        case convertToSnakeCase

        /// Provide a custom conversion to the key in the encoded JSON from the keys specified by the encoded types.
        /// The full path to the current encoding position is provided for context (in case you need to locate this key within the payload). The returned key is used in place of the last component in the coding path before encoding.
        /// If the result of the conversion is a duplicate key, then only one value will be present in the result.
        @preconcurrency case custom(@Sendable (_ codingPath: [any CodingKey]) -> any CodingKey)
    }

    /// The output format to produce. Defaults to `[]`.
    open var outputFormatting: JSONEncoder.OutputFormatting

    /// The strategy to use in encoding dates. Defaults to `.deferredToDate`.
    open var dateEncodingStrategy: JSONEncoder.DateEncodingStrategy

    /// The strategy to use in encoding binary data. Defaults to `.base64`.
    open var dataEncodingStrategy: JSONEncoder.DataEncodingStrategy

    /// The strategy to use in encoding non-conforming numbers. Defaults to `.throw`.
    open var nonConformingFloatEncodingStrategy: JSONEncoder.NonConformingFloatEncodingStrategy

    /// The strategy to use for encoding keys. Defaults to `.useDefaultKeys`.
    open var keyEncodingStrategy: JSONEncoder.KeyEncodingStrategy

    /// Contextual user-provided information for use during encoding.
    @preconcurrency open var userInfo: [CodingUserInfoKey : any Sendable]

    /// Initializes `self` with default strategies.
    public init()

    /// Encodes the given top-level value and returns its JSON representation.
    ///
    /// - parameter value: The value to encode.
    /// - returns: A new `Data` value containing the encoded JSON data.
    /// - throws: `EncodingError.invalidValue` if a non-conforming floating-point value is encountered during encoding, and the encoding strategy is `.throw`.
    /// - throws: An error if any value throws an error during encoding.
    open func encode<T>(_ value: T) throws -> Data where T : Encodable

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func encode<T>(_ value: T, configuration: T.EncodingConfiguration) throws -> Data where T : EncodableWithConfiguration

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func encode<T, C>(_ value: T, configuration: C.Type) throws -> Data where T : EncodableWithConfiguration, C : EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration

    @objc deinit
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension JSONEncoder : @unchecked Sendable {
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension JSONEncoder : TopLevelEncoder {

    /// The type this encoder produces.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Output = Data
}

/// Compares elements using a `KeyPath`, and a `SortComparator` which compares
/// elements of the `KeyPath`s `Value` type.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct KeyPathComparator<Compared> : SortComparator {

    /// The key path to the property to be used for comparisons.
    @preconcurrency public let keyPath: any PartialKeyPath<Compared> & Sendable

    /// If the `SortComparator`s resulting order is forward or reverse.
    public var order: SortOrder

    public init<Value>(_ keyPath: any KeyPath<Compared, Value> & Sendable, order: SortOrder = .forward) where Value : Comparable

    public init<Value>(_ keyPath: any KeyPath<Compared, Value?> & Sendable, order: SortOrder = .forward) where Value : Comparable

    public init<Value, Comparator>(_ keyPath: any KeyPath<Compared, Value> & Sendable, comparator: Comparator) where Value == Comparator.Compared, Comparator : SortComparator

    public init<Value, Comparator>(_ keyPath: any KeyPath<Compared, Value?> & Sendable, comparator: Comparator) where Value == Comparator.Compared, Comparator : SortComparator

    public init<Value, Comparator>(_ keyPath: any KeyPath<Compared, Value> & Sendable, comparator: Comparator, order: SortOrder) where Value == Comparator.Compared, Comparator : SortComparator

    public init<Value, Comparator>(_ keyPath: any KeyPath<Compared, Value?> & Sendable, comparator: Comparator, order: SortOrder) where Value == Comparator.Compared, Comparator : SortComparator

    /// The relative ordering of lhs, and rhs.
    ///
    /// The result of comparisons should be flipped if the current `order`
    /// is `reverse`.
    ///
    /// If `compare(lhs, rhs)` is `.orderedAscending`, then `compare(rhs, lhs)`
    /// must be `.orderedDescending`. If `compare(lhs, rhs)` is
    /// `.orderedDescending`, then `compare(rhs, lhs)` must be
    /// `.orderedAscending`.
    ///
    /// - Parameters:
    ///     - lhs: A value to compare.
    ///     - rhs: A value to compare.
    public func compare(_ lhs: Compared, _ rhs: Compared) -> ComparisonResult

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: KeyPathComparator<Compared>, rhs: KeyPathComparator<Compared>) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct ListFormatStyle<Style, Base> : FormatStyle where Style : FormatStyle, Base : Sequence, Style.FormatInput == Base.Element, Style.FormatOutput == String {

    public var width: ListFormatStyle<Style, Base>.Width

    public var listType: ListFormatStyle<Style, Base>.ListType

    public var locale: Locale

    public init(memberStyle: Style)

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: Base) -> String

    public enum Width : Int, Codable, Sendable {

        case standard

        case short

        case narrow

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    public enum ListType : Int, Codable, Sendable {

        case and

        case or

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
    public func locale(_ locale: Locale) -> ListFormatStyle<Style, Base>

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: ListFormatStyle<Style, Base>, b: ListFormatStyle<Style, Base>) -> Bool

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = Base

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle : Sendable where Style : Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.Width : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.Width : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.Width : RawRepresentable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.ListType : Equatable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.ListType : Hashable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ListFormatStyle.ListType : RawRepresentable {
}

/**
 `Locale` encapsulates information about linguistic, cultural, and technological conventions and standards. Examples of information encapsulated by a locale include the symbol used for the decimal separator in numbers and the way dates are formatted.

 Locales are typically used to provide, format, and interpret information about and according to the user's customs and preferences. They are frequently used in conjunction with formatters. Although you can use many locales, you usually use the one associated with the current user.
*/
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct Locale : Hashable, Equatable, Sendable {

    public typealias LanguageDirection = NSLocale.LanguageDirection

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public enum IdentifierType : Sendable {

        /// Identifier following ICU (International Components for Unicode) convention. Unlike the `posix` type, does not include character set
        /// For example: "th_TH@calendar=gregorian;numbers=thai"
        case icu

        /// The identifier is also a valid BCP47 language tag
        /// For example: "th-TH-u-ca-gregory-nu-thai"
        case bcp47

        /// The components are the same as `icu`, but does not use the key-value type keyword list
        /// For example: "th_TH_u_ca_gregory_nu_thai"
        case cldr

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Locale.IdentifierType, b: Locale.IdentifierType) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Returns a locale which tracks the user's current preferences.
    ///
    /// If mutated, this Locale will no longer track the user's preferences.
    ///
    /// - note: The autoupdating Locale will only compare equal to another autoupdating Locale.
    public static var autoupdatingCurrent: Locale { get }

    /// Returns the user's current locale.
    public static var current: Locale { get }

    /// Return a locale with the specified identifier.
    public init(identifier: String)

    /// Creates a `Locale` with the specified locale components
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init(components: Locale.Components)

    /// Creates a `Locale` with the specified language components
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init(languageComponents: Locale.Language.Components)

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init(languageCode: Locale.LanguageCode? = nil, script: Locale.Script? = nil, languageRegion: Locale.Region? = nil)

    /// Returns a localized string for a specified identifier.
    ///
    /// For example, in the "en" locale, the result for `"es"` is `"Spanish"`.
    public func localizedString(forIdentifier identifier: String) -> String?

    /// Returns a localized string for a specified language code.
    ///
    /// For example, in the "en" locale, the result for `"es"` is `"Spanish"`.
    public func localizedString(forLanguageCode languageCode: String) -> String?

    /// Returns a localized string for a specified region code.
    ///
    /// For example, in the "en" locale, the result for `"fr"` is `"France"`.
    public func localizedString(forRegionCode regionCode: String) -> String?

    /// Returns a localized string for a specified script code.
    ///
    /// For example, in the "en" locale, the result for `"Hans"` is `"Simplified Han"`.
    public func localizedString(forScriptCode scriptCode: String) -> String?

    /// Returns a localized string for a specified variant code.
    ///
    /// For example, in the "en" locale, the result for `"POSIX"` is `"Computer"`.
    public func localizedString(forVariantCode variantCode: String) -> String?

    /// Returns a localized string for a specified `Calendar.Identifier`.
    ///
    /// For example, in the "en" locale, the result for `.buddhist` is `"Buddhist Calendar"`.
    public func localizedString(for calendarIdentifier: Calendar.Identifier) -> String?

    /// Returns a localized string for a specified ISO 4217 currency code.
    ///
    /// For example, in the "en" locale, the result for `"USD"` is `"US Dollar"`.
    /// - seealso: `Locale.isoCurrencyCodes`
    public func localizedString(forCurrencyCode currencyCode: String) -> String?

    /// Returns a localized string for a specified ICU collation identifier.
    ///
    /// For example, in the "en" locale, the result for `"phonebook"` is `"Phonebook Sort Order"`.
    public func localizedString(forCollationIdentifier collationIdentifier: String) -> String?

    /// Returns a localized string for a specified ICU collator identifier.
    public func localizedString(forCollatorIdentifier collatorIdentifier: String) -> String?

    /// Returns the identifier of the locale.
    public var identifier: String { get }

    /// Returns the language code of the locale, or nil if has none.
    ///
    /// For example, for the locale "zh-Hant-HK", returns "zh".
    @available(macOS, deprecated: 13, renamed: "language.languageCode.identifier")
    @available(iOS, deprecated: 16, renamed: "language.languageCode.identifier")
    @available(tvOS, deprecated: 16, renamed: "language.languageCode.identifier")
    @available(watchOS, deprecated: 9, renamed: "language.languageCode.identifier")
    public var languageCode: String? { get }

    /// Returns the region code of the locale, or nil if it has none.
    ///
    /// For example, for the locale "zh-Hant-HK", returns "HK".
    @available(macOS, deprecated: 13, renamed: "region.identifier")
    @available(iOS, deprecated: 16, renamed: "region.identifier")
    @available(tvOS, deprecated: 16, renamed: "region.identifier")
    @available(watchOS, deprecated: 9, renamed: "region.identifier")
    public var regionCode: String? { get }

    /// Returns the script code of the locale, or nil if has none.
    ///
    /// For example, for the locale "zh-Hant-HK", returns "Hant".
    @available(macOS, deprecated: 13, renamed: "language.script.identifier")
    @available(iOS, deprecated: 16, renamed: "language.script.identifier")
    @available(tvOS, deprecated: 16, renamed: "language.script.identifier")
    @available(watchOS, deprecated: 9, renamed: "language.script.identifier")
    public var scriptCode: String? { get }

    /// Returns the variant code for the locale, or nil if it has none.
    ///
    /// For example, for the locale "en_POSIX", returns "POSIX".
    @available(macOS, deprecated: 13, renamed: "variant.identifier")
    @available(iOS, deprecated: 16, renamed: "variant.identifier")
    @available(tvOS, deprecated: 16, renamed: "variant.identifier")
    @available(watchOS, deprecated: 9, renamed: "variant.identifier")
    public var variantCode: String? { get }

    /// Returns the exemplar character set for the locale, or nil if has none.
    public var exemplarCharacterSet: CharacterSet? { get }

    /// Returns the calendar for the locale, or the Gregorian calendar as a fallback.
    public var calendar: Calendar { get }

    /// Returns the collation identifier for the locale, or nil if it has none.
    ///
    /// For example, for the locale "en_US@collation=phonebook", returns "phonebook".
    @available(macOS, deprecated: 13, renamed: "collation.identifier")
    @available(iOS, deprecated: 16, renamed: "collation.identifier")
    @available(tvOS, deprecated: 16, renamed: "collation.identifier")
    @available(watchOS, deprecated: 9, renamed: "collation.identifier")
    public var collationIdentifier: String? { get }

    /// Returns true if the locale uses the metric system.
    ///
    /// -seealso: MeasurementFormatter
    @available(macOS, deprecated: 13, message: "Use `measurementSystem` instead")
    @available(iOS, deprecated: 16, message: "Use `measurementSystem` instead")
    @available(tvOS, deprecated: 16, message: "Use `measurementSystem` instead")
    @available(watchOS, deprecated: 9, message: "Use `measurementSystem` instead")
    public var usesMetricSystem: Bool { get }

    /// Returns the decimal separator of the locale.
    ///
    /// For example, for "en_US", returns ".".
    public var decimalSeparator: String? { get }

    /// Returns the grouping separator of the locale.
    ///
    /// For example, for "en_US", returns ",".
    public var groupingSeparator: String? { get }

    /// Returns the currency symbol of the locale.
    ///
    /// For example, for "zh-Hant-HK", returns "HK$".
    public var currencySymbol: String? { get }

    /// Returns the currency code of the locale.
    ///
    /// For example, for "zh-Hant-HK", returns "HKD".
    @available(macOS, deprecated: 13, renamed: "currency.identifier")
    @available(iOS, deprecated: 16, renamed: "currency.identifier")
    @available(tvOS, deprecated: 16, renamed: "currency.identifier")
    @available(watchOS, deprecated: 9, renamed: "currency.identifier")
    public var currencyCode: String? { get }

    /// Returns the collator identifier of the locale.
    public var collatorIdentifier: String? { get }

    /// Returns the quotation begin delimiter of the locale.
    ///
    /// For example, returns `“` for "en_US", and `「` for "zh-Hant-HK".
    public var quotationBeginDelimiter: String? { get }

    /// Returns the quotation end delimiter of the locale.
    ///
    /// For example, returns `”` for "en_US", and `」` for "zh-Hant-HK".
    public var quotationEndDelimiter: String? { get }

    /// Returns the alternate quotation begin delimiter of the locale.
    ///
    /// For example, returns `‘` for "en_US", and `『` for "zh-Hant-HK".
    public var alternateQuotationBeginDelimiter: String? { get }

    /// Returns the alternate quotation end delimiter of the locale.
    ///
    /// For example, returns `’` for "en_US", and `』` for "zh-Hant-HK".
    public var alternateQuotationEndDelimiter: String? { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var measurementSystem: Locale.MeasurementSystem { get }

    /// Returns the currency of the locale. Returns nil if the data isn't available.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var currency: Locale.Currency? { get }

    /// Returns the numbering system of the locale. If the locale has an explicitly specified numbering system in the identifier (e.g. `bn_BD@numbers=latn`) or in the associated `Locale.Components`, that numbering system is returned. Otherwise, returns the default numbering system of the locale. Returns `"latn"` as the default value if the data isn't available.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var numberingSystem: Locale.NumberingSystem { get }

    /// Returns all the valid numbering systems for the locale. For example, `"ar-AE (Arabic (United Arab Emirates)"` has both `"latn" (Latin digits)` and `"arab" (Arabic-Indic digits)` numbering system.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var availableNumberingSystems: [Locale.NumberingSystem] { get }

    /// Returns the first day of the week of the locale. Returns `.sunday` as the default value if the data isn't available to the requested locale.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var firstDayOfWeek: Locale.Weekday { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var language: Locale.Language { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public func identifier(_ type: Locale.IdentifierType) -> String

    /// Returns the hour cycle such as whether it uses 12-hour clock or 24-hour clock. Default is `.zeroToTwentyThree` if the data isn't available.
    /// Calling this on `.current` or `.autoupdatingCurrent` returns user's preference values as set in the system settings if available, overriding the default value of the user's locale.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var hourCycle: Locale.HourCycle { get }

    /// Returns the default collation used by the locale. Default is `.standard`.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var collation: Locale.Collation { get }

    /// Returns the region of the locale. For example, "US" for "en_US", "GB" for "en_GB", "PT" for "pt_PT".
    ///
    ///
    /// note: Typically this is equivalent to the language region, unless there's an `rg` override in the locale identifier. For example, for "en_GB@rg=USzzzz", the language region is "GB", while the locale region is "US". `Language.region` represents the region variant of the language, such as "British English" in this example, while `Locale.region` controls the region-specific default values, such as measuring system and first day of the week.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var region: Locale.Region? { get }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var timeZone: TimeZone? { get }

    /// Returns the regional subdivision for the locale, or nil if there is none.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var subdivision: Locale.Subdivision? { get }

    /// Returns the variant for the locale, or nil if it has none. For example, for the locale "en_POSIX", returns "POSIX".
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public var variant: Locale.Variant? { get }

    /// Returns a list of the user's preferred languages, as specified in Language & Region settings, taking into account any per-app language overrides.
    ///
    /// - note: `Bundle` is responsible for determining the language that your application will run in, based on the result of this API and combined with the languages your application supports.
    /// - seealso: `Bundle.preferredLocalizations(from:)`
    /// - seealso: `Bundle.preferredLocalizations(from:forPreferences:)`
    /// - seealso: `Locale.preferredLocales`
    public static var preferredLanguages: [String] { get }

    /// Returns a list of the user’s preferred locales, as specified in Language & Region settings, taking into account any per-app language overrides.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public static var preferredLocales: [Locale] { get }

    /// Constructs an identifier from a dictionary of components.
    public static func identifier(fromComponents components: [String : String]) -> String

    /// Returns a canonical identifier from the given string.
    @available(macOS, deprecated: 13, renamed: "identifier(_:from:)")
    @available(iOS, deprecated: 16, renamed: "identifier(_:from:)")
    @available(tvOS, deprecated: 16, renamed: "identifier(_:from:)")
    @available(watchOS, deprecated: 9, renamed: "identifier(_:from:)")
    public static func canonicalIdentifier(from string: String) -> String

    /// Returns a canonical language identifier from the given string.
    public static func canonicalLanguageIdentifier(from string: String) -> String

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Locale, rhs: Locale) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Locale {

    /// Returns the `Locale` identifier from a given Windows locale code, or nil if it could not be converted.
    public static func identifier(fromWindowsLocaleCode code: Int) -> String?

    /// Returns the Windows locale code from a given identifier, or nil if it could not be converted.
    public static func windowsLocaleCode(fromIdentifier identifier: String) -> Int?

    /// Returns the identifier conforming to the specified standard for the specified string.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public static func identifier(_ type: Locale.IdentifierType, from string: String) -> String

    /// Returns a list of available `Locale` identifiers.
    public static var availableIdentifiers: [String] { get }

    /// Returns a list of common `Locale` currency codes.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public static var commonISOCurrencyCodes: [String] { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Locale : ReferenceConvertible {

    public typealias ReferenceType = NSLocale
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Locale {

    /// Returns a list of available `Locale` language codes.
    @available(macOS, deprecated: 13, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
    @available(iOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
    @available(tvOS, deprecated: 16, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
    @available(watchOS, deprecated: 9, message: "Use `Locale.LanguageCode.isoLanguageCodes` instead")
    public static var isoLanguageCodes: [String] { get }

    /// Returns a dictionary that splits an identifier into its component pieces.
    @available(macOS, deprecated: 13, message: "Use `Locale.Components(identifier:)` to access components")
    @available(iOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Components(identifier:)` to access components")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Components(identifier:)` to access components")
    public static func components(fromIdentifier string: String) -> [String : String]

    /// Returns a list of available `Locale` region codes.
    @available(macOS, deprecated: 13, message: "Use `Locale.Region.isoRegions` instead")
    @available(iOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Region.isoRegions` instead")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Region.isoRegions` instead")
    public static var isoRegionCodes: [String] { get }

    /// Returns a list of available `Locale` currency codes.
    @available(macOS, deprecated: 13, message: "Use `Locale.Currency.isoCurrencies` instead")
    @available(iOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Currency.isoCurrencies` instead")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Currency.isoCurrencies` instead")
    public static var isoCurrencyCodes: [String] { get }

    /// Returns the character direction for a specified language code.
    @available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).characterDirection`")
    @available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).characterDirection`")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).characterDirection`")
    public static func characterDirection(forLanguage isoLangCode: String) -> Locale.LanguageDirection

    /// Returns the line direction for a specified language code.
    @available(macOS, deprecated: 13, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
    @available(iOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
    @available(tvOS, deprecated: 16, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
    @available(watchOS, deprecated: 9, message: "Use `Locale.Language(identifier:).lineLayoutDirection`")
    public static func lineDirection(forLanguage isoLangCode: String) -> Locale.LanguageDirection
}

extension Locale {

    /// Represents locale-related attributes. You can use `Locale.Components` to create a `Locale` with specific overrides.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Components : Hashable, Codable, Sendable {

        /// Represents the language identifier a locale
        public var languageComponents: Locale.Language.Components

        /// Set this to override the default calendar. To request the default calendar used by the locale, use `Locale.calendar`
        ///
        /// Corresponds to the "ca" key of the Unicode BCP 47 extension
        public var calendar: Calendar.Identifier?

        /// Set this to override the string sort order. To request the default calendar used by the locale, use `Locale.calendar`
        ///
        /// Corresponds to the "co" key of the Unicode BCP 47 extension
        public var collation: Locale.Collation?

        /// Set this to override the currency. To request the default currency used by the locale, use `Locale.currency`
        ///
        /// Corresponds to the "cu" key of the Unicode BCP 47 extension
        public var currency: Locale.Currency?

        /// Set this to override the numbering system. To request the default numbering system used by the locale, use `Locale.numberingSystem`
        ///
        /// Corresponds to the "nu" key of the Unicode BCP 47 extension
        public var numberingSystem: Locale.NumberingSystem?

        /// Set this to override the first day of the week. To request the default first day of the week preferred by the locale, use `Locale.firstDayOfWeek`
        ///
        /// Corresponds to the "fw" key of the Unicode BCP 47 extension
        /// The preferred first day of the week that should be shown in a calendar view. Not necessarily the same as the first day after the weekend, and should not be determined from the weekend information
        public var firstDayOfWeek: Locale.Weekday?

        /// Set this to override the hour cycle. To request the default hour cycle, use `Locale.hourCycle`
        ///
        /// Corresponds to the "hc" key
        public var hourCycle: Locale.HourCycle?

        /// Set this to override the measurement system. To request the default measurement system, use `Locale.measurementSystem`
        ///
        /// Corresponds to the "ms" key of the Unicode BCP 47 extension
        public var measurementSystem: Locale.MeasurementSystem?

        /// Set this to override the region for region-related preferences, such as measuring system, calendar, and first day of the week. If unset, the region of the language component is used
        ///
        /// Corresponds to the "rg" key of the Unicode BCP 47 extension
        public var region: Locale.Region?

        /// Set this to override the regional subdivision of `region`
        ///
        /// Corresponds to the "sd" key of the Unicode BCP 47 extension
        public var subdivision: Locale.Subdivision?

        /// Set this to specify a time zone to associate with this locale
        ///
        /// Corresponds to the "tz" key of the Unicode BCP 47 extension
        public var timeZone: TimeZone?

        /// Set this to specify a variant used for the locale
        ///
        /// Corresponds to the "va" key of the Unicode BCP 47 extension
        public var variant: Locale.Variant?

        /// Creates a `Locale.Components` with the specified language code, script and region for the language
        public init(languageCode: Locale.LanguageCode? = nil, script: Locale.Script? = nil, languageRegion: Locale.Region? = nil)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Locale.Components, b: Locale.Components) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

extension Locale {

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct LanguageCode : Hashable, Codable, Sendable, ExpressibleByStringLiteral {

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        /// Creates a `LanguageCode` type
        /// - Parameter identifier: A two-letter or three-letter ISO 639 code, or a language code of your choice if using a custom language, such as "en" for English. Case-insensitive.
        public init(_ identifier: String)

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var debugDescription: String { get }

        /// A two-letter or three-letter code supported by ISO 639, or a language code of your choice if using a custom language.
        public var identifier: String

        /// Types of ISO 639 language code.
        public enum IdentifierType : Sendable {

            /// Two-letter alpha-2 code, e.g. "en" for English
            case alpha2

            /// Three-letter alpha-3 code, e.g. "eng" for English
            case alpha3

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Locale.LanguageCode.IdentifierType, b: Locale.LanguageCode.IdentifierType) -> Bool

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// The `und` code: used in cases where the language has not been identified
        public static let unidentified: Locale.LanguageCode

        /// The `mis` code: represents languages that have not been included in the ISO standard yet
        public static let uncoded: Locale.LanguageCode

        /// The `mul` code: represents the language of some content when there are more than one languages
        public static let multiple: Locale.LanguageCode

        /// The `zxx` code: used in cases when the content is not in any particular languages, such as images, symbols, etc.
        public static let unavailable: Locale.LanguageCode

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Locale.LanguageCode, rhs: Locale.LanguageCode) -> Bool

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias UnicodeScalarLiteralType = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Script : Hashable, Codable, Sendable, ExpressibleByStringLiteral {

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        public var identifier: String

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var debugDescription: String { get }

        /// Creates a `Script` with specified identifier
        /// - Parameter identifier: A BCP 47 script subtag such as "Arab", "Cyrl" or "Latn". Case-insensitive.
        public init(_ identifier: String)

        /// Represents an uncoded script
        public static let unknown: Locale.Script

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Locale.Script, rhs: Locale.Script) -> Bool

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias UnicodeScalarLiteralType = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Region : Hashable, Codable, Sendable, ExpressibleByStringLiteral {

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var debugDescription: String { get }

        public var identifier: String

        /// Creates a `Region` with the specified region code
        /// - Parameter identifier: A two-letter BCP 47 region subtag such as "US" for the United States. Case-insensitive.
        public init(_ identifier: String)

        /// Represents an unknown or invalid region
        public static let unknown: Locale.Region

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Locale.Region, rhs: Locale.Region) -> Bool

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias UnicodeScalarLiteralType = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Collation : Hashable, Codable, Sendable, ExpressibleByStringLiteral {

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        public var identifier: String

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var debugDescription: String { get }

        /// The complete list of collation identifiers can be found [here](https://github.com/unicode-org/cldr/blob/latest/common/bcp47/collation.xml), under the key named "co"
        public init(_ identifier: String)

        /// Dedicated for string search. This is only appropriate for determining whether two strings should be considered equivalent. Using this may ignore or modify the string for searching purpose. For example, the contractions in Thai and Lao are suppressed. It should not be used to determine the relative order of the two strings.
        public static let searchRules: Locale.Collation

        /// The default ordering for each language
        public static let standard: Locale.Collation

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Locale.Collation, rhs: Locale.Collation) -> Bool

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias UnicodeScalarLiteralType = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Currency : Hashable, Codable, Sendable, ExpressibleByStringLiteral {

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        public var identifier: String

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var debugDescription: String { get }

        public init(_ identifier: String)

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Locale.Currency, rhs: Locale.Currency) -> Bool

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias UnicodeScalarLiteralType = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct NumberingSystem : Hashable, Codable, Sendable, ExpressibleByStringLiteral {

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        public var identifier: String

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var debugDescription: String { get }

        /// The complete list of valid numbering systems can be found [here](https://github.com/unicode-org/cldr/blob/latest/common/bcp47/number.xml), under the key with the name "nu"
        public init(_ identifier: String)

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Locale.NumberingSystem, rhs: Locale.NumberingSystem) -> Bool

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias UnicodeScalarLiteralType = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public enum Weekday : String, Codable, Hashable, Sendable {

        case sunday

        case monday

        case tuesday

        case wednesday

        case thursday

        case friday

        case saturday

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias RawValue = String

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public enum HourCycle : String, Codable, Hashable, Sendable {

        /// 12-hour clock. Hour ranges from 0 to 11
        case zeroToEleven

        /// 12-hour clock. Hour ranges from 1 to 12
        case oneToTwelve

        /// 24-hour clock. Hour ranges from 0 to 23
        case zeroToTwentyThree

        /// 24-hour clock. Hour ranges from 1 to 24
        case oneToTwentyFour

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: String)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias RawValue = String

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: String { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct MeasurementSystem : Codable, Hashable, Sendable, ExpressibleByStringLiteral {

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        public var identifier: String

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var debugDescription: String { get }

        /// The complete list of valid measurement systems can be found [here](https://github.com/unicode-org/cldr/blob/latest/common/bcp47/measure.xml), under the key with the name "ms"
        public init(_ identifier: String)

        /// Metric system
        public static let metric: Locale.MeasurementSystem

        /// US System of measurement: feet, pints, etc.; pints are 16oz
        public static let us: Locale.MeasurementSystem

        /// UK System of measurement: feet, pints, etc.; pints are 20oz
        public static let uk: Locale.MeasurementSystem

        /// Returns a list of measurement systems
        public static var measurementSystems: [Locale.MeasurementSystem] { get }

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Locale.MeasurementSystem, rhs: Locale.MeasurementSystem) -> Bool

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias UnicodeScalarLiteralType = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Subdivision : Hashable, Codable, Sendable, ExpressibleByStringLiteral {

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        public var identifier: String

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var debugDescription: String { get }

        /// Creates a subdivision with the given identifier
        /// - Parameter identifier: A unicode subdivision identifier, such as "usca" for California, US. Case-insensitive. The complete list of subdivision identifier can be found [here](https://github.com/unicode-org/cldr/blob/maint/maint-40/common/validity/subdivision.xml), under the "subdivision" type
        public init(_ identifier: String)

        /// Returns the subdivision representing the given region as a whole. For example, returns a subdivision with the "uszzzz" identifier for the entire US region
        public static func subdivision(for region: Locale.Region) -> Locale.Subdivision

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Locale.Subdivision, rhs: Locale.Subdivision) -> Bool

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias UnicodeScalarLiteralType = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Variant : Codable, Hashable, Sendable, ExpressibleByStringLiteral {

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        public var identifier: String

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
        public var debugDescription: String { get }

        /// The complete list of valid variants can be found [here](https://github.com/unicode-org/cldr/blob/latest/common/bcp47/variant.xml), under the key named "va"
        public init(_ identifier: String)

        public static let posix: Locale.Variant

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: Locale.Variant, rhs: Locale.Variant) -> Bool

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
        public typealias UnicodeScalarLiteralType = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension Locale {

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct Language : Hashable, Codable, Sendable {

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        public struct Components : Hashable, Codable, Sendable {

            public var languageCode: Locale.LanguageCode?

            public var script: Locale.Script?

            public var region: Locale.Region?

            public init(languageCode: Locale.LanguageCode? = nil, script: Locale.Script? = nil, region: Locale.Region? = nil)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Locale.Language.Components, b: Locale.Language.Components) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        public init(components: Locale.Language.Components)

        public init(languageCode: Locale.LanguageCode? = nil, script: Locale.Script? = nil, region: Locale.Region? = nil)

        /// Returns a list of system languages, includes the languages of all product localization for the current platform
        public static var systemLanguages: [Locale.Language] { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Locale.Language, b: Locale.Language) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Locale : CustomDebugStringConvertible, CustomStringConvertible, CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Locale : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Locale {

    public struct CurrentLocaleDidChangeMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = Locale

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> Locale.CurrentLocaleDidChangeMessage?
    }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.IdentifierType : Equatable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.IdentifierType : Hashable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Components {

    /// - Parameter identifier: Unicode language identifier such as "en-u-nu-thai-ca-buddhist-kk-true"
    public init(identifier: String)

    /// Creates a `Locale.Components` with the identifier of the specified `locale`.
    /// - Parameter locale: The locale whose identifier is used to create the component. If `Locale.current` or `Locale.autoupdatingCurrent` is specified, the created `Locale.Components` will contain user's preferred values as set in the system settings if available.
    public init(locale: Locale)
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.LanguageCode {

    /// Returns the ISO code of the given identifier type.
    /// Returns nil if the language isn't a valid ISO language,
    /// or if the specified identifier type isn't available to
    /// the language.
    public func identifier(_ type: Locale.LanguageCode.IdentifierType) -> String?

    /// Returns if the language is an ISO-639 language
    public var isISOLanguage: Bool { get }

    /// Returns a list of `Locale` language codes that are two-letter language codes defined in ISO 639 and two-letter codes without a two-letter equivalent
    public static var isoLanguageCodes: [Locale.LanguageCode] { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Locale.LanguageCode : CustomDebugStringConvertible {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.LanguageCode {

    public static var ainu: Locale.LanguageCode { get }

    public static var albanian: Locale.LanguageCode { get }

    public static var amharic: Locale.LanguageCode { get }

    public static var apacheWestern: Locale.LanguageCode { get }

    public static var arabic: Locale.LanguageCode { get }

    public static var armenian: Locale.LanguageCode { get }

    public static var assamese: Locale.LanguageCode { get }

    public static var assyrian: Locale.LanguageCode { get }

    public static var azerbaijani: Locale.LanguageCode { get }

    public static var bangla: Locale.LanguageCode { get }

    public static var belarusian: Locale.LanguageCode { get }

    public static var bodo: Locale.LanguageCode { get }

    public static var bulgarian: Locale.LanguageCode { get }

    public static var burmese: Locale.LanguageCode { get }

    public static var cantonese: Locale.LanguageCode { get }

    public static var catalan: Locale.LanguageCode { get }

    public static var cherokee: Locale.LanguageCode { get }

    public static var chinese: Locale.LanguageCode { get }

    public static var croatian: Locale.LanguageCode { get }

    public static var czech: Locale.LanguageCode { get }

    public static var danish: Locale.LanguageCode { get }

    public static var dhivehi: Locale.LanguageCode { get }

    public static var dogri: Locale.LanguageCode { get }

    public static var dutch: Locale.LanguageCode { get }

    public static var dzongkha: Locale.LanguageCode { get }

    public static var english: Locale.LanguageCode { get }

    public static var estonian: Locale.LanguageCode { get }

    public static var faroese: Locale.LanguageCode { get }

    public static var finnish: Locale.LanguageCode { get }

    public static var french: Locale.LanguageCode { get }

    public static var fula: Locale.LanguageCode { get }

    public static var georgian: Locale.LanguageCode { get }

    public static var german: Locale.LanguageCode { get }

    public static var greek: Locale.LanguageCode { get }

    public static var gujarati: Locale.LanguageCode { get }

    public static var hawaiian: Locale.LanguageCode { get }

    public static var hebrew: Locale.LanguageCode { get }

    public static var hindi: Locale.LanguageCode { get }

    public static var hungarian: Locale.LanguageCode { get }

    public static var icelandic: Locale.LanguageCode { get }

    public static var igbo: Locale.LanguageCode { get }

    public static var indonesian: Locale.LanguageCode { get }

    public static var irish: Locale.LanguageCode { get }

    public static var italian: Locale.LanguageCode { get }

    public static var japanese: Locale.LanguageCode { get }

    public static var kannada: Locale.LanguageCode { get }

    public static var kashmiri: Locale.LanguageCode { get }

    public static var kazakh: Locale.LanguageCode { get }

    public static var khmer: Locale.LanguageCode { get }

    public static var konkani: Locale.LanguageCode { get }

    public static var korean: Locale.LanguageCode { get }

    public static var kurdish: Locale.LanguageCode { get }

    public static var kurdishSorani: Locale.LanguageCode { get }

    public static var kyrgyz: Locale.LanguageCode { get }

    public static var lao: Locale.LanguageCode { get }

    public static var latvian: Locale.LanguageCode { get }

    public static var lithuanian: Locale.LanguageCode { get }

    public static var macedonian: Locale.LanguageCode { get }

    public static var maithili: Locale.LanguageCode { get }

    public static var malay: Locale.LanguageCode { get }

    public static var malayalam: Locale.LanguageCode { get }

    public static var maltese: Locale.LanguageCode { get }

    public static var manipuri: Locale.LanguageCode { get }

    public static var māori: Locale.LanguageCode { get }

    public static var marathi: Locale.LanguageCode { get }

    public static var mongolian: Locale.LanguageCode { get }

    public static var navajo: Locale.LanguageCode { get }

    public static var nepali: Locale.LanguageCode { get }

    public static var norwegian: Locale.LanguageCode { get }

    public static var norwegianBokmål: Locale.LanguageCode { get }

    public static var norwegianNynorsk: Locale.LanguageCode { get }

    public static var odia: Locale.LanguageCode { get }

    public static var pashto: Locale.LanguageCode { get }

    public static var persian: Locale.LanguageCode { get }

    public static var polish: Locale.LanguageCode { get }

    public static var portuguese: Locale.LanguageCode { get }

    public static var punjabi: Locale.LanguageCode { get }

    public static var rohingya: Locale.LanguageCode { get }

    public static var romanian: Locale.LanguageCode { get }

    public static var russian: Locale.LanguageCode { get }

    public static var samoan: Locale.LanguageCode { get }

    public static var sanskrit: Locale.LanguageCode { get }

    public static var santali: Locale.LanguageCode { get }

    public static var serbian: Locale.LanguageCode { get }

    public static var sindhi: Locale.LanguageCode { get }

    public static var sinhala: Locale.LanguageCode { get }

    public static var slovak: Locale.LanguageCode { get }

    public static var slovenian: Locale.LanguageCode { get }

    public static var spanish: Locale.LanguageCode { get }

    public static var swahili: Locale.LanguageCode { get }

    public static var swedish: Locale.LanguageCode { get }

    public static var tagalog: Locale.LanguageCode { get }

    public static var tajik: Locale.LanguageCode { get }

    public static var tamil: Locale.LanguageCode { get }

    public static var telugu: Locale.LanguageCode { get }

    public static var thai: Locale.LanguageCode { get }

    public static var tibetan: Locale.LanguageCode { get }

    public static var tongan: Locale.LanguageCode { get }

    public static var turkish: Locale.LanguageCode { get }

    public static var turkmen: Locale.LanguageCode { get }

    public static var ukrainian: Locale.LanguageCode { get }

    public static var urdu: Locale.LanguageCode { get }

    public static var uyghur: Locale.LanguageCode { get }

    public static var uzbek: Locale.LanguageCode { get }

    public static var vietnamese: Locale.LanguageCode { get }

    public static var welsh: Locale.LanguageCode { get }

    public static var yiddish: Locale.LanguageCode { get }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Script {

    /// Returns if the script is an ISO 15924 script
    public var isISOScript: Bool { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Locale.Script : CustomDebugStringConvertible {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Script {

    public static var adlam: Locale.Script { get }

    public static var arabic: Locale.Script { get }

    public static var arabicNastaliq: Locale.Script { get }

    public static var armenian: Locale.Script { get }

    public static var bangla: Locale.Script { get }

    public static var cherokee: Locale.Script { get }

    public static var cyrillic: Locale.Script { get }

    public static var devanagari: Locale.Script { get }

    public static var ethiopic: Locale.Script { get }

    public static var georgian: Locale.Script { get }

    public static var greek: Locale.Script { get }

    public static var gujarati: Locale.Script { get }

    public static var gurmukhi: Locale.Script { get }

    public static var hanifiRohingya: Locale.Script { get }

    public static var hanSimplified: Locale.Script { get }

    public static var hanTraditional: Locale.Script { get }

    public static var hebrew: Locale.Script { get }

    public static var hiragana: Locale.Script { get }

    public static var japanese: Locale.Script { get }

    public static var kannada: Locale.Script { get }

    public static var katakana: Locale.Script { get }

    public static var khmer: Locale.Script { get }

    public static var korean: Locale.Script { get }

    public static var lao: Locale.Script { get }

    public static var latin: Locale.Script { get }

    public static var malayalam: Locale.Script { get }

    public static var meiteiMayek: Locale.Script { get }

    public static var myanmar: Locale.Script { get }

    public static var odia: Locale.Script { get }

    public static var olChiki: Locale.Script { get }

    public static var sinhala: Locale.Script { get }

    public static var syriac: Locale.Script { get }

    public static var tamil: Locale.Script { get }

    public static var telugu: Locale.Script { get }

    public static var thaana: Locale.Script { get }

    public static var thai: Locale.Script { get }

    public static var tibetan: Locale.Script { get }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Region {

    public var isISORegion: Bool { get }

    /// Returns all the sub-regions of the region
    public var subRegions: [Locale.Region] { get }

    /// Returns the region within which the region is contained, e.g. for `US`, returns `Northern America`
    public var containingRegion: Locale.Region? { get }

    /// Returns the continent of the region. Returns `nil` if the continent cannot be determined, such as when the region isn't an ISO region
    public var continent: Locale.Region? { get }

    /// Returns a list of regions of a specified type defined by ISO
    public static var isoRegions: [Locale.Region] { get }

    /// Categories of a region. See https://www.unicode.org/reports/tr35/tr35-35/tr35-info.html#Territory_Data
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public struct Category : Codable, Sendable, Hashable, CustomDebugStringConvertible {

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }

        /// Category representing the whold world.
        public static let world: Locale.Region.Category

        /// Category representing a continent, regions contained directly by world.
        public static let continent: Locale.Region.Category

        /// Category representing a sub-continent, regions contained directly by a continent.
        public static let subcontinent: Locale.Region.Category

        /// Category representing a territory.
        public static let territory: Locale.Region.Category

        /// Category representing a grouping, regions that has a well defined membership.
        public static let grouping: Locale.Region.Category

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Locale.Region.Category, b: Locale.Region.Category) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// An array of regions matching the specified categories.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public static func isoRegions(ofCategory category: Locale.Region.Category) -> [Locale.Region]

    /// The category of the region.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public var category: Locale.Region.Category? { get }

    /// An array of the sub-regions, matching the specified category of the region.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public func subRegions(ofCategoy category: Locale.Region.Category) -> [Locale.Region]

    /// The subcontinent that contains this region, if any.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public var subcontinent: Locale.Region? { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Locale.Region : CustomDebugStringConvertible {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Region {

    public static var afghanistan: Locale.Region { get }

    public static var ålandIslands: Locale.Region { get }

    public static var albania: Locale.Region { get }

    public static var algeria: Locale.Region { get }

    public static var americanSamoa: Locale.Region { get }

    public static var andorra: Locale.Region { get }

    public static var angola: Locale.Region { get }

    public static var anguilla: Locale.Region { get }

    public static var antarctica: Locale.Region { get }

    public static var antiguaBarbuda: Locale.Region { get }

    public static var argentina: Locale.Region { get }

    public static var armenia: Locale.Region { get }

    public static var aruba: Locale.Region { get }

    public static var ascensionIsland: Locale.Region { get }

    public static var australia: Locale.Region { get }

    public static var austria: Locale.Region { get }

    public static var azerbaijan: Locale.Region { get }

    public static var bahamas: Locale.Region { get }

    public static var bahrain: Locale.Region { get }

    public static var bangladesh: Locale.Region { get }

    public static var barbados: Locale.Region { get }

    public static var belarus: Locale.Region { get }

    public static var belgium: Locale.Region { get }

    public static var belize: Locale.Region { get }

    public static var benin: Locale.Region { get }

    public static var bermuda: Locale.Region { get }

    public static var bhutan: Locale.Region { get }

    public static var bolivia: Locale.Region { get }

    public static var bosniaHerzegovina: Locale.Region { get }

    public static var botswana: Locale.Region { get }

    public static var bouvetIsland: Locale.Region { get }

    public static var brazil: Locale.Region { get }

    public static var britishVirginIslands: Locale.Region { get }

    public static var brunei: Locale.Region { get }

    public static var bulgaria: Locale.Region { get }

    public static var burkinaFaso: Locale.Region { get }

    public static var burundi: Locale.Region { get }

    public static var cambodia: Locale.Region { get }

    public static var cameroon: Locale.Region { get }

    public static var canada: Locale.Region { get }

    public static var canaryIslands: Locale.Region { get }

    public static var capeVerde: Locale.Region { get }

    public static var caribbeanNetherlands: Locale.Region { get }

    public static var caymanIslands: Locale.Region { get }

    public static var centralAfricanRepublic: Locale.Region { get }

    public static var ceutaMelilla: Locale.Region { get }

    public static var chad: Locale.Region { get }

    public static var chagosArchipelago: Locale.Region { get }

    public static var chile: Locale.Region { get }

    public static var chinaMainland: Locale.Region { get }

    public static var christmasIsland: Locale.Region { get }

    public static var clippertonIsland: Locale.Region { get }

    public static var cocosIslands: Locale.Region { get }

    public static var colombia: Locale.Region { get }

    public static var comoros: Locale.Region { get }

    public static var congoBrazzaville: Locale.Region { get }

    public static var congoKinshasa: Locale.Region { get }

    public static var cookIslands: Locale.Region { get }

    public static var costaRica: Locale.Region { get }

    public static var côteDIvoire: Locale.Region { get }

    public static var croatia: Locale.Region { get }

    public static var cuba: Locale.Region { get }

    public static var curaçao: Locale.Region { get }

    public static var cyprus: Locale.Region { get }

    public static var czechia: Locale.Region { get }

    public static var denmark: Locale.Region { get }

    public static var diegoGarcia: Locale.Region { get }

    public static var djibouti: Locale.Region { get }

    public static var dominica: Locale.Region { get }

    public static var dominicanRepublic: Locale.Region { get }

    public static var ecuador: Locale.Region { get }

    public static var egypt: Locale.Region { get }

    public static var elSalvador: Locale.Region { get }

    public static var equatorialGuinea: Locale.Region { get }

    public static var eritrea: Locale.Region { get }

    public static var estonia: Locale.Region { get }

    public static var eswatini: Locale.Region { get }

    public static var ethiopia: Locale.Region { get }

    public static var falklandIslands: Locale.Region { get }

    public static var faroeIslands: Locale.Region { get }

    public static var fiji: Locale.Region { get }

    public static var finland: Locale.Region { get }

    public static var france: Locale.Region { get }

    public static var frenchGuiana: Locale.Region { get }

    public static var frenchPolynesia: Locale.Region { get }

    public static var frenchSouthernTerritories: Locale.Region { get }

    public static var gabon: Locale.Region { get }

    public static var gambia: Locale.Region { get }

    public static var georgia: Locale.Region { get }

    public static var germany: Locale.Region { get }

    public static var ghana: Locale.Region { get }

    public static var gibraltar: Locale.Region { get }

    public static var greece: Locale.Region { get }

    public static var greenland: Locale.Region { get }

    public static var grenada: Locale.Region { get }

    public static var guadeloupe: Locale.Region { get }

    public static var guam: Locale.Region { get }

    public static var guatemala: Locale.Region { get }

    public static var guernsey: Locale.Region { get }

    public static var guinea: Locale.Region { get }

    public static var guineaBissau: Locale.Region { get }

    public static var guyana: Locale.Region { get }

    public static var haiti: Locale.Region { get }

    public static var heardMcdonaldIslands: Locale.Region { get }

    public static var honduras: Locale.Region { get }

    public static var hongKong: Locale.Region { get }

    public static var hungary: Locale.Region { get }

    public static var iceland: Locale.Region { get }

    public static var india: Locale.Region { get }

    public static var indonesia: Locale.Region { get }

    public static var iran: Locale.Region { get }

    public static var iraq: Locale.Region { get }

    public static var ireland: Locale.Region { get }

    public static var isleOfMan: Locale.Region { get }

    public static var israel: Locale.Region { get }

    public static var italy: Locale.Region { get }

    public static var jamaica: Locale.Region { get }

    public static var japan: Locale.Region { get }

    public static var jersey: Locale.Region { get }

    public static var jordan: Locale.Region { get }

    public static var kazakhstan: Locale.Region { get }

    public static var kenya: Locale.Region { get }

    public static var kiribati: Locale.Region { get }

    public static var kosovo: Locale.Region { get }

    public static var kuwait: Locale.Region { get }

    public static var kyrgyzstan: Locale.Region { get }

    public static var laos: Locale.Region { get }

    public static var latvia: Locale.Region { get }

    public static var lebanon: Locale.Region { get }

    public static var lesotho: Locale.Region { get }

    public static var liberia: Locale.Region { get }

    public static var libya: Locale.Region { get }

    public static var liechtenstein: Locale.Region { get }

    public static var lithuania: Locale.Region { get }

    public static var luxembourg: Locale.Region { get }

    public static var macao: Locale.Region { get }

    public static var madagascar: Locale.Region { get }

    public static var malawi: Locale.Region { get }

    public static var malaysia: Locale.Region { get }

    public static var maldives: Locale.Region { get }

    public static var mali: Locale.Region { get }

    public static var malta: Locale.Region { get }

    public static var marshallIslands: Locale.Region { get }

    public static var martinique: Locale.Region { get }

    public static var mauritania: Locale.Region { get }

    public static var mauritius: Locale.Region { get }

    public static var mayotte: Locale.Region { get }

    public static var mexico: Locale.Region { get }

    public static var micronesia: Locale.Region { get }

    public static var moldova: Locale.Region { get }

    public static var monaco: Locale.Region { get }

    public static var mongolia: Locale.Region { get }

    public static var montenegro: Locale.Region { get }

    public static var montserrat: Locale.Region { get }

    public static var morocco: Locale.Region { get }

    public static var mozambique: Locale.Region { get }

    public static var myanmar: Locale.Region { get }

    public static var namibia: Locale.Region { get }

    public static var nauru: Locale.Region { get }

    public static var nepal: Locale.Region { get }

    public static var netherlands: Locale.Region { get }

    public static var newCaledonia: Locale.Region { get }

    public static var newZealand: Locale.Region { get }

    public static var nicaragua: Locale.Region { get }

    public static var niger: Locale.Region { get }

    public static var nigeria: Locale.Region { get }

    public static var niue: Locale.Region { get }

    public static var norfolkIsland: Locale.Region { get }

    public static var northernMarianaIslands: Locale.Region { get }

    public static var northMacedonia: Locale.Region { get }

    public static var norway: Locale.Region { get }

    public static var oman: Locale.Region { get }

    public static var pakistan: Locale.Region { get }

    public static var palau: Locale.Region { get }

    public static var palestinianTerritories: Locale.Region { get }

    public static var panama: Locale.Region { get }

    public static var papuaNewGuinea: Locale.Region { get }

    public static var paraguay: Locale.Region { get }

    public static var peru: Locale.Region { get }

    public static var philippines: Locale.Region { get }

    public static var pitcairnIslands: Locale.Region { get }

    public static var poland: Locale.Region { get }

    public static var portugal: Locale.Region { get }

    public static var puertoRico: Locale.Region { get }

    public static var qatar: Locale.Region { get }

    public static var réunion: Locale.Region { get }

    public static var romania: Locale.Region { get }

    public static var russia: Locale.Region { get }

    public static var rwanda: Locale.Region { get }

    public static var saintBarthélemy: Locale.Region { get }

    public static var saintHelena: Locale.Region { get }

    public static var saintKittsNevis: Locale.Region { get }

    public static var saintLucia: Locale.Region { get }

    public static var saintMartin: Locale.Region { get }

    public static var saintPierreMiquelon: Locale.Region { get }

    public static var saintVincentGrenadines: Locale.Region { get }

    public static var samoa: Locale.Region { get }

    public static var sanMarino: Locale.Region { get }

    public static var sãoToméPríncipe: Locale.Region { get }

    public static var saudiArabia: Locale.Region { get }

    public static var senegal: Locale.Region { get }

    public static var serbia: Locale.Region { get }

    public static var seychelles: Locale.Region { get }

    public static var sierraLeone: Locale.Region { get }

    public static var singapore: Locale.Region { get }

    public static var sintMaarten: Locale.Region { get }

    public static var slovakia: Locale.Region { get }

    public static var slovenia: Locale.Region { get }

    public static var solomonIslands: Locale.Region { get }

    public static var somalia: Locale.Region { get }

    public static var southAfrica: Locale.Region { get }

    public static var southGeorgiaSouthSandwichIslands: Locale.Region { get }

    public static var southKorea: Locale.Region { get }

    public static var southSudan: Locale.Region { get }

    public static var spain: Locale.Region { get }

    public static var sriLanka: Locale.Region { get }

    public static var suriname: Locale.Region { get }

    public static var svalbardJanMayen: Locale.Region { get }

    public static var sweden: Locale.Region { get }

    public static var switzerland: Locale.Region { get }

    public static var taiwan: Locale.Region { get }

    public static var tajikistan: Locale.Region { get }

    public static var tanzania: Locale.Region { get }

    public static var thailand: Locale.Region { get }

    public static var timorLeste: Locale.Region { get }

    public static var togo: Locale.Region { get }

    public static var tokelau: Locale.Region { get }

    public static var tonga: Locale.Region { get }

    public static var trinidadTobago: Locale.Region { get }

    public static var tristanDaCunha: Locale.Region { get }

    public static var tunisia: Locale.Region { get }

    public static var turkey: Locale.Region { get }

    public static var turkmenistan: Locale.Region { get }

    public static var turksCaicosIslands: Locale.Region { get }

    public static var tuvalu: Locale.Region { get }

    public static var uganda: Locale.Region { get }

    public static var ukraine: Locale.Region { get }

    public static var unitedArabEmirates: Locale.Region { get }

    public static var unitedKingdom: Locale.Region { get }

    public static var unitedStates: Locale.Region { get }

    public static var unitedStatesOutlyingIslands: Locale.Region { get }

    public static var unitedStatesVirginIslands: Locale.Region { get }

    public static var uruguay: Locale.Region { get }

    public static var uzbekistan: Locale.Region { get }

    public static var vanuatu: Locale.Region { get }

    public static var vaticanCity: Locale.Region { get }

    public static var venezuela: Locale.Region { get }

    public static var vietnam: Locale.Region { get }

    public static var wallisFutuna: Locale.Region { get }

    public static var westernSahara: Locale.Region { get }

    public static var yemen: Locale.Region { get }

    public static var zambia: Locale.Region { get }

    public static var zimbabwe: Locale.Region { get }

    public static var world: Locale.Region { get }

    public static var latinAmerica: Locale.Region { get }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Collation {

    /// A list of available collations on the system.
    public static var availableCollations: [Locale.Collation] { get }

    /// A list of available collations for the specified `language` in the order that it is most likely to make a difference.
    public static func availableCollations(for language: Locale.Language) -> [Locale.Collation]
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Locale.Collation : CustomDebugStringConvertible {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Currency {

    public var isISOCurrency: Bool { get }

    /// Represents an unknown currency, used when no currency is involved in a transaction
    public static let unknown: Locale.Currency

    /// Returns a list of `Locale` currency codes defined in ISO-4217
    public static var isoCurrencies: [Locale.Currency] { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Locale.Currency : CustomDebugStringConvertible {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.NumberingSystem {

    /// A list of available numbering systems on the system.
    public static var availableNumberingSystems: [Locale.NumberingSystem] { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Locale.NumberingSystem : CustomDebugStringConvertible {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Weekday : RawRepresentable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.HourCycle : RawRepresentable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Locale.MeasurementSystem : CustomDebugStringConvertible {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Locale.Subdivision : CustomDebugStringConvertible {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Locale.Variant : CustomDebugStringConvertible {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Language {

    /// Ordering of lines within a page.
    /// For example, top-to-bottom for English; right-to-left for Mongolian in the Mongolian Script
    /// - note: See also `characterDirection`.
    public var lineLayoutDirection: Locale.LanguageDirection { get }

    /// Ordering of characters within a line.
    /// For example, left-to-right for English; top-to-bottom for Mongolian in the Mongolian Script
    public var characterDirection: Locale.LanguageDirection { get }

    /// Returns the parent language of a language. For example, the parent language of `"en_US_POSIX"` is `"en_US"`
    /// Returns nil if the parent language cannot be determined
    public var parent: Locale.Language? { get }

    public func hasCommonParent(with language: Locale.Language) -> Bool

    /// Returns if `self` and the specified `language` are equal after expanding missing components
    /// For example, `en`, `en-Latn`, `en-US`, and `en-Latn-US` are equivalent
    public func isEquivalent(to language: Locale.Language) -> Bool

    /// Creates a `Language` with the language identifier
    /// - Parameter identifier: Unicode language identifier, such as "en-US", "es-419", "zh-Hant-TW"
    public init(identifier: String)

    /// Returns a BCP-47 identifier in a minimalist form. Script and region may be omitted. For example, "zh-TW", "en"
    public var minimalIdentifier: String { get }

    /// Returns a BCP-47 identifier that always includes the script: "zh-Hant-TW", "en-Latn-US"
    public var maximalIdentifier: String { get }

    /// The language code of the language. Returns nil if it cannot be determined
    public var languageCode: Locale.LanguageCode? { get }

    /// The script of the language. Returns nil if it cannot be determined
    public var script: Locale.Script? { get }

    /// The region of the language. Returns nil if it cannot be determined
    public var region: Locale.Region? { get }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.LanguageCode.IdentifierType : Equatable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.LanguageCode.IdentifierType : Hashable {
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension Locale.Language.Components {

    /// - Parameter identifier: Unicode language identifier, such as "en-US", "es-419", "zh-Hant-TW"
    public init(identifier: String)

    public init(language: Locale.Language)
}

/// Describes an error that provides localized messages describing why
/// an error occurred and provides more information about the error.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol LocalizedError : Error {

    /// A localized message describing what error occurred.
    var errorDescription: String? { get }

    /// A localized message describing the reason for the failure.
    var failureReason: String? { get }

    /// A localized message describing how one might recover from the failure.
    var recoverySuggestion: String? { get }

    /// A localized message providing "help" text if the user requests help.
    var helpAnchor: String? { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension LocalizedError {

    /// A localized message describing what error occurred.
    public var errorDescription: String? { get }

    /// A localized message describing the reason for the failure.
    public var failureReason: String? { get }

    /// A localized message describing how one might recover from the failure.
    public var recoverySuggestion: String? { get }

    /// A localized message providing "help" text if the user requests help.
    public var helpAnchor: String? { get }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public struct LocalizedStringResource : Equatable, Codable, CustomLocalizedStringResourceConvertible, ExpressibleByStringInterpolation {

    public let key: String

    public let defaultValue: String.LocalizationValue

    public let table: String?

    public var locale: Locale

    public var bundle: LocalizedStringResource.BundleDescription { get }

    public enum BundleDescription : Sendable {

        case main

        case forClass(AnyClass)

        case atURL(URL)
    }

    public init(_ keyAndValue: String.LocalizationValue, table: String? = nil, locale: Locale = .current, bundle: LocalizedStringResource.BundleDescription = .main, comment: StaticString? = nil)

    public init(_ key: StaticString, defaultValue: String.LocalizationValue, table: String? = nil, locale: Locale = .current, bundle: LocalizedStringResource.BundleDescription = .main, comment: StaticString? = nil)

    public init(_ keyAndValue: String.LocalizationValue, table: String? = nil, locale: Locale = .current, bundle: Bundle, comment: StaticString? = nil)

    public init(_ key: StaticString, defaultValue: String.LocalizationValue, table: String? = nil, locale: Locale = .current, bundle: Bundle, comment: StaticString? = nil)

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: String)

    /// Creates an instance from a string interpolation.
    /// 
    /// Most `StringInterpolation` types will store information about the
    /// literals and interpolations appended to them in one or more properties.
    /// `init(stringInterpolation:)` should use these properties to initialize
    /// the instance.
    /// 
    /// - Parameter stringInterpolation: An instance of `StringInterpolation`
    ///             which has had each segment of the string literal appended
    ///             to it.
    public init(stringInterpolation: String.LocalizationValue.StringInterpolation)

    public var localizedStringResource: LocalizedStringResource { get }

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: LocalizedStringResource, rhs: LocalizedStringResource) -> Bool

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias ExtendedGraphemeClusterLiteralType = String

    /// The type each segment of a string literal containing interpolations
    /// should be appended to.
    ///
    /// The `StringLiteralType` of an interpolation type must match the
    /// `StringLiteralType` of the conforming type.
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringInterpolation = String.LocalizationValue.StringInterpolation

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias StringLiteralType = String

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    @available(iOS 16, tvOS 16, watchOS 9, macOS 13, *)
    public typealias UnicodeScalarLiteralType = String
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension LocalizedStringResource : Sendable {
}

/// Describes an error in the Mach error domain.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct MachError {

    /// The domain of the error.
    public static var errorDomain: String { get }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// The type of an error code.
    public typealias Code = MachErrorCode
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension MachError {

    public static var success: MachError.Code { get }

    /// Specified address is not currently valid.
    public static var invalidAddress: MachError.Code { get }

    /// Specified memory is valid, but does not permit the required
    /// forms of access.
    public static var protectionFailure: MachError.Code { get }

    /// The address range specified is already in use, or no address
    /// range of the size specified could be found.
    public static var noSpace: MachError.Code { get }

    /// The function requested was not applicable to this type of
    /// argument, or an argument is invalid.
    public static var invalidArgument: MachError.Code { get }

    /// The function could not be performed.  A catch-all.
    public static var failure: MachError.Code { get }

    /// A system resource could not be allocated to fulfill this
    /// request.  This failure may not be permanent.
    public static var resourceShortage: MachError.Code { get }

    /// The task in question does not hold receive rights for the port
    /// argument.
    public static var notReceiver: MachError.Code { get }

    /// Bogus access restriction.
    public static var noAccess: MachError.Code { get }

    /// During a page fault, the target address refers to a memory
    /// object that has been destroyed.  This failure is permanent.
    public static var memoryFailure: MachError.Code { get }

    /// During a page fault, the memory object indicated that the data
    /// could not be returned.  This failure may be temporary; future
    /// attempts to access this same data may succeed, as defined by the
    /// memory object.
    public static var memoryError: MachError.Code { get }

    /// The receive right is already a member of the portset.
    public static var alreadyInSet: MachError.Code { get }

    /// The receive right is not a member of a port set.
    public static var notInSet: MachError.Code { get }

    /// The name already denotes a right in the task.
    public static var nameExists: MachError.Code { get }

    /// The operation was aborted.  Ipc code will catch this and reflect
    /// it as a message error.
    public static var aborted: MachError.Code { get }

    /// The name doesn't denote a right in the task.
    public static var invalidName: MachError.Code { get }

    /// Target task isn't an active task.
    public static var invalidTask: MachError.Code { get }

    /// The name denotes a right, but not an appropriate right.
    public static var invalidRight: MachError.Code { get }

    /// A blatant range error.
    public static var invalidValue: MachError.Code { get }

    /// Operation would overflow limit on user-references.
    public static var userReferencesOverflow: MachError.Code { get }

    /// The supplied (port) capability is improper.
    public static var invalidCapability: MachError.Code { get }

    /// The task already has send or receive rights for the port under
    /// another name.
    public static var rightExists: MachError.Code { get }

    /// Target host isn't actually a host.
    public static var invalidHost: MachError.Code { get }

    /// An attempt was made to supply "precious" data for memory that is
    /// already present in a memory object.
    public static var memoryPresent: MachError.Code { get }

    /// A page was requested of a memory manager via
    /// memory_object_data_request for an object using a
    /// MEMORY_OBJECT_COPY_CALL strategy, with the VM_PROT_WANTS_COPY
    /// flag being used to specify that the page desired is for a copy
    /// of the object, and the memory manager has detected the page was
    /// pushed into a copy of the object while the kernel was walking
    /// the shadow chain from the copy to the object. This error code is
    /// delivered via memory_object_data_error and is handled by the
    /// kernel (it forces the kernel to restart the fault). It will not
    /// be seen by users.
    public static var memoryDataMoved: MachError.Code { get }

    /// A strategic copy was attempted of an object upon which a quicker
    /// copy is now possible.  The caller should retry the copy using
    /// vm_object_copy_quickly. This error code is seen only by the
    /// kernel.
    public static var memoryRestartCopy: MachError.Code { get }

    /// An argument applied to assert processor set privilege was not a
    /// processor set control port.
    public static var invalidProcessorSet: MachError.Code { get }

    /// The specified scheduling attributes exceed the thread's limits.
    public static var policyLimit: MachError.Code { get }

    /// The specified scheduling policy is not currently enabled for the
    /// processor set.
    public static var invalidPolicy: MachError.Code { get }

    /// The external memory manager failed to initialize the memory object.
    public static var invalidObject: MachError.Code { get }

    /// A thread is attempting to wait for an event for which there is
    /// already a waiting thread.
    public static var alreadyWaiting: MachError.Code { get }

    /// An attempt was made to destroy the default processor set.
    public static var defaultSet: MachError.Code { get }

    /// An attempt was made to fetch an exception port that is
    /// protected, or to abort a thread while processing a protected
    /// exception.
    public static var exceptionProtected: MachError.Code { get }

    /// A ledger was required but not supplied.
    public static var invalidLedger: MachError.Code { get }

    /// The port was not a memory cache control port.
    public static var invalidMemoryControl: MachError.Code { get }

    /// An argument supplied to assert security privilege was not a host
    /// security port.
    public static var invalidSecurity: MachError.Code { get }

    /// thread_depress_abort was called on a thread which was not
    /// currently depressed.
    public static var notDepressed: MachError.Code { get }

    /// Object has been terminated and is no longer available.
    public static var terminated: MachError.Code { get }

    /// Lock set has been destroyed and is no longer available.
    public static var lockSetDestroyed: MachError.Code { get }

    /// The thread holding the lock terminated before releasing the lock.
    public static var lockUnstable: MachError.Code { get }

    /// The lock is already owned by another thread.
    public static var lockOwned: MachError.Code { get }

    /// The lock is already owned by the calling thread.
    public static var lockOwnedSelf: MachError.Code { get }

    /// Semaphore has been destroyed and is no longer available.
    public static var semaphoreDestroyed: MachError.Code { get }

    /// Return from RPC indicating the target server was terminated
    /// before it successfully replied.
    public static var rpcServerTerminated: MachError.Code { get }

    /// Terminate an orphaned activation.
    public static var rpcTerminateOrphan: MachError.Code { get }

    /// Allow an orphaned activation to continue executing.
    public static var rpcContinueOrphan: MachError.Code { get }

    /// Empty thread activation (No thread linked to it).
    public static var notSupported: MachError.Code { get }

    /// Remote node down or inaccessible.
    public static var nodeDown: MachError.Code { get }

    /// A signalled thread was not actually waiting.
    public static var notWaiting: MachError.Code { get }

    /// Some thread-oriented operation (semaphore_wait) timed out.
    public static var operationTimedOut: MachError.Code { get }

    /// During a page fault, indicates that the page was rejected as a
    /// result of a signature check.
    public static var codesignError: MachError.Code { get }

    /// The requested property cannot be changed at this time.
    public static var policyStatic: MachError.Code { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol MarkdownDecodableAttributedStringKey : AttributedStringKey {

    static func decodeMarkdown(from decoder: any Decoder) throws -> Self.Value

    static var markdownName: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension MarkdownDecodableAttributedStringKey {

    public static var markdownName: String { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension MarkdownDecodableAttributedStringKey where Self : DecodableAttributedStringKey {

    public static func decodeMarkdown(from decoder: any Decoder) throws -> Self.Value
}

/// A `Measurement` is a model type that holds a `Double` value associated with a `Unit`.
///
/// Measurements support a large set of operators, including `+`, `-`, `*`, `/`, and a full set of comparison operators.
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
public struct Measurement<UnitType> : ReferenceConvertible, Comparable, Equatable where UnitType : Unit {

    public typealias ReferenceType = NSMeasurement

    /// The unit component of the `Measurement`.
    public let unit: UnitType

    /// The value component of the `Measurement`.
    public var value: Double

    /// Create a `Measurement` given a specified value and unit.
    public init(value: Double, unit: UnitType)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : Sendable {
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

/// When a `Measurement` contains a `Dimension` unit, it gains the ability to convert between the kinds of units in that dimension.
@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement where UnitType : Dimension {

    /// Returns a new measurement created by converting to the specified unit.
    ///
    /// - parameter otherUnit: A unit of the same `Dimension`.
    /// - returns: A converted measurement.
    public func converted(to otherUnit: UnitType) -> Measurement<UnitType>

    /// Converts the measurement to the specified unit.
    ///
    /// - parameter otherUnit: A unit of the same `Dimension`.
    public mutating func convert(to otherUnit: UnitType)

    /// Add two measurements of the same Dimension.
    ///
    /// If the `unit` of the `lhs` and `rhs` are `isEqual`, then this returns the result of adding the `value` of each `Measurement`. If they are not equal, then this will convert both to the base unit of the `Dimension` and return the result as a `Measurement` of that base unit.
    /// - returns: The result of adding the two measurements.
    public static func + (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>

    /// Subtract two measurements of the same Dimension.
    ///
    /// If the `unit` of the `lhs` and `rhs` are `==`, then this returns the result of subtracting the `value` of each `Measurement`. If they are not equal, then this will convert both to the base unit of the `Dimension` and return the result as a `Measurement` of that base unit.
    /// - returns: The result of adding the two measurements.
    public static func - (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement {

    /// Add two measurements of the same Unit.
    /// - precondition: The `unit` of `lhs` and `rhs` must be `isEqual`.
    /// - returns: A measurement of value `lhs.value + rhs.value` and unit `lhs.unit`.
    public static func + (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>

    /// Subtract two measurements of the same Unit.
    /// - precondition: The `unit` of `lhs` and `rhs` must be `isEqual`.
    /// - returns: A measurement of value `lhs.value - rhs.value` and unit `lhs.unit`.
    public static func - (lhs: Measurement<UnitType>, rhs: Measurement<UnitType>) -> Measurement<UnitType>

    /// Multiply a measurement by a scalar value.
    /// - returns: A measurement of value `lhs.value * rhs` with the same unit as `lhs`.
    public static func * (lhs: Measurement<UnitType>, rhs: Double) -> Measurement<UnitType>

    /// Multiply a scalar value by a measurement.
    /// - returns: A measurement of value `lhs * rhs.value` with the same unit as `rhs`.
    public static func * (lhs: Double, rhs: Measurement<UnitType>) -> Measurement<UnitType>

    /// Divide a measurement by a scalar value.
    /// - returns: A measurement of value `lhs.value / rhs` with the same unit as `lhs`.
    public static func / (lhs: Measurement<UnitType>, rhs: Double) -> Measurement<UnitType>

    /// Divide a scalar value by a measurement.
    /// - returns: A measurement of value `lhs / rhs.value` with the same unit as `rhs`.
    public static func / (lhs: Double, rhs: Measurement<UnitType>) -> Measurement<UnitType>

    /// Compare two measurements of the same `Dimension`.
    ///
    /// If `lhs.unit == rhs.unit`, returns `lhs.value == rhs.value`. Otherwise, converts `rhs` to the same unit as `lhs` and then compares the resulting values.
    /// - returns: `true` if the measurements are equal.
    public static func == <LeftHandSideType, RightHandSideType>(lhs: Measurement<LeftHandSideType>, rhs: Measurement<RightHandSideType>) -> Bool where LeftHandSideType : Unit, RightHandSideType : Unit

    /// Compare two measurements of the same `Unit`.
    /// - returns: `true` if the measurements can be compared and the `lhs` is less than the `rhs` converted value.
    public static func < <LeftHandSideType, RightHandSideType>(lhs: Measurement<LeftHandSideType>, rhs: Measurement<RightHandSideType>) -> Bool where LeftHandSideType : Unit, RightHandSideType : Unit
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension Measurement : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Measurement where UnitType : Dimension {

    @dynamicMemberLookup public struct AttributedStyle : FormatStyle, Sendable {

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ measurement: Measurement<UnitType>) -> AttributedString

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Measurement<UnitType>.AttributedStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Measurement<UnitType>.AttributedStyle, b: Measurement<UnitType>.AttributedStyle) -> Bool

        /// The type of data to format.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatInput = Measurement<UnitType>

        /// The type of the formatted data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatOutput = AttributedString

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Measurement where UnitType : Dimension {

    public struct FormatStyle : FormatStyle, Sendable {

        public struct UnitWidth : Codable, Hashable, Sendable {

            /// Examples for formatting a measurement with value of 37.20:
            ///
            /// Shows the unit in its full spelling.
            /// For example, "37.20 Calories", "37,20 litres"
            public static var wide: Measurement<UnitType>.FormatStyle.UnitWidth { get }

            /// Shows the unit using abbreviation.
            /// For example, "37.20 Cal", "37,2 L"
            public static var abbreviated: Measurement<UnitType>.FormatStyle.UnitWidth { get }

            /// Shows the unit in the shortest form possible, and may condense the spacing between the value and the unit.
            /// For example, "37.20Cal", "37,2L"
            public static var narrow: Measurement<UnitType>.FormatStyle.UnitWidth { get }

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Measurement<UnitType>.FormatStyle.UnitWidth, b: Measurement<UnitType>.FormatStyle.UnitWidth) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        public var width: Measurement<UnitType>.FormatStyle.UnitWidth

        public var locale: Locale

        /// Specifies how the value part is formatted.
        public var numberFormatStyle: FloatingPointFormatStyle<Double>?

        public var usage: MeasurementFormatUnitUsage<UnitType>?

        public var attributed: Measurement<UnitType>.AttributedStyle { get }

        public init(width: Measurement<UnitType>.FormatStyle.UnitWidth, locale: Locale = .autoupdatingCurrent, usage: MeasurementFormatUnitUsage<UnitType> = .general, numberFormatStyle: FloatingPointFormatStyle<Double>? = nil)

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Measurement<UnitType>.FormatStyle

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ measurement: Measurement<UnitType>) -> String

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Measurement<UnitType>.FormatStyle, b: Measurement<UnitType>.FormatStyle) -> Bool

        /// The type of data to format.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatInput = Measurement<UnitType>

        /// The type of the formatted data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatOutput = String

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Measurement where UnitType : Dimension {

    public func formatted<S>(_ style: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Measurement<UnitType>

    public func formatted() -> String
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Measurement.AttributedStyle where UnitType == UnitInformationStorage {

    /// Formats a `Measurement<UnitInformationStorage>` as an attributed string. The attributed string output contains `FoundationAttributes.ByteCountAttribute`, `Foundation.NumberFormatPart`, and `Foundation.NumberFormatSymbol` attributes.
    public struct ByteCount : FormatStyle, Sendable {

        public typealias Style = ByteCountFormatStyle.Style

        public typealias Units = ByteCountFormatStyle.Units

        public var style: Measurement<UnitInformationStorage>.AttributedStyle.ByteCount.Style

        public var allowedUnits: Measurement<UnitInformationStorage>.AttributedStyle.ByteCount.Units

        public var spellsOutZero: Bool

        public var includesActualByteCount: Bool

        public var locale: Locale

        public init(style: Measurement<UnitType>.AttributedStyle.ByteCount.Style, allowedUnits: Measurement<UnitType>.AttributedStyle.ByteCount.Units, spellsOutZero: Bool, includesActualByteCount: Bool, locale: Locale)

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ value: Measurement<UnitInformationStorage>) -> AttributedString

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Measurement<UnitType>.AttributedStyle.ByteCount

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Measurement<UnitType>.AttributedStyle.ByteCount, b: Measurement<UnitType>.AttributedStyle.ByteCount) -> Bool

        /// The type of data to format.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias FormatInput = Measurement<UnitInformationStorage>

        /// The type of the formatted data.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias FormatOutput = AttributedString

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension Measurement.AttributedStyle {

    public subscript<T>(dynamicMember key: KeyPath<Measurement<UnitType>.FormatStyle, T>) -> T { get }

    public subscript<T>(dynamicMember key: WritableKeyPath<Measurement<UnitType>.FormatStyle, T>) -> T
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Measurement.FormatStyle where UnitType == UnitTemperature {

    /// Hides the scale name. For example, "90°" rather than "90°F" or "90°C" with the `narrow` unit width, or "90 degrees" rather than "90 degrees celcius" or "90 degrees fahrenheit" with the `wide` width.
    public var hidesScaleName: Bool

    public init(width: Measurement<UnitType>.FormatStyle.UnitWidth = .abbreviated, locale: Locale = .autoupdatingCurrent, usage: MeasurementFormatUnitUsage<UnitType> = .general, hidesScaleName: Bool = false, numberFormatStyle: FloatingPointFormatStyle<Double>? = nil)
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Measurement.FormatStyle where UnitType == UnitInformationStorage {

    public struct ByteCount : FormatStyle, Sendable {

        public typealias Style = ByteCountFormatStyle.Style

        public typealias Units = ByteCountFormatStyle.Units

        public var style: Measurement<UnitInformationStorage>.FormatStyle.ByteCount.Style

        public var allowedUnits: Measurement<UnitInformationStorage>.FormatStyle.ByteCount.Units

        public var spellsOutZero: Bool

        public var includesActualByteCount: Bool

        public var locale: Locale

        public var attributed: Measurement<UnitInformationStorage>.AttributedStyle.ByteCount { get }

        public init(style: Measurement<UnitType>.FormatStyle.ByteCount.Style, allowedUnits: Measurement<UnitType>.FormatStyle.ByteCount.Units, spellsOutZero: Bool, includesActualByteCount: Bool, locale: Locale)

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ value: Measurement<UnitInformationStorage>) -> String

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Measurement<UnitType>.FormatStyle.ByteCount

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Measurement<UnitType>.FormatStyle.ByteCount, b: Measurement<UnitType>.FormatStyle.ByteCount) -> Bool

        /// The type of data to format.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias FormatInput = Measurement<UnitInformationStorage>

        /// The type of the formatted data.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias FormatOutput = String

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct MeasurementFormatUnitUsage<UnitType> : Codable, Hashable, Sendable where UnitType : Dimension {

    /// Default. No specific usage.
    public static var general: MeasurementFormatUnitUsage<UnitType> { get }

    /// Ignore the preferred unit by the locale and use the given unit.
    public static var asProvided: MeasurementFormatUnitUsage<UnitType> { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: MeasurementFormatUnitUsage<UnitType>, b: MeasurementFormatUnitUsage<UnitType>) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitTemperature {

    public static var weather: MeasurementFormatUnitUsage<UnitTemperature> { get }

    public static var person: MeasurementFormatUnitUsage<UnitTemperature> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitLength {

    public static var person: MeasurementFormatUnitUsage<UnitLength> { get }

    public static var road: MeasurementFormatUnitUsage<UnitLength> { get }

    public static var personHeight: MeasurementFormatUnitUsage<UnitLength> { get }

    /// Describes the distance of visibility
    @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
    public static var visibility: MeasurementFormatUnitUsage<UnitLength> { get }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitLength {

    /// Used to format the focal length of an optical system, such as that of camera lenses
    public static var focalLength: MeasurementFormatUnitUsage<UnitLength> { get }

    /// Used to format the rainfall amount
    public static var rainfall: MeasurementFormatUnitUsage<UnitLength> { get }

    /// Used to format the snowfall amount
    public static var snowfall: MeasurementFormatUnitUsage<UnitLength> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitEnergy {

    public static var food: MeasurementFormatUnitUsage<UnitEnergy> { get }

    public static var workout: MeasurementFormatUnitUsage<UnitEnergy> { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitMass {

    public static var personWeight: MeasurementFormatUnitUsage<UnitMass> { get }
}

extension MeasurementFormatUnitUsage where UnitType == UnitSpeed {

    /// Describes the unit for wind speed
    @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
    public static var wind: MeasurementFormatUnitUsage<UnitSpeed> { get }
}

extension MeasurementFormatUnitUsage where UnitType == UnitPressure {

    /// Describes the unit for barometric pressure
    @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
    public static var barometric: MeasurementFormatUnitUsage<UnitPressure> { get }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension MeasurementFormatUnitUsage where UnitType == UnitVolume {

    /// Used to format the amount of liquid
    public static var liquid: MeasurementFormatUnitUsage<UnitVolume> { get }
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
public struct Morphology : Sendable {

    public init()

    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    public enum GrammaticalGender : Int, Hashable, Sendable {

        case feminine

        case masculine

        case neuter

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    public var grammaticalGender: Morphology.GrammaticalGender?

    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    public enum PartOfSpeech : Int, Hashable, Sendable {

        case determiner

        case pronoun

        case letter

        case adverb

        case particle

        case adjective

        case adposition

        case verb

        case noun

        case conjunction

        case numeral

        case interjection

        case preposition

        case abbreviation

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    public var partOfSpeech: Morphology.PartOfSpeech?

    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    public enum GrammaticalNumber : Int, Hashable, Sendable {

        case singular

        case zero

        case plural

        case pluralTwo

        case pluralFew

        case pluralMany

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    public var number: Morphology.GrammaticalNumber?

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public enum GrammaticalCase : Int, Hashable, Sendable {

        case nominative

        case accusative

        case dative

        case genitive

        case prepositional

        case ablative

        case adessive

        case allative

        case elative

        case illative

        case essive

        case inessive

        case locative

        case translative

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var grammaticalCase: Morphology.GrammaticalCase?

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public enum GrammaticalPerson : Int, Hashable, Sendable {

        case first

        case second

        case third

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var grammaticalPerson: Morphology.GrammaticalPerson?

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public enum PronounType : Int, Hashable, Sendable {

        case personal

        case reflexive

        case possessive

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var pronounType: Morphology.PronounType?

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public enum Determination : Int, Hashable, Sendable {

        case independent

        case dependent

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var determination: Morphology.Determination?

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public enum Definiteness : Int, Hashable, Sendable {

        case indefinite

        case definite

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 17, tvOS 17, watchOS 10, macOS 14, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var definiteness: Morphology.Definiteness?
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology : Hashable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: Morphology, b: Morphology) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS, introduced: 12.0, deprecated: 14.0, message: "Use TermOfAddress instead")
@available(iOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
@available(tvOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
@available(watchOS, introduced: 8.0, deprecated: 10.0, message: "Use TermOfAddress instead")
extension Morphology {

    public func customPronoun(forLanguage language: String) -> Morphology.CustomPronoun?

    public mutating func setCustomPronoun(_ pronoun: Morphology.CustomPronoun?, forLanguage language: String) throws

    @available(macOS, introduced: 12.0, deprecated: 14.0, message: "Use TermOfAddress instead")
    @available(iOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
    @available(tvOS, introduced: 15.0, deprecated: 17.0, message: "Use TermOfAddress instead")
    @available(watchOS, introduced: 8.0, deprecated: 10.0, message: "Use TermOfAddress instead")
    public struct CustomPronoun : Sendable, Codable, Hashable, Equatable {

        public init()

        public static func isSupported(forLanguage language: String) -> Bool

        public static func requiredKeys(forLanguage language: String) -> [PartialKeyPath<Morphology.CustomPronoun>]

        public var subjectForm: String?

        public var objectForm: String?

        public var possessiveForm: String?

        public var possessiveAdjectiveForm: String?

        public var reflexiveForm: String?

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Morphology.CustomPronoun, b: Morphology.CustomPronoun) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology {

    /// A single pronoun referring to a third person
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public struct Pronoun : Sendable, Equatable, Hashable, Codable {

        public var pronoun: String

        public var morphology: Morphology

        public var dependentMorphology: Morphology?

        public init(pronoun: String, morphology: Morphology, dependentMorphology: Morphology? = nil)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Morphology.Pronoun, b: Morphology.Pronoun) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology {

    public var isUnspecified: Bool { get }

    public static let user: Morphology
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology.GrammaticalGender : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Morphology.GrammaticalGender : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology.PartOfSpeech : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Morphology.PartOfSpeech : RawRepresentable {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Morphology.GrammaticalNumber : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension Morphology.GrammaticalNumber : RawRepresentable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.GrammaticalCase : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.GrammaticalCase : RawRepresentable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.GrammaticalPerson : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.GrammaticalPerson : RawRepresentable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.PronounType : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.PronounType : RawRepresentable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.Determination : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.Determination : RawRepresentable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.Definiteness : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Morphology.Definiteness : RawRepresentable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol MutableDataProtocol : DataProtocol, MutableCollection, RangeReplaceableCollection {

    /// Replaces the contents of the buffer at the given range with zeroes.
    ///
    /// A default implementation is given in terms of
    /// `replaceSubrange(_:with:)`.
    mutating func resetBytes<R>(in range: R) where R : RangeExpression, Self.Index == R.Bound
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension MutableDataProtocol {

    /// Replaces the contents of the buffer at the given range with zeroes.
    ///
    /// A default implementation is given in terms of
    /// `replaceSubrange(_:with:)`.
    public mutating func resetBytes<R>(in range: R) where R : RangeExpression, Self.Index == R.Bound
}

@available(*, deprecated, message: "Please use the struct type URLRequest")
public typealias MutableURLRequest = NSMutableURLRequest

public typealias NSErrorPointer = AutoreleasingUnsafeMutablePointer<NSError?>?

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@available(*, noasync)
public struct NSFastEnumerationIterator : IteratorProtocol {

    public init(_ enumerable: any NSFastEnumeration)

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Any?

    /// The type of element traversed by the iterator.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    @available(*, noasync)
    public typealias Element = Any
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct NSIndexSetIterator : IteratorProtocol {

    /// The type of element traversed by the iterator.
    public typealias Element = Int

    /// Advances to the next element and returns it, or `nil` if no next element
    /// exists.
    ///
    /// Repeatedly calling this method returns, in order, all the elements of the
    /// underlying sequence. As soon as the sequence has run out of elements, all
    /// subsequent calls return `nil`.
    ///
    /// You must not call this method if any other copy of this iterator has been
    /// advanced with a call to its `next()` method.
    ///
    /// The following example shows how an iterator can be used explicitly to
    /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
    /// then call the iterator's `next()` method until it returns `nil`.
    ///
    ///     let numbers = [2, 3, 5, 7]
    ///     var numbersIterator = numbers.makeIterator()
    ///
    ///     while let num = numbersIterator.next() {
    ///         print(num)
    ///     }
    ///     // Prints "2"
    ///     // Prints "3"
    ///     // Prints "5"
    ///     // Prints "7"
    ///
    /// - Returns: The next element in the underlying sequence, if a next element
    ///   exists; otherwise, `nil`.
    public mutating func next() -> Int?
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
@objc(_NSKeyValueObservation) public class NSKeyValueObservation : NSObject {

    ///invalidate() will be called automatically when an NSKeyValueObservation is deinited
    @objc public func invalidate()

    @objc deinit
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension NSKeyValueObservation : @unchecked Sendable {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct NSKeyValueObservedChange<Value> {

    public typealias Kind = NSKeyValueChange

    public let kind: NSKeyValueObservedChange<Value>.Kind

    ///newValue and oldValue will only be non-nil if .new/.old is passed to `observe()`. In general, get the most up to date value by accessing it directly on the observed object instead.
    public let newValue: Value?

    public let oldValue: Value?

    ///indexes will be nil unless the observed KeyPath refers to an ordered to-many property
    public let indexes: IndexSet?

    ///'isPrior' will be true if this change observation is being sent before the change happens, due to .prior being passed to `observe()`
    public let isPrior: Bool
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSKeyValueObservedChange : Sendable where Value : Sendable {
}

///Conforming to NSKeyValueObservingCustomization is not required to use Key-Value Observing. Provide an implementation of these functions if you need to disable auto-notifying for a key, or add dependent keys
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol NSKeyValueObservingCustomization : NSObjectProtocol {

    static func keyPathsAffectingValue(for key: AnyKeyPath) -> Set<AnyKeyPath>

    static func automaticallyNotifiesObservers(for key: AnyKeyPath) -> Bool
}

/// Returns the localized version of a string.
///
/// - parameter key: An identifying value used to reference a localized string.
///   Don't use the empty string as a key. Values keyed by the empty string will
///   not be localized.
/// - parameter tableName: The name of the table containing the localized string
///   identified by `key`. This is the prefix of the strings file—a file with
///   the `.strings` extension—containing the localized values. If `tableName`
///   is `nil` or the empty string, the `Localizable` table is used.
/// - parameter bundle: The bundle containing the table's strings file. The main
///   bundle is used by default.
/// - parameter value: A user-visible string to return when the localized string
///   for `key` cannot be found in the table. If `value` is the empty string,
///   `key` would be returned instead.
/// - parameter comment: A note to the translator describing the context where
///   the localized string is presented to the user.
///
/// - returns: A localized version of the string designated by `key` in the
///   table identified by `tableName`. If the localized string for `key` cannot
///   be found within the table, `value` is returned. However, `key` is returned
///   instead when `value` is the empty string.
///
/// Export Localizations with Xcode
/// -------------------------------
///
/// Xcode can read through a project's code to find invocations of
/// `NSLocalizedString(_:tableName:bundle:value:comment:)` and automatically
/// generate the appropriate strings files for the project's base localization.
///
/// In Xcode, open the project file and, in the `Edit` menu, select
/// `Export for Localization`. This will generate an XLIFF bundle containing
/// strings files derived from your code along with other localizable assets.
/// `xcodebuild` can also be used to generate the localization bundle from the
/// command line with the `exportLocalizations` option.
///
///     xcodebuild -exportLocalizations -project <projectname>.xcodeproj \
///                                     -localizationPath <path>
///
/// These bundles can be sent to translators for localization, and then
/// reimported into your Xcode project. In Xcode, open the project file. In the
/// `Edit` menu, select `Import Localizations...`, and select the XLIFF
/// folder to import. You can also use `xcodebuild` to import localizations with
/// the `importLocalizations` option.
///
///     xcodebuild -importLocalizations -project <projectname>.xcodeproj \
///                                     -localizationPath <path>
///
/// Choose Meaningful Keys
/// ----------------------
///
/// Words can often have multiple different meanings depending on the context
/// in which they're used. For example, the word "Book" can be used as a noun—a
/// printed literary work—and it can be used as a verb—the action of making a
/// reservation. Words with different meanings which share the same spelling are
/// heteronyms.
///
/// Different languages often have different heteronyms. "Book" in English is
/// one such heteronym, but that's not so in French, where the noun translates
/// to "Livre", and the verb translates to "Réserver". For this reason, it's
/// important make sure that each use of the same phrase is translated
/// appropriately for its context by assigning unique keys to each phrase and
/// adding a description comment describing how that phrase is used.
///
///     NSLocalizedString("book-tag-title", value: "Book", comment: """
///     noun: A label attached to literary items in the library.
///     """)
///
///     NSLocalizedString("book-button-title", value: "Book", comment: """
///     verb: Title of the button that makes a reservation.
///     """)
///
/// Use Only String Literals
/// ------------------------
///
/// String literal values must be used with `key`, `tableName`, `value`, and
/// `comment`.
///
/// Xcode does not evaluate interpolated strings and string variables when
/// generating strings files from code. Attempting to localize a string using
/// those language features will cause Xcode to export something that resembles
/// the original code expression instead of its expected value at runtime.
/// Translators would then translate that exported value—leaving
/// international users with a localized string containing code.
///
///     // Translators will see "1 + 1 = (1 + 1)".
///     // International users will see a localization "1 + 1 = (1 + 1)".
///     let localizedString = NSLocalizedString("string-interpolation",
///                                             value: "1 + 1 = \(1 + 1)"
///                                             comment: "A math equation.")
///
/// To dynamically insert values within localized strings, set `value` to a
/// format string, and use `String.localizedStringWithFormat(_:_:)` to insert
/// those values.
///
///     // Translators will see "1 + 1 = %d" (they know what "%d" means).
///     // International users will see a localization of "1 + 1 = 2".
///     let format = NSLocalizedString("string-literal",
///                                    value: "1 + 1 = %d",
///                                    comment: "A math equation.")
///     let localizedString = String.localizedStringWithFormat(format, (1 + 1))
///
/// Multiline string literals are technically supported, but will result in
/// unexpected behavior during internationalization. A newline will be inserted
/// before and after the body of text within the string, and translators will
/// likely preserve those in their internationalizations.
///
/// To preserve some of the aesthetics of having newlines in the string mirrored
/// in their code representation, string literal concatenation with the `+`
/// operator can be used.
///
///     NSLocalizedString("multiline-string-literal",
///                       value: """
///     This multiline string literal won't work as expected.
///     An extra newline is added to the beginning and end of the string.
///     """,
///                       comment: "The description of a sample of code.")
///
///     NSLocalizedString("string-literal-contatenation",
///                       value: "This string literal concatenated with"
///                            + "this other string literal works just fine.",
///                       comment: "The description of a sample of code.")
///
/// Since comments aren't localized, multiline string literals can be safely
/// used with `comment`.
///
/// Work with Manually Managed Strings
/// ----------------------------------
///
/// If having Xcode generate strings files from code isn't desired behavior,
/// call `Bundle.localizedString(forKey:value:table:)` instead.
///
///     let greeting = Bundle.localizedString(forKey: "program-greeting",
///                                           value: "Hello, World!",
///                                           table: "Localization")
///
/// However, this requires the manual creation and management of that table's
/// strings file.
///
///     /* Localization.strings */
///
///     /* A friendly greeting to the user when the program starts. */
///     "program-greeting" = "Hello, World!";
///
/// - note: Although `NSLocalizedString(_:tableName:bundle:value:comment:)`
/// and `Bundle.localizedString(forKey:value:table:)` can be used in a project
/// at the same time, data from manually managed strings files will be
/// overwritten by Xcode when their table is also used to look up localized
/// strings with `NSLocalizedString(_:tableName:bundle:value:comment:)`.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func NSLocalizedString(_ key: String, tableName: String? = nil, bundle: Bundle = Bundle.main, value: String = "", comment: String) -> String

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func NSLog(_ format: String, _ args: any CVarArg...)

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public let NSNotFound: Int

/**
 `Notification` encapsulates information broadcast to observers via a `NotificationCenter`.
*/
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct Notification : ReferenceConvertible, Equatable, Hashable {

    public typealias ReferenceType = NSNotification

    /// A tag identifying the notification.
    public var name: Notification.Name

    /// An object that the poster wishes to send to observers.
    ///
    /// Typically this is the object that posted the notification.
    public var object: Any?

    /// Storage for values or objects related to this notification.
    public var userInfo: [AnyHashable : Any]?

    /// Initialize a new `Notification`.
    ///
    /// The default value for `userInfo` is nil.
    public init(name: Notification.Name, object: Any? = nil, userInfo: [AnyHashable : Any]? = nil)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    public typealias Name = NSNotification.Name

    /// Compare two notifications for equality.
    public static func == (lhs: Notification, rhs: Notification) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Notification : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public enum NumberFormatStyleConfiguration {

    public typealias RoundingRule = FloatingPointRoundingRule

    public struct Grouping : Codable, Hashable, CustomStringConvertible, Sendable {

        public static var automatic: NumberFormatStyleConfiguration.Grouping { get }

        public static var never: NumberFormatStyleConfiguration.Grouping { get }

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NumberFormatStyleConfiguration.Grouping, b: NumberFormatStyleConfiguration.Grouping) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct Precision : Codable, Hashable, Sendable {

        public static func significantDigits<R>(_ limits: R) -> NumberFormatStyleConfiguration.Precision where R : RangeExpression, R.Bound == Int

        public static func significantDigits(_ digits: Int) -> NumberFormatStyleConfiguration.Precision

        public static func integerAndFractionLength<R1, R2>(integerLimits: R1, fractionLimits: R2) -> NumberFormatStyleConfiguration.Precision where R1 : RangeExpression, R2 : RangeExpression, R1.Bound == Int, R2.Bound == Int

        public static func integerAndFractionLength(integer: Int, fraction: Int) -> NumberFormatStyleConfiguration.Precision

        public static func integerLength<R>(_ limits: R) -> NumberFormatStyleConfiguration.Precision where R : RangeExpression

        public static func integerLength(_ length: Int) -> NumberFormatStyleConfiguration.Precision

        public static func fractionLength<R>(_ limits: R) -> NumberFormatStyleConfiguration.Precision where R : RangeExpression, R.Bound == Int

        public static func fractionLength(_ length: Int) -> NumberFormatStyleConfiguration.Precision

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NumberFormatStyleConfiguration.Precision, b: NumberFormatStyleConfiguration.Precision) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct DecimalSeparatorDisplayStrategy : Codable, Hashable, CustomStringConvertible, Sendable {

        public static var automatic: NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy { get }

        public static var always: NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy { get }

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy, b: NumberFormatStyleConfiguration.DecimalSeparatorDisplayStrategy) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct SignDisplayStrategy : Codable, Hashable, CustomStringConvertible, Sendable {

        public static var automatic: NumberFormatStyleConfiguration.SignDisplayStrategy { get }

        public static var never: NumberFormatStyleConfiguration.SignDisplayStrategy { get }

        public static func always(includingZero: Bool = true) -> NumberFormatStyleConfiguration.SignDisplayStrategy

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NumberFormatStyleConfiguration.SignDisplayStrategy, b: NumberFormatStyleConfiguration.SignDisplayStrategy) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct Notation : Codable, Hashable, CustomStringConvertible, Sendable {

        public static var scientific: NumberFormatStyleConfiguration.Notation { get }

        public static var automatic: NumberFormatStyleConfiguration.Notation { get }

        /// Formats the number with localized prefixes or suffixes corresponding to powers of ten. Rounds to integer while showing at least two significant digits by default.
        /// For example, "42.3K" for 42300 for the "en_US" locale.
        /// - note: We do not support parsing a number string containing localized prefixes or suffixes.
        public static var compactName: NumberFormatStyleConfiguration.Notation { get }

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NumberFormatStyleConfiguration.Notation, b: NumberFormatStyleConfiguration.Notation) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
public protocol ObjectiveCConvertibleAttributedStringKey : AttributedStringKey {

    associatedtype ObjectiveCValue : NSObject

    static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue

    static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == NSNumber, Self.Value : RawRepresentable, Self.Value.RawValue == Int {

    public static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue

    public static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension ObjectiveCConvertibleAttributedStringKey where Self.ObjectiveCValue == NSString, Self.Value : RawRepresentable, Self.Value.RawValue == String {

    public static func objectiveCValue(for value: Self.Value) throws -> Self.ObjectiveCValue

    public static func value(for object: Self.ObjectiveCValue) throws -> Self.Value
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias ObservableObject = ObservableObject

/// Describes an error in the POSIX error domain.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct POSIXError {

    /// The domain of the error.
    public static var errorDomain: String { get }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// The type of an error code.
    public typealias Code = POSIXErrorCode
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension POSIXError {

    /// Operation not permitted.
    public static var EPERM: POSIXErrorCode { get }

    /// No such file or directory.
    public static var ENOENT: POSIXErrorCode { get }

    /// No such process.
    public static var ESRCH: POSIXErrorCode { get }

    /// Interrupted system call.
    public static var EINTR: POSIXErrorCode { get }

    /// Input/output error.
    public static var EIO: POSIXErrorCode { get }

    /// Device not configured.
    public static var ENXIO: POSIXErrorCode { get }

    /// Argument list too long.
    public static var E2BIG: POSIXErrorCode { get }

    /// Exec format error.
    public static var ENOEXEC: POSIXErrorCode { get }

    /// Bad file descriptor.
    public static var EBADF: POSIXErrorCode { get }

    /// No child processes.
    public static var ECHILD: POSIXErrorCode { get }

    /// Resource deadlock avoided.
    public static var EDEADLK: POSIXErrorCode { get }

    /// Cannot allocate memory.
    public static var ENOMEM: POSIXErrorCode { get }

    /// Permission denied.
    public static var EACCES: POSIXErrorCode { get }

    /// Bad address.
    public static var EFAULT: POSIXErrorCode { get }

    /// Block device required.
    public static var ENOTBLK: POSIXErrorCode { get }

    /// Device / Resource busy.
    public static var EBUSY: POSIXErrorCode { get }

    /// File exists.
    public static var EEXIST: POSIXErrorCode { get }

    /// Cross-device link.
    public static var EXDEV: POSIXErrorCode { get }

    /// Operation not supported by device.
    public static var ENODEV: POSIXErrorCode { get }

    /// Not a directory.
    public static var ENOTDIR: POSIXErrorCode { get }

    /// Is a directory.
    public static var EISDIR: POSIXErrorCode { get }

    /// Invalid argument.
    public static var EINVAL: POSIXErrorCode { get }

    /// Too many open files in system.
    public static var ENFILE: POSIXErrorCode { get }

    /// Too many open files.
    public static var EMFILE: POSIXErrorCode { get }

    /// Inappropriate ioctl for device.
    public static var ENOTTY: POSIXErrorCode { get }

    /// Text file busy.
    public static var ETXTBSY: POSIXErrorCode { get }

    /// File too large.
    public static var EFBIG: POSIXErrorCode { get }

    /// No space left on device.
    public static var ENOSPC: POSIXErrorCode { get }

    /// Illegal seek.
    public static var ESPIPE: POSIXErrorCode { get }

    /// Read-only file system.
    public static var EROFS: POSIXErrorCode { get }

    /// Too many links.
    public static var EMLINK: POSIXErrorCode { get }

    /// Broken pipe.
    public static var EPIPE: POSIXErrorCode { get }

    /// Numerical argument out of domain.
    public static var EDOM: POSIXErrorCode { get }

    /// Result too large.
    public static var ERANGE: POSIXErrorCode { get }

    /// Resource temporarily unavailable.
    public static var EAGAIN: POSIXErrorCode { get }

    /// Operation would block.
    public static var EWOULDBLOCK: POSIXErrorCode { get }

    /// Operation now in progress.
    public static var EINPROGRESS: POSIXErrorCode { get }

    /// Operation already in progress.
    public static var EALREADY: POSIXErrorCode { get }

    /// Socket operation on non-socket.
    public static var ENOTSOCK: POSIXErrorCode { get }

    /// Destination address required.
    public static var EDESTADDRREQ: POSIXErrorCode { get }

    /// Message too long.
    public static var EMSGSIZE: POSIXErrorCode { get }

    /// Protocol wrong type for socket.
    public static var EPROTOTYPE: POSIXErrorCode { get }

    /// Protocol not available.
    public static var ENOPROTOOPT: POSIXErrorCode { get }

    /// Protocol not supported.
    public static var EPROTONOSUPPORT: POSIXErrorCode { get }

    /// Socket type not supported.
    public static var ESOCKTNOSUPPORT: POSIXErrorCode { get }

    /// Operation not supported.
    public static var ENOTSUP: POSIXErrorCode { get }

    /// Protocol family not supported.
    public static var EPFNOSUPPORT: POSIXErrorCode { get }

    /// Address family not supported by protocol family.
    public static var EAFNOSUPPORT: POSIXErrorCode { get }

    /// Address already in use.
    public static var EADDRINUSE: POSIXErrorCode { get }

    /// Can't assign requested address.
    public static var EADDRNOTAVAIL: POSIXErrorCode { get }

    /// Network is down.
    public static var ENETDOWN: POSIXErrorCode { get }

    /// Network is unreachable.
    public static var ENETUNREACH: POSIXErrorCode { get }

    /// Network dropped connection on reset.
    public static var ENETRESET: POSIXErrorCode { get }

    /// Software caused connection abort.
    public static var ECONNABORTED: POSIXErrorCode { get }

    /// Connection reset by peer.
    public static var ECONNRESET: POSIXErrorCode { get }

    /// No buffer space available.
    public static var ENOBUFS: POSIXErrorCode { get }

    /// Socket is already connected.
    public static var EISCONN: POSIXErrorCode { get }

    /// Socket is not connected.
    public static var ENOTCONN: POSIXErrorCode { get }

    /// Can't send after socket shutdown.
    public static var ESHUTDOWN: POSIXErrorCode { get }

    /// Too many references: can't splice.
    public static var ETOOMANYREFS: POSIXErrorCode { get }

    /// Operation timed out.
    public static var ETIMEDOUT: POSIXErrorCode { get }

    /// Connection refused.
    public static var ECONNREFUSED: POSIXErrorCode { get }

    /// Too many levels of symbolic links.
    public static var ELOOP: POSIXErrorCode { get }

    /// File name too long.
    public static var ENAMETOOLONG: POSIXErrorCode { get }

    /// Host is down.
    public static var EHOSTDOWN: POSIXErrorCode { get }

    /// No route to host.
    public static var EHOSTUNREACH: POSIXErrorCode { get }

    /// Directory not empty.
    public static var ENOTEMPTY: POSIXErrorCode { get }

    /// Too many processes.
    public static var EPROCLIM: POSIXErrorCode { get }

    /// Too many users.
    public static var EUSERS: POSIXErrorCode { get }

    /// Disk quota exceeded.
    public static var EDQUOT: POSIXErrorCode { get }

    /// Stale NFS file handle.
    public static var ESTALE: POSIXErrorCode { get }

    /// Too many levels of remote in path.
    public static var EREMOTE: POSIXErrorCode { get }

    /// RPC struct is bad.
    public static var EBADRPC: POSIXErrorCode { get }

    /// RPC version wrong.
    public static var ERPCMISMATCH: POSIXErrorCode { get }

    /// RPC prog. not avail.
    public static var EPROGUNAVAIL: POSIXErrorCode { get }

    /// Program version wrong.
    public static var EPROGMISMATCH: POSIXErrorCode { get }

    /// Bad procedure for program.
    public static var EPROCUNAVAIL: POSIXErrorCode { get }

    /// No locks available.
    public static var ENOLCK: POSIXErrorCode { get }

    /// Function not implemented.
    public static var ENOSYS: POSIXErrorCode { get }

    /// Inappropriate file type or format.
    public static var EFTYPE: POSIXErrorCode { get }

    /// Authentication error.
    public static var EAUTH: POSIXErrorCode { get }

    /// Need authenticator.
    public static var ENEEDAUTH: POSIXErrorCode { get }

    /// Device power is off.
    public static var EPWROFF: POSIXErrorCode { get }

    /// Device error, e.g. paper out.
    public static var EDEVERR: POSIXErrorCode { get }

    /// Value too large to be stored in data type.
    public static var EOVERFLOW: POSIXErrorCode { get }

    /// Bad executable.
    public static var EBADEXEC: POSIXErrorCode { get }

    /// Bad CPU type in executable.
    public static var EBADARCH: POSIXErrorCode { get }

    /// Shared library version mismatch.
    public static var ESHLIBVERS: POSIXErrorCode { get }

    /// Malformed Macho file.
    public static var EBADMACHO: POSIXErrorCode { get }

    /// Operation canceled.
    public static var ECANCELED: POSIXErrorCode { get }

    /// Identifier removed.
    public static var EIDRM: POSIXErrorCode { get }

    /// No message of desired type.
    public static var ENOMSG: POSIXErrorCode { get }

    /// Illegal byte sequence.
    public static var EILSEQ: POSIXErrorCode { get }

    /// Attribute not found.
    public static var ENOATTR: POSIXErrorCode { get }

    /// Bad message.
    public static var EBADMSG: POSIXErrorCode { get }

    /// Reserved.
    public static var EMULTIHOP: POSIXErrorCode { get }

    /// No message available on STREAM.
    public static var ENODATA: POSIXErrorCode { get }

    /// Reserved.
    public static var ENOLINK: POSIXErrorCode { get }

    /// No STREAM resources.
    public static var ENOSR: POSIXErrorCode { get }

    /// Not a STREAM.
    public static var ENOSTR: POSIXErrorCode { get }

    /// Protocol error.
    public static var EPROTO: POSIXErrorCode { get }

    /// STREAM ioctl timeout.
    public static var ETIME: POSIXErrorCode { get }

    /// No such policy registered.
    public static var ENOPOLICY: POSIXErrorCode { get }

    /// State not recoverable.
    public static var ENOTRECOVERABLE: POSIXErrorCode { get }

    /// Previous owner died.
    public static var EOWNERDEAD: POSIXErrorCode { get }

    /// Interface output queue is full.
    public static var EQFULL: POSIXErrorCode { get }
}

/// A type that can parse a representation of a given data type.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol ParseStrategy : Decodable, Encodable, Hashable {

    /// The type of the representation describing the data.
    associatedtype ParseInput

    /// The type of the data type.
    associatedtype ParseOutput

    /// Creates an instance of the `ParseOutput` type from `value`.
    func parse(_ value: Self.ParseInput) throws -> Self.ParseOutput
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension ParseStrategy where Self == URL.ParseStrategy {

    public static var url: URL.ParseStrategy { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseStrategy where Self == Date.FormatStyle {

    public static var dateTime: Date.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseStrategy {

    public static func fixed(format: Date.FormatString, timeZone: TimeZone, locale: Locale? = nil) -> Self where Self == Date.ParseStrategy
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension ParseStrategy where Self == Date.HTTPFormatStyle {

    public static var http: Date.HTTPFormatStyle { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension ParseStrategy where Self == DateComponents.HTTPFormatStyle {

    public static var http: DateComponents.HTTPFormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseStrategy where Self == Date.ISO8601FormatStyle {

    public static var iso8601: Date.ISO8601FormatStyle { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension ParseStrategy where Self == DateComponents.ISO8601FormatStyle {

    public static var iso8601: DateComponents.ISO8601FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseStrategy where Self == PersonNameComponents.ParseStrategy {

    public static var name: PersonNameComponents.ParseStrategy { get }
}

/// A type that can convert a given data type into a representation.
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public protocol ParseableFormatStyle : FormatStyle {

    associatedtype Strategy : ParseStrategy where Self.FormatInput == Self.Strategy.ParseOutput, Self.FormatOutput == Self.Strategy.ParseInput

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    var parseStrategy: Self.Strategy { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Date.FormatStyle {

    public static var dateTime: Date.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Decimal.FormatStyle {

    public static var number: Decimal.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Decimal.FormatStyle.Percent {

    public static var percent: Decimal.FormatStyle.Percent { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Decimal.FormatStyle.Currency {

    public static func currency(code: String) -> Self
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension ParseableFormatStyle where Self == Date.HTTPFormatStyle {

    public static var http: Date.HTTPFormatStyle { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension ParseableFormatStyle where Self == DateComponents.HTTPFormatStyle {

    public static var http: DateComponents.HTTPFormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == Date.ISO8601FormatStyle {

    public static var iso8601: Date.ISO8601FormatStyle { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension ParseableFormatStyle where Self == DateComponents.ISO8601FormatStyle {

    public static var iso8601: DateComponents.ISO8601FormatStyle { get }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension ParseableFormatStyle where Self == URL.FormatStyle {

    public static var url: URL.FormatStyle { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension ParseableFormatStyle where Self == PersonNameComponents.FormatStyle {

    public static func name(style: PersonNameComponents.FormatStyle.Style) -> Self
}

@available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
public struct PersonNameComponents : ReferenceConvertible, Hashable, Equatable, Sendable {

    public typealias ReferenceType = NSPersonNameComponents

    public init()

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public init(namePrefix: String? = nil, givenName: String? = nil, middleName: String? = nil, familyName: String? = nil, nameSuffix: String? = nil, nickname: String? = nil, phoneticRepresentation: PersonNameComponents? = nil)

    public var namePrefix: String?

    public var givenName: String?

    public var middleName: String?

    public var familyName: String?

    public var nameSuffix: String?

    public var nickname: String?

    public var phoneticRepresentation: PersonNameComponents?

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public static func == (lhs: PersonNameComponents, rhs: PersonNameComponents) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
extension PersonNameComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
extension PersonNameComponents : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents {

    public struct FormatStyle : FormatStyle, Sendable {

        public var style: PersonNameComponents.FormatStyle.Style

        public var locale: Locale

        public var attributed: PersonNameComponents.AttributedStyle { get }

        public init(style: PersonNameComponents.FormatStyle.Style = .medium, locale: Locale = .autoupdatingCurrent)

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> PersonNameComponents.FormatStyle

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ value: PersonNameComponents) -> String

        public enum Style : Int, Codable, Hashable, Sendable {

            case short

            case medium

            case long

            case abbreviated

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: Int)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
            public typealias RawValue = Int

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: Int { get }
        }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PersonNameComponents.FormatStyle, b: PersonNameComponents.FormatStyle) -> Bool

        /// The type of data to format.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatInput = PersonNameComponents

        /// The type of the formatted data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatOutput = String

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct AttributedStyle : FormatStyle, Sendable {

        public var style: PersonNameComponents.FormatStyle.Style

        public var locale: Locale

        public init(style: PersonNameComponents.FormatStyle.Style = .medium, locale: Locale = .autoupdatingCurrent)

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ value: PersonNameComponents) -> AttributedString

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> PersonNameComponents.AttributedStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PersonNameComponents.AttributedStyle, b: PersonNameComponents.AttributedStyle) -> Bool

        /// The type of data to format.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatInput = PersonNameComponents

        /// The type of the formatted data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias FormatOutput = AttributedString

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents {

    public struct ParseStrategy : ParseStrategy, Sendable {

        public init()

        /// Creates an instance of the `ParseOutput` type from `value`.
        public func parse(_ value: String) throws -> PersonNameComponents

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PersonNameComponents.ParseStrategy, b: PersonNameComponents.ParseStrategy) -> Bool

        /// The type of the representation describing the data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias ParseInput = String

        /// The type of the data type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias ParseOutput = PersonNameComponents

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents {

    public func formatted<S>(_ style: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == PersonNameComponents

    public func formatted() -> String

    public init<S>(_ value: S.ParseInput, strategy: S) throws where S : ParseStrategy, S.ParseOutput == PersonNameComponents

    public init(_ value: String) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents.FormatStyle : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: PersonNameComponents.ParseStrategy { get }

    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias Strategy = PersonNameComponents.ParseStrategy
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension PersonNameComponents.FormatStyle.Style : RawRepresentable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct Predicate<each Input> : Sendable {

    public let expression: any StandardPredicateExpression<Bool>

    public let variable: (repeat PredicateExpressions.Variable<each Input>)

    public init(_ builder: (repeat PredicateExpressions.Variable<each Input>) -> any StandardPredicateExpression<Bool>)

    public func evaluate(_ input: repeat each Input) throws -> Bool
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Predicate : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Predicate : CodableWithConfiguration {

    public typealias EncodingConfiguration = PredicateCodableConfiguration

    public typealias DecodingConfiguration = PredicateCodableConfiguration

    public func encode(to encoder: any Encoder, configuration: Predicate<repeat each Input>.EncodingConfiguration) throws

    public init(from decoder: any Decoder, configuration: Predicate<repeat each Input>.DecodingConfiguration) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Predicate {

    public static var `true`: Predicate<repeat each Input> { get }

    public static var `false`: Predicate<repeat each Input> { get }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Predicate : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension Predicate : CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@freestanding(expression) public macro Predicate<each Input>(_ body: (repeat each Input) -> Bool) -> Predicate<repeat each Input> = #externalMacro(module: "FoundationMacros", type: "PredicateMacro")

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct PredicateBindings {

    public init<each T>(_ value: repeat (PredicateExpressions.Variable<each T>, each T))

    public subscript<T>(variable: PredicateExpressions.Variable<T>) -> T?

    public func binding<T>(_ variable: PredicateExpressions.Variable<T>, to value: T) -> PredicateBindings
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct PredicateCodableConfiguration : Sendable, CustomDebugStringConvertible {

    public init()

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    public mutating func allowType(_ type: any Any.Type, identifier: String? = nil)

    public mutating func disallowType(_ type: any Any.Type)

    public mutating func allowPartialType(_ type: any Any.Type, identifier: String)

    public mutating func disallowPartialType(_ type: any Any.Type)

    public mutating func allowKeyPath(_ keyPath: any AnyKeyPath & Sendable, identifier: String)

    public mutating func disallowKeyPath(_ keyPath: any AnyKeyPath & Sendable)

    public mutating func allowKeyPathsForPropertiesProvided<T>(by type: T.Type, recursive: Bool = false) where T : PredicateCodableKeyPathProviding

    public mutating func disallowKeyPathsForPropertiesProvided<T>(by type: T.Type, recursive: Bool = false) where T : PredicateCodableKeyPathProviding

    public mutating func allow(_ other: PredicateCodableConfiguration)
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateCodableConfiguration {

    public static let standardConfiguration: PredicateCodableConfiguration
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol PredicateCodableKeyPathProviding {

    @preconcurrency static var predicateCodableKeyPaths: [String : any PartialKeyPath<Self> & Sendable] { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct PredicateError : Error, Hashable, CustomDebugStringConvertible {

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: PredicateError, rhs: PredicateError) -> Bool

    public static let undefinedVariable: PredicateError

    public static let forceUnwrapFailure: PredicateError

    public static let forceCastFailure: PredicateError

    public static let invalidInput: PredicateError

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol PredicateExpression<Output> {

    associatedtype Output

    func evaluate(_ bindings: PredicateBindings) throws -> Self.Output
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
@frozen public enum PredicateExpressions {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct StringLocalizedStandardContains<Root, Other> : PredicateExpression where Root : PredicateExpression, Other : PredicateExpression, Root.Output : StringProtocol, Other.Output : StringProtocol {

        public typealias Output = Bool

        public let root: Root

        public let other: Other

        public init(root: Root, other: Other)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.StringLocalizedStandardContains<Root, Other>.Output
    }

    public static func build_localizedStandardContains<Root, Other>(_ root: Root, _ other: Other) -> PredicateExpressions.StringLocalizedStandardContains<Root, Other> where Root : PredicateExpression, Other : PredicateExpression, Root.Output : StringProtocol, Other.Output : StringProtocol
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct StringLocalizedCompare<Root, Other> : PredicateExpression where Root : PredicateExpression, Other : PredicateExpression, Root.Output : StringProtocol, Other.Output : StringProtocol {

        public typealias Output = ComparisonResult

        public let root: Root

        public let other: Other

        public init(root: Root, other: Other)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.StringLocalizedCompare<Root, Other>.Output
    }

    public static func build_localizedCompare<Root, Other>(_ root: Root, _ other: Other) -> PredicateExpressions.StringLocalizedCompare<Root, Other> where Root : PredicateExpression, Other : PredicateExpression, Root.Output : StringProtocol, Other.Output : StringProtocol
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct SequenceMaximum<Elements> : PredicateExpression where Elements : PredicateExpression, Elements.Output : Sequence, Elements.Output.Element : Comparable {

        public typealias Output = Elements.Output.Element?

        public let elements: Elements

        public init(elements: Elements)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.SequenceMaximum<Elements>.Output
    }

    public static func build_max<Elements>(_ elements: Elements) -> PredicateExpressions.SequenceMaximum<Elements> where Elements : PredicateExpression, Elements.Output : Sequence, Elements.Output.Element : Comparable
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct SequenceMinimum<Elements> : PredicateExpression where Elements : PredicateExpression, Elements.Output : Sequence, Elements.Output.Element : Comparable {

        public typealias Output = Elements.Output.Element?

        public let elements: Elements

        public init(elements: Elements)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.SequenceMinimum<Elements>.Output
    }

    public static func build_min<Elements>(_ elements: Elements) -> PredicateExpressions.SequenceMinimum<Elements> where Elements : PredicateExpression, Elements.Output : Sequence, Elements.Output.Element : Comparable
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public enum ArithmeticOperator : Codable, Sendable {

        case add

        case subtract

        case multiply

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PredicateExpressions.ArithmeticOperator, b: PredicateExpressions.ArithmeticOperator) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct Arithmetic<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Numeric, LHS.Output == RHS.Output {

        public typealias Output = LHS.Output

        public let op: PredicateExpressions.ArithmeticOperator

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS, op: PredicateExpressions.ArithmeticOperator)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.Arithmetic<LHS, RHS>.Output
    }

    public static func build_Arithmetic<LHS, RHS>(lhs: LHS, rhs: RHS, op: PredicateExpressions.ArithmeticOperator) -> PredicateExpressions.Arithmetic<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Numeric, LHS.Output == RHS.Output
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct CollectionIndexSubscript<Wrapped, Index> : PredicateExpression where Wrapped : PredicateExpression, Index : PredicateExpression, Wrapped.Output : Collection, Index.Output == Wrapped.Output.Index {

        public typealias Output = Wrapped.Output.Element

        public let wrapped: Wrapped

        public let index: Index

        public init(wrapped: Wrapped, index: Index)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.CollectionIndexSubscript<Wrapped, Index>.Output
    }

    public static func build_subscript<Wrapped, Index>(_ wrapped: Wrapped, _ index: Index) -> PredicateExpressions.CollectionIndexSubscript<Wrapped, Index> where Wrapped : PredicateExpression, Index : PredicateExpression, Wrapped.Output : Collection, Index.Output == Wrapped.Output.Index
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct CollectionRangeSubscript<Wrapped, Range> : PredicateExpression where Wrapped : PredicateExpression, Range : PredicateExpression, Wrapped.Output : Collection, Range.Output == Range<Wrapped.Output.Index> {

        public typealias Output = Wrapped.Output.SubSequence

        public let wrapped: Wrapped

        public let range: Range

        public init(wrapped: Wrapped, range: Range)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.CollectionRangeSubscript<Wrapped, Range>.Output
    }

    public static func build_subscript<Wrapped, Range>(_ wrapped: Wrapped, _ range: Range) -> PredicateExpressions.CollectionRangeSubscript<Wrapped, Range> where Wrapped : PredicateExpression, Range : PredicateExpression, Wrapped.Output : Collection, Range.Output == Range<Wrapped.Output.Index>
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct CollectionContainsCollection<Base, Other> : PredicateExpression where Base : PredicateExpression, Other : PredicateExpression, Base.Output : Collection, Other.Output : Collection, Base.Output.Element : Equatable, Base.Output.Element == Other.Output.Element {

        public typealias Output = Bool

        public let base: Base

        public let other: Other

        public init(base: Base, other: Other)

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public static func build_contains<Base, Other>(_ base: Base, _ other: Other) -> PredicateExpressions.CollectionContainsCollection<Base, Other> where Base : PredicateExpression, Other : PredicateExpression, Base.Output : Collection, Other.Output : Collection, Base.Output.Element : Equatable, Base.Output.Element == Other.Output.Element
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public enum ComparisonOperator : Codable, Sendable {

        case lessThan

        case lessThanOrEqual

        case greaterThan

        case greaterThanOrEqual

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PredicateExpressions.ComparisonOperator, b: PredicateExpressions.ComparisonOperator) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct Comparison<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Comparable, LHS.Output == RHS.Output {

        public typealias Output = Bool

        public let op: PredicateExpressions.ComparisonOperator

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS, op: PredicateExpressions.ComparisonOperator)

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public static func build_Comparison<LHS, RHS>(lhs: LHS, rhs: RHS, op: PredicateExpressions.ComparisonOperator) -> PredicateExpressions.Comparison<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Comparable, LHS.Output == RHS.Output
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct Conditional<Test, If, Else> : PredicateExpression where Test : PredicateExpression, If : PredicateExpression, Else : PredicateExpression, Test.Output == Bool, If.Output == Else.Output {

        public typealias Output = If.Output

        public let test: Test

        public let trueBranch: If

        public let falseBranch: Else

        public init(test: Test, trueBranch: If, falseBranch: Else)

        public func evaluate(_ bindings: PredicateBindings) throws -> If.Output
    }

    public static func build_Conditional<Test, If, Else>(_ test: Test, _ trueBranch: If, _ falseBranch: Else) -> PredicateExpressions.Conditional<Test, If, Else> where Test : PredicateExpression, If : PredicateExpression, Else : PredicateExpression, Test.Output == Bool, If.Output == Else.Output
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct Conjunction<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output == Bool, RHS.Output == Bool {

        public typealias Output = Bool

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public static func build_Conjunction<LHS, RHS>(lhs: LHS, rhs: RHS) -> PredicateExpressions.Conjunction<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output == Bool, RHS.Output == Bool
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct DictionaryKeySubscript<Wrapped, Key, Value> : PredicateExpression where Wrapped : PredicateExpression, Key : PredicateExpression, Wrapped.Output == [Key.Output : Value], Key.Output : Hashable {

        public typealias Output = Value?

        public let wrapped: Wrapped

        public let key: Key

        public init(wrapped: Wrapped, key: Key)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.DictionaryKeySubscript<Wrapped, Key, Value>.Output
    }

    public static func build_subscript<Wrapped, Key, Value>(_ wrapped: Wrapped, _ key: Key) -> PredicateExpressions.DictionaryKeySubscript<Wrapped, Key, Value> where Wrapped : PredicateExpression, Key : PredicateExpression, Wrapped.Output == [Key.Output : Value], Key.Output : Hashable
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct DictionaryKeyDefaultValueSubscript<Wrapped, Key, Default> : PredicateExpression where Wrapped : PredicateExpression, Key : PredicateExpression, Default : PredicateExpression, Wrapped.Output == [Key.Output : Default.Output], Key.Output : Hashable {

        public typealias Output = Default.Output

        public let wrapped: Wrapped

        public let key: Key

        public let `default`: Default

        public init(wrapped: Wrapped, key: Key, default: Default)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.DictionaryKeyDefaultValueSubscript<Wrapped, Key, Default>.Output
    }

    public static func build_subscript<Wrapped, Key, Default>(_ wrapped: Wrapped, _ key: Key, default: Default) -> PredicateExpressions.DictionaryKeyDefaultValueSubscript<Wrapped, Key, Default> where Wrapped : PredicateExpression, Key : PredicateExpression, Default : PredicateExpression, Wrapped.Output == [Key.Output : Default.Output], Key.Output : Hashable
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct Disjunction<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output == Bool, RHS.Output == Bool {

        public typealias Output = Bool

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public static func build_Disjunction<LHS, RHS>(lhs: LHS, rhs: RHS) -> PredicateExpressions.Disjunction<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output == Bool, RHS.Output == Bool
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct IntDivision<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : BinaryInteger, LHS.Output == RHS.Output {

        public typealias Output = LHS.Output

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.IntDivision<LHS, RHS>.Output
    }

    public struct IntRemainder<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : BinaryInteger, LHS.Output == RHS.Output {

        public typealias Output = LHS.Output

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.IntRemainder<LHS, RHS>.Output
    }

    public struct FloatDivision<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : FloatingPoint, LHS.Output == RHS.Output {

        public typealias Output = LHS.Output

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.FloatDivision<LHS, RHS>.Output
    }

    public static func build_Division<LHS, RHS>(lhs: LHS, rhs: RHS) -> PredicateExpressions.IntDivision<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : BinaryInteger, LHS.Output == RHS.Output

    public static func build_Division<LHS, RHS>(lhs: LHS, rhs: RHS) -> PredicateExpressions.FloatDivision<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : FloatingPoint, LHS.Output == RHS.Output

    public static func build_Remainder<LHS, RHS>(lhs: LHS, rhs: RHS) -> PredicateExpressions.IntRemainder<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : BinaryInteger, LHS.Output == RHS.Output
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct Equal<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Equatable, LHS.Output == RHS.Output {

        public typealias Output = Bool

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public static func build_Equal<LHS, RHS>(lhs: LHS, rhs: RHS) -> PredicateExpressions.Equal<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Equatable, LHS.Output == RHS.Output
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public struct ExpressionEvaluate<Transformation, each Input, Output> : PredicateExpression where Transformation : PredicateExpression, repeat each Input : PredicateExpression, Transformation.Output == Expression<repeat (each Input).Output, Output> {

        public let expression: Transformation

        public let input: (repeat each Input)

        public init(expression: Transformation, input: repeat each Input)

        public func evaluate(_ bindings: PredicateBindings) throws -> Output
    }

    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
    public static func build_evaluate<Transformation, each Input, Output>(_ expression: Transformation, _ input: repeat each Input) -> PredicateExpressions.ExpressionEvaluate<Transformation, repeat each Input, Output> where Transformation : PredicateExpression, repeat each Input : PredicateExpression, Transformation.Output == Expression<repeat (each Input).Output, Output>
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct Filter<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Sequence, RHS.Output == Bool {

        public typealias Element = LHS.Output.Element

        public typealias Output = [PredicateExpressions.Filter<LHS, RHS>.Element]

        public let sequence: LHS

        public let filter: RHS

        public let variable: PredicateExpressions.Variable<PredicateExpressions.Filter<LHS, RHS>.Element>

        public init(_ sequence: LHS, _ builder: (PredicateExpressions.Variable<PredicateExpressions.Filter<LHS, RHS>.Element>) -> RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.Filter<LHS, RHS>.Output
    }

    public static func build_filter<LHS, RHS>(_ lhs: LHS, _ builder: (PredicateExpressions.Variable<LHS.Output.Element>) -> RHS) -> PredicateExpressions.Filter<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Sequence, RHS.Output == Bool
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct NotEqual<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Equatable, LHS.Output == RHS.Output {

        public typealias Output = Bool

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public static func build_NotEqual<LHS, RHS>(lhs: LHS, rhs: RHS) -> PredicateExpressions.NotEqual<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Equatable, LHS.Output == RHS.Output
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct Negation<Wrapped> : PredicateExpression where Wrapped : PredicateExpression, Wrapped.Output == Bool {

        public typealias Output = Bool

        public let wrapped: Wrapped

        public init(_ wrapped: Wrapped)

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public static func build_Negation<T>(_ wrapped: T) -> PredicateExpressions.Negation<T> where T : PredicateExpression, T.Output == Bool
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct OptionalFlatMap<LHS, Wrapped, RHS, Result> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output == Wrapped? {

        public typealias Output = Result?

        public let wrapped: LHS

        public let transform: RHS

        public let variable: PredicateExpressions.Variable<Wrapped>

        public init(_ wrapped: LHS, _ builder: (PredicateExpressions.Variable<Wrapped>) -> RHS) where Result == RHS.Output

        public init(_ wrapped: LHS, _ builder: (PredicateExpressions.Variable<Wrapped>) -> RHS) where RHS.Output == Result?

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.OptionalFlatMap<LHS, Wrapped, RHS, Result>.Output
    }

    public static func build_flatMap<LHS, RHS, Wrapped, Result>(_ wrapped: LHS, _ builder: (PredicateExpressions.Variable<Wrapped>) -> RHS) -> PredicateExpressions.OptionalFlatMap<LHS, Wrapped, RHS, Result> where LHS : PredicateExpression, RHS : PredicateExpression, Result == RHS.Output, LHS.Output == Wrapped?

    public static func build_flatMap<LHS, RHS, Wrapped, Result>(_ wrapped: LHS, _ builder: (PredicateExpressions.Variable<Wrapped>) -> RHS) -> PredicateExpressions.OptionalFlatMap<LHS, Wrapped, RHS, Result> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output == Wrapped?, RHS.Output == Result?

    public struct NilCoalesce<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output == RHS.Output? {

        public typealias Output = RHS.Output

        public let lhs: LHS

        public let rhs: RHS

        public init(lhs: LHS, rhs: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.NilCoalesce<LHS, RHS>.Output
    }

    public static func build_NilCoalesce<LHS, RHS>(lhs: LHS, rhs: RHS) -> PredicateExpressions.NilCoalesce<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output == RHS.Output?

    public struct ForcedUnwrap<Inner, Wrapped> : PredicateExpression where Inner : PredicateExpression, Inner.Output == Wrapped? {

        public typealias Output = Wrapped

        public let inner: Inner

        public init(_ inner: Inner)

        public func evaluate(_ bindings: PredicateBindings) throws -> Wrapped
    }

    public static func build_ForcedUnwrap<Inner, Wrapped>(_ inner: Inner) -> PredicateExpressions.ForcedUnwrap<Inner, Wrapped> where Inner : PredicateExpression, Inner.Output == Wrapped?
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct NilLiteral<Wrapped> : StandardPredicateExpression, Codable, Sendable {

        public typealias Output = Wrapped?

        public init()

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.NilLiteral<Wrapped>.Output

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public static func build_NilLiteral<Wrapped>() -> PredicateExpressions.NilLiteral<Wrapped>
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    @available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
    public struct PredicateEvaluate<Condition, each Input> : PredicateExpression where Condition : PredicateExpression, repeat each Input : PredicateExpression, Condition.Output == Predicate<repeat (each Input).Output> {

        public typealias Output = Bool

        public let predicate: Condition

        public let input: (repeat each Input)

        public init(predicate: Condition, input: repeat each Input)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.PredicateEvaluate<Condition, repeat each Input>.Output
    }

    @available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
    public static func build_evaluate<Condition, each Input>(_ predicate: Condition, _ input: repeat each Input) -> PredicateExpressions.PredicateEvaluate<Condition, repeat each Input> where Condition : PredicateExpression, repeat each Input : PredicateExpression, Condition.Output == Predicate<repeat (each Input).Output>
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct Range<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Comparable, LHS.Output == RHS.Output {

        public typealias Output = Range<LHS.Output>

        public let lower: LHS

        public let upper: RHS

        public init(lower: LHS, upper: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> Range<LHS.Output>
    }

    public static func build_Range<LHS, RHS>(lower: LHS, upper: RHS) -> PredicateExpressions.Range<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Comparable, LHS.Output == RHS.Output
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct ClosedRange<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Comparable, LHS.Output == RHS.Output {

        public typealias Output = ClosedRange<LHS.Output>

        public let lower: LHS

        public let upper: RHS

        public init(lower: LHS, upper: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> ClosedRange<LHS.Output>
    }

    public static func build_ClosedRange<LHS, RHS>(lower: LHS, upper: RHS) -> PredicateExpressions.ClosedRange<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Comparable, LHS.Output == RHS.Output
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct RangeExpressionContains<RangeExpression, Element> : PredicateExpression where RangeExpression : PredicateExpression, Element : PredicateExpression, RangeExpression.Output : RangeExpression, Element.Output == RangeExpression.Output.Bound {

        public typealias Output = Bool

        public let range: RangeExpression

        public let element: Element

        public init(range: RangeExpression, element: Element)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.RangeExpressionContains<RangeExpression, Element>.Output
    }

    public static func build_contains<RangeExpression, Element>(_ range: RangeExpression, _ element: Element) -> PredicateExpressions.RangeExpressionContains<RangeExpression, Element> where RangeExpression : PredicateExpression, Element : PredicateExpression, RangeExpression.Output : RangeExpression, Element.Output == RangeExpression.Output.Bound
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension PredicateExpressions {

    public struct StringContainsRegex<Subject, Regex> : PredicateExpression, CustomStringConvertible where Subject : PredicateExpression, Regex : PredicateExpression, Subject.Output : BidirectionalCollection, Regex.Output : RegexComponent, Subject.Output.SubSequence == Substring {

        public typealias Output = Bool

        public let subject: Subject

        public let regex: Regex

        public init(subject: Subject, regex: Regex)

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public static func build_contains<Subject, Regex>(_ subject: Subject, _ regex: Regex) -> PredicateExpressions.StringContainsRegex<Subject, Regex> where Subject : PredicateExpression, Regex : PredicateExpression, Subject.Output : BidirectionalCollection, Regex.Output : RegexComponent, Subject.Output.SubSequence == Substring
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension PredicateExpressions {

    public struct PredicateRegex : Sendable, Codable, RegexComponent, CustomStringConvertible {

        public let stringRepresentation: String

        /// The regular expression represented by this component.
        public var regex: Regex<AnyRegexOutput> { get }

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        public init?(_ component: some RegexComponent)

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// The output type for this regular expression.
        ///
        /// A `Regex` instance's output type depends on whether the `Regex` has
        /// captures and how it is created.
        ///
        /// - A `Regex` created from a string using the ``init(_:)`` initializer
        ///   has an output type of ``AnyRegexOutput``, whether it has captures or
        ///   not.
        /// - A `Regex` without captures created from a regex literal, the
        ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
        ///   `Substring` output type, where the substring is the portion of the
        ///   string that was matched.
        /// - A `Regex` with captures created from a regex literal or the
        ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
        ///   type. The first component of the tuple is the full portion of the string
        ///   that was matched, with the remaining components holding the captures.
        @available(iOS 18, tvOS 18, watchOS 11, macOS 15, *)
        public typealias RegexOutput = AnyRegexOutput
    }

    public static func build_Arg(_ component: some RegexComponent) -> PredicateExpressions.Value<PredicateExpressions.PredicateRegex>
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct SequenceContains<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Sequence, RHS.Output : Equatable, RHS.Output == LHS.Output.Element {

        public typealias Output = Bool

        public let sequence: LHS

        public let element: RHS

        public init(sequence: LHS, element: RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public struct SequenceContainsWhere<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Sequence, RHS.Output == Bool {

        public typealias Element = LHS.Output.Element

        public typealias Output = Bool

        public let sequence: LHS

        public let test: RHS

        public let variable: PredicateExpressions.Variable<PredicateExpressions.SequenceContainsWhere<LHS, RHS>.Element>

        public init(_ sequence: LHS, builder: (PredicateExpressions.Variable<PredicateExpressions.SequenceContainsWhere<LHS, RHS>.Element>) -> RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.SequenceContainsWhere<LHS, RHS>.Output
    }

    public struct SequenceAllSatisfy<LHS, RHS> : PredicateExpression where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Sequence, RHS.Output == Bool {

        public typealias Element = LHS.Output.Element

        public typealias Output = Bool

        public let sequence: LHS

        public let test: RHS

        public let variable: PredicateExpressions.Variable<PredicateExpressions.SequenceAllSatisfy<LHS, RHS>.Element>

        public init(_ sequence: LHS, builder: (PredicateExpressions.Variable<PredicateExpressions.SequenceAllSatisfy<LHS, RHS>.Element>) -> RHS)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.SequenceAllSatisfy<LHS, RHS>.Output
    }

    public struct SequenceStartsWith<Base, Prefix> : PredicateExpression where Base : PredicateExpression, Prefix : PredicateExpression, Base.Output : Sequence, Prefix.Output : Sequence, Base.Output.Element : Equatable, Base.Output.Element == Prefix.Output.Element {

        public typealias Output = Bool

        public let base: Base

        public let prefix: Prefix

        public init(base: Base, prefix: Prefix)

        public func evaluate(_ bindings: PredicateBindings) throws -> Bool
    }

    public static func build_contains<LHS, RHS>(_ lhs: LHS, _ rhs: RHS) -> PredicateExpressions.SequenceContains<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Sequence, RHS.Output : Equatable, RHS.Output == LHS.Output.Element

    public static func build_contains<LHS, RHS>(_ lhs: LHS, where builder: (PredicateExpressions.Variable<LHS.Output.Element>) -> RHS) -> PredicateExpressions.SequenceContainsWhere<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Sequence, RHS.Output == Bool

    public static func build_allSatisfy<LHS, RHS>(_ lhs: LHS, _ builder: (PredicateExpressions.Variable<LHS.Output.Element>) -> RHS) -> PredicateExpressions.SequenceAllSatisfy<LHS, RHS> where LHS : PredicateExpression, RHS : PredicateExpression, LHS.Output : Sequence, RHS.Output == Bool

    public static func build_starts<Base, Prefix>(_ base: Base, with prefix: Prefix) -> PredicateExpressions.SequenceStartsWith<Base, Prefix> where Base : PredicateExpression, Prefix : PredicateExpression, Base.Output : Sequence, Prefix.Output : Sequence, Base.Output.Element : Equatable, Base.Output.Element == Prefix.Output.Element
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct StringCaseInsensitiveCompare<Root, Other> : PredicateExpression where Root : PredicateExpression, Other : PredicateExpression, Root.Output : StringProtocol, Other.Output : StringProtocol {

        public typealias Output = ComparisonResult

        public let root: Root

        public let other: Other

        public init(root: Root, other: Other)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.StringCaseInsensitiveCompare<Root, Other>.Output
    }

    public static func build_caseInsensitiveCompare<Root, Other>(_ root: Root, _ other: Other) -> PredicateExpressions.StringCaseInsensitiveCompare<Root, Other> where Root : PredicateExpression, Other : PredicateExpression, Root.Output : StringProtocol, Other.Output : StringProtocol
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct ConditionalCast<Input, Desired> : PredicateExpression where Input : PredicateExpression {

        public typealias Output = Desired?

        public let input: Input

        public init(_ input: Input)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.ConditionalCast<Input, Desired>.Output
    }

    public struct ForceCast<Input, Desired> : PredicateExpression where Input : PredicateExpression {

        public typealias Output = Desired

        public let input: Input

        public init(_ input: Input)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.ForceCast<Input, Desired>.Output
    }

    public struct TypeCheck<Input, Desired> : PredicateExpression where Input : PredicateExpression {

        public typealias Output = Bool

        public let input: Input

        public init(_ input: Input)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.TypeCheck<Input, Desired>.Output
    }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct UnaryMinus<Wrapped> : PredicateExpression where Wrapped : PredicateExpression, Wrapped.Output : SignedNumeric {

        public typealias Output = Wrapped.Output

        public let wrapped: Wrapped

        public init(_ wrapped: Wrapped)

        public func evaluate(_ bindings: PredicateBindings) throws -> PredicateExpressions.UnaryMinus<Wrapped>.Output
    }

    public static func build_UnaryMinus<T>(_ inner: T) -> PredicateExpressions.UnaryMinus<T> where T : PredicateExpression, T.Output : SignedNumeric
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions {

    public struct VariableID : Hashable, Codable, Sendable {

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PredicateExpressions.VariableID, b: PredicateExpressions.VariableID) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    public struct Variable<Output> : StandardPredicateExpression {

        public let key: PredicateExpressions.VariableID

        public init()

        public func evaluate(_ bindings: PredicateBindings) throws -> Output

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct KeyPath<Root, Output> : PredicateExpression where Root : PredicateExpression {

        public let root: Root

        public let keyPath: any KeyPath<Root.Output, Output> & Sendable

        public init(root: Root, keyPath: any KeyPath<Root.Output, Output> & Sendable)

        public func evaluate(_ bindings: PredicateBindings) throws -> Output
    }

    public struct Value<Output> : PredicateExpression {

        public let value: Output

        public init(_ value: Output)

        public func evaluate(_ bindings: PredicateBindings) -> Output
    }

    public static func build_Arg<T>(_ arg: T) -> PredicateExpressions.Value<T>

    public static func build_Arg<T>(_ arg: T) -> T where T : PredicateExpression

    public static func build_KeyPath<Root, Value>(root: Root, keyPath: any KeyPath<Root.Output, Value> & Sendable) -> PredicateExpressions.KeyPath<Root, Value> where Root : PredicateExpression
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions : BitwiseCopyable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.StringLocalizedStandardContains : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.StringLocalizedStandardContains : StandardPredicateExpression where Root : StandardPredicateExpression, Other : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.StringLocalizedStandardContains : Codable where Root : Decodable, Root : Encodable, Other : Decodable, Other : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.StringLocalizedStandardContains : Sendable where Root : Sendable, Other : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.StringLocalizedCompare : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.StringLocalizedCompare : StandardPredicateExpression where Root : StandardPredicateExpression, Other : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.StringLocalizedCompare : Codable where Root : Decodable, Root : Encodable, Other : Decodable, Other : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.StringLocalizedCompare : Sendable where Root : Sendable, Other : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceMaximum : StandardPredicateExpression where Elements : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.SequenceMaximum : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceMaximum : Codable where Elements : Decodable, Elements : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceMaximum : Sendable where Elements : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceMinimum : StandardPredicateExpression where Elements : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.SequenceMinimum : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceMinimum : Codable where Elements : Decodable, Elements : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceMinimum : Sendable where Elements : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ArithmeticOperator : Equatable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ArithmeticOperator : Hashable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Arithmetic : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Arithmetic : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Arithmetic : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Arithmetic : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionIndexSubscript : Sendable where Wrapped : Sendable, Index : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.CollectionIndexSubscript : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionIndexSubscript : Codable where Wrapped : Decodable, Wrapped : Encodable, Index : Decodable, Index : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionIndexSubscript : StandardPredicateExpression where Wrapped : StandardPredicateExpression, Index : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.CollectionRangeSubscript : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionRangeSubscript : Sendable where Wrapped : Sendable, Range : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionRangeSubscript : Codable where Wrapped : Decodable, Wrapped : Encodable, Range : Decodable, Range : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionRangeSubscript : StandardPredicateExpression where Wrapped : StandardPredicateExpression, Range : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.CollectionContainsCollection : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionContainsCollection : Sendable where Base : Sendable, Other : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionContainsCollection : Codable where Base : Decodable, Base : Encodable, Other : Decodable, Other : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.CollectionContainsCollection : StandardPredicateExpression where Base : StandardPredicateExpression, Other : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ComparisonOperator : Equatable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ComparisonOperator : Hashable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Comparison : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Comparison : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Comparison : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Comparison : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Conditional : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Conditional : StandardPredicateExpression where Test : StandardPredicateExpression, If : StandardPredicateExpression, Else : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Conditional : Codable where Test : Decodable, Test : Encodable, If : Decodable, If : Encodable, Else : Decodable, Else : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Conditional : Sendable where Test : Sendable, If : Sendable, Else : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Conjunction : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Conjunction : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Conjunction : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Conjunction : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.DictionaryKeySubscript : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.DictionaryKeySubscript : Sendable where Wrapped : Sendable, Key : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.DictionaryKeySubscript : Codable where Wrapped : Decodable, Wrapped : Encodable, Key : Decodable, Key : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.DictionaryKeySubscript : StandardPredicateExpression where Wrapped : StandardPredicateExpression, Key : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.DictionaryKeyDefaultValueSubscript : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.DictionaryKeyDefaultValueSubscript : Sendable where Wrapped : Sendable, Key : Sendable, Default : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.DictionaryKeyDefaultValueSubscript : Codable where Wrapped : Decodable, Wrapped : Encodable, Key : Decodable, Key : Encodable, Default : Decodable, Default : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.DictionaryKeyDefaultValueSubscript : StandardPredicateExpression where Wrapped : StandardPredicateExpression, Key : StandardPredicateExpression, Default : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Disjunction : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Disjunction : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Disjunction : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Disjunction : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.IntDivision : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.IntDivision : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.IntDivision : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.IntDivision : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.IntRemainder : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.IntRemainder : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.IntRemainder : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.IntRemainder : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.FloatDivision : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.FloatDivision : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.FloatDivision : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.FloatDivision : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Equal : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Equal : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Equal : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Equal : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension PredicateExpressions.ExpressionEvaluate : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension PredicateExpressions.ExpressionEvaluate : StandardPredicateExpression where Transformation : StandardPredicateExpression, repeat each Input : StandardPredicateExpression {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension PredicateExpressions.ExpressionEvaluate : Codable where Transformation : Decodable, Transformation : Encodable, repeat each Input : Decodable, repeat each Input : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension PredicateExpressions.ExpressionEvaluate : Sendable where Transformation : Sendable, repeat each Input : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Filter : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Filter : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Filter : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Filter : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.NotEqual : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.NotEqual : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.NotEqual : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.NotEqual : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Negation : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Negation : StandardPredicateExpression where Wrapped : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Negation : Codable where Wrapped : Decodable, Wrapped : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Negation : Sendable where Wrapped : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.OptionalFlatMap : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.OptionalFlatMap : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.OptionalFlatMap : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.OptionalFlatMap : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.NilCoalesce : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.NilCoalesce : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.NilCoalesce : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.NilCoalesce : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.ForcedUnwrap : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForcedUnwrap : StandardPredicateExpression where Inner : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForcedUnwrap : Codable where Inner : Decodable, Inner : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForcedUnwrap : Sendable where Inner : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.PredicateEvaluate : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.PredicateEvaluate : StandardPredicateExpression where Condition : StandardPredicateExpression, repeat each Input : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.PredicateEvaluate : Codable where Condition : Decodable, Condition : Encodable, repeat each Input : Decodable, repeat each Input : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.PredicateEvaluate : Sendable where Condition : Sendable, repeat each Input : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Range : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Range : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Range : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Range : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.ClosedRange : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ClosedRange : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ClosedRange : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ClosedRange : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.RangeExpressionContains : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.RangeExpressionContains : StandardPredicateExpression where RangeExpression : StandardPredicateExpression, Element : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.RangeExpressionContains : Codable where RangeExpression : Decodable, RangeExpression : Encodable, Element : Decodable, Element : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.RangeExpressionContains : Sendable where RangeExpression : Sendable, Element : Sendable {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension PredicateExpressions.StringContainsRegex : Sendable where Subject : Sendable, Regex : Sendable {
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension PredicateExpressions.StringContainsRegex : Codable where Subject : Decodable, Subject : Encodable, Regex : Decodable, Regex : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension PredicateExpressions.StringContainsRegex : StandardPredicateExpression where Subject : StandardPredicateExpression, Regex : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.SequenceContains : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceContains : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceContains : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceContains : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.SequenceContainsWhere : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceContainsWhere : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceContainsWhere : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceContainsWhere : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.SequenceAllSatisfy : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceAllSatisfy : StandardPredicateExpression where LHS : StandardPredicateExpression, RHS : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceAllSatisfy : Codable where LHS : Decodable, LHS : Encodable, RHS : Decodable, RHS : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceAllSatisfy : Sendable where LHS : Sendable, RHS : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceStartsWith : StandardPredicateExpression where Base : StandardPredicateExpression, Prefix : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceStartsWith : Codable where Base : Decodable, Base : Encodable, Prefix : Decodable, Prefix : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.SequenceStartsWith : Sendable where Base : Sendable, Prefix : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.StringCaseInsensitiveCompare : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.StringCaseInsensitiveCompare : StandardPredicateExpression where Root : StandardPredicateExpression, Other : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.StringCaseInsensitiveCompare : Codable where Root : Decodable, Root : Encodable, Other : Decodable, Other : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.StringCaseInsensitiveCompare : Sendable where Root : Sendable, Other : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.ConditionalCast : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ConditionalCast : StandardPredicateExpression where Input : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ConditionalCast : Codable where Input : Decodable, Input : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ConditionalCast : Sendable where Input : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.ForceCast : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForceCast : StandardPredicateExpression where Input : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForceCast : Codable where Input : Decodable, Input : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.ForceCast : Sendable where Input : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.TypeCheck : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.TypeCheck : StandardPredicateExpression where Input : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.TypeCheck : Codable where Input : Decodable, Input : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.TypeCheck : Sendable where Input : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.UnaryMinus : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.UnaryMinus : StandardPredicateExpression where Wrapped : StandardPredicateExpression {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.UnaryMinus : Codable where Wrapped : Decodable, Wrapped : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.UnaryMinus : Sendable where Wrapped : Sendable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Variable : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.KeyPath : Codable where Root : Decodable, Root : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.KeyPath : Sendable where Root : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.KeyPath : StandardPredicateExpression where Root : StandardPredicateExpression {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.KeyPath : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.KeyPath {

    public enum CommonKeyPathKind : Hashable, Sendable {

        case collectionCount

        case collectionIsEmpty

        case collectionFirst

        case bidirectionalCollectionLast

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PredicateExpressions.KeyPath<Root, Output>.CommonKeyPathKind, b: PredicateExpressions.KeyPath<Root, Output>.CommonKeyPathKind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    public var kind: PredicateExpressions.KeyPath<Root, Output>.CommonKeyPathKind? { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Value : Codable where Output : Decodable, Output : Encodable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Value : Sendable where Output : Sendable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension PredicateExpressions.Value : StandardPredicateExpression where Output : Decodable, Output : Encodable {
}

@available(macOS 14.4, iOS 17.4, tvOS 17.4, watchOS 10.4, *)
extension PredicateExpressions.Value : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
public struct PresentationIntent : Hashable, Codable, CustomDebugStringConvertible, Sendable {

    public var components: [PresentationIntent.IntentType]

    public var count: Int { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    public enum Kind : Hashable, Codable, CustomDebugStringConvertible, Sendable {

        case paragraph

        case header(level: Int)

        case orderedList

        case unorderedList

        case listItem(ordinal: Int)

        case codeBlock(languageHint: String?)

        case blockQuote

        case thematicBreak

        case table(columns: [PresentationIntent.TableColumn])

        case tableHeaderRow

        case tableRow(rowIndex: Int)

        case tableCell(columnIndex: Int)

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PresentationIntent.Kind, b: PresentationIntent.Kind) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    public struct TableColumn : Hashable, Codable, Sendable {

        public enum Alignment : Int, Hashable, Codable, Sendable {

            case left

            case center

            case right

            /// Creates a new instance with the specified raw value.
            ///
            /// If there is no value of the type that corresponds with the specified raw
            /// value, this initializer returns `nil`. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     print(PaperSize(rawValue: "Legal"))
            ///     // Prints "Optional(PaperSize.Legal)"
            ///
            ///     print(PaperSize(rawValue: "Tabloid"))
            ///     // Prints "nil"
            ///
            /// - Parameter rawValue: The raw value to use for the new instance.
            public init?(rawValue: Int)

            /// The raw type that can be used to represent all values of the conforming
            /// type.
            ///
            /// Every distinct value of the conforming type has a corresponding unique
            /// value of the `RawValue` type, but there may be values of the `RawValue`
            /// type that don't have a corresponding value of the conforming type.
            @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
            public typealias RawValue = Int

            /// The corresponding value of the raw type.
            ///
            /// A new instance initialized with `rawValue` will be equivalent to this
            /// instance. For example:
            ///
            ///     enum PaperSize: String {
            ///         case A4, A5, Letter, Legal
            ///     }
            ///
            ///     let selectedSize = PaperSize.Letter
            ///     print(selectedSize.rawValue)
            ///     // Prints "Letter"
            ///
            ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
            ///     // Prints "true"
            public var rawValue: Int { get }
        }

        public var alignment: PresentationIntent.TableColumn.Alignment

        public init(alignment: PresentationIntent.TableColumn.Alignment)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PresentationIntent.TableColumn, b: PresentationIntent.TableColumn) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public struct IntentType : Hashable, Codable, CustomDebugStringConvertible, Sendable {

        public var kind: PresentationIntent.Kind

        public var identity: Int

        /// A textual representation of this instance, suitable for debugging.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(reflecting:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `debugDescription` property for types that conform to
        /// `CustomDebugStringConvertible`:
        ///
        ///     struct Point: CustomDebugStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var debugDescription: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(reflecting: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `debugDescription` property.
        public var debugDescription: String { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: PresentationIntent.IntentType, b: PresentationIntent.IntentType) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    public init(_ kind: PresentationIntent.Kind, identity: Int, parent: PresentationIntent? = nil)

    public init(types: [PresentationIntent.IntentType])

    public var isValid: Bool { get }

    public var indentationLevel: Int { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: PresentationIntent, b: PresentationIntent) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(macOS 12, iOS 15, watchOS 8, tvOS 15, *)
extension PresentationIntent.TableColumn.Alignment : RawRepresentable {
}

/// `PropertyListDecoder` facilitates the decoding of property list values into semantic `Decodable` types.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
open class PropertyListDecoder {

    public typealias PropertyListFormat = PropertyListSerialization.PropertyListFormat

    /// Contextual user-provided information for use during decoding.
    @preconcurrency open var userInfo: [CodingUserInfoKey : any Sendable]

    /// Initializes `self` with default strategies.
    public init()

    /// Decodes a top-level value of the given type from the given property list representation.
    ///
    /// - parameter type: The type of the value to decode.
    /// - parameter data: The data to decode from.
    /// - returns: A value of the requested type.
    /// - throws: `DecodingError.dataCorrupted` if values requested from the payload are corrupted, or if the given data is not a valid property list.
    /// - throws: An error if any value throws an error during decoding.
    open func decode<T>(_ type: T.Type, from data: Data) throws -> T where T : Decodable

    /// Decodes a top-level value of the given type from the given property list representation.
    ///
    /// - parameter type: The type of the value to decode.
    /// - parameter data: The data to decode from.
    /// - parameter format: The parsed property list format.
    /// - returns: A value of the requested type along with the detected format of the property list.
    /// - throws: `DecodingError.dataCorrupted` if values requested from the payload are corrupted, or if the given data is not a valid property list.
    /// - throws: An error if any value throws an error during decoding.
    open func decode<T>(_ type: T.Type, from data: Data, format: inout PropertyListDecoder.PropertyListFormat) throws -> T where T : Decodable

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func decode<T>(_ type: T.Type, from data: Data, configuration: T.DecodingConfiguration) throws -> T where T : DecodableWithConfiguration

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func decode<T, C>(_ type: T.Type, from data: Data, configuration: C.Type) throws -> T where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func decode<T, C>(_ type: T.Type, from data: Data, format: inout PropertyListDecoder.PropertyListFormat, configuration: C.Type) throws -> T where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func decode<T>(_ type: T.Type, from data: Data, format: inout PropertyListDecoder.PropertyListFormat, configuration: T.DecodingConfiguration) throws -> T where T : DecodableWithConfiguration

    @objc deinit
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension PropertyListDecoder : @unchecked Sendable {
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension PropertyListDecoder : TopLevelDecoder {

    /// The type this decoder accepts.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Input = Data
}

/// `PropertyListEncoder` facilitates the encoding of `Encodable` values into property lists.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
open class PropertyListEncoder {

    /// The output format to write the property list data in. Defaults to `.binary`.
    open var outputFormat: PropertyListDecoder.PropertyListFormat

    /// Contextual user-provided information for use during encoding.
    @preconcurrency open var userInfo: [CodingUserInfoKey : any Sendable]

    /// Initializes `self` with default strategies.
    public init()

    /// Encodes the given top-level value and returns its property list representation.
    ///
    /// - parameter value: The value to encode.
    /// - returns: A new `Data` value containing the encoded property list data.
    /// - throws: `EncodingError.invalidValue` if a non-conforming floating-point value is encountered during encoding, and the encoding strategy is `.throw`.
    /// - throws: An error if any value throws an error during encoding.
    open func encode<Value>(_ value: Value) throws -> Data where Value : Encodable

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func encode<T>(_ value: T, configuration: T.EncodingConfiguration) throws -> Data where T : EncodableWithConfiguration

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    open func encode<T, C>(_ value: T, configuration: C.Type) throws -> Data where T : EncodableWithConfiguration, C : EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration

    @objc deinit
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension PropertyListEncoder : @unchecked Sendable {
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension PropertyListEncoder : TopLevelEncoder {

    /// The type this encoder produces.
    @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
    public typealias Output = Data
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
public typealias Published = Published

/// Describes an error that may be recoverable by presenting several
/// potential recovery options to the user.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol RecoverableError : Error {

    /// Provides a set of possible recovery options to present to the user.
    var recoveryOptions: [String] { get }

    /// Attempt to recover from this error when the user selected the
    /// option at the given index. This routine must call handler and
    /// indicate whether recovery was successful (or not).
    ///
    /// This entry point is used for recovery of errors handled at a
    /// "document" granularity, that do not affect the entire
    /// application.
    func attemptRecovery(optionIndex recoveryOptionIndex: Int, resultHandler handler: @escaping (_ recovered: Bool) -> Void)

    /// Attempt to recover from this error when the user selected the
    /// option at the given index. Returns true to indicate
    /// successful recovery, and false otherwise.
    ///
    /// This entry point is used for recovery of errors handled at
    /// the "application" granularity, where nothing else in the
    /// application can proceed until the attempted error recovery
    /// completes.
    func attemptRecovery(optionIndex recoveryOptionIndex: Int) -> Bool
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension RecoverableError {

    /// Default implementation that uses the application-model recovery
    /// mechanism (``attemptRecovery(optionIndex:)``) to implement
    /// document-modal recovery.
    public func attemptRecovery(optionIndex recoveryOptionIndex: Int, resultHandler handler: @escaping (_ recovered: Bool) -> Void)
}

/// Decorates types which are backed by a Foundation reference type.
///
/// All `ReferenceConvertible` types are hashable, equatable, and provide description functions.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public protocol ReferenceConvertible : CustomDebugStringConvertible, CustomStringConvertible, Hashable, _ObjectiveCBridgeable {

    associatedtype ReferenceType : NSObject, NSCopying
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
@dynamicMemberLookup public struct ScopedAttributeContainer<S> : Sendable where S : AttributeScope {

    @preconcurrency public subscript<T>(dynamicMember keyPath: KeyPath<S, T>) -> T.Value? where T : AttributedStringKey, T.Value : Sendable
}

/// A comparison algorithm for a given type.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@preconcurrency public protocol SortComparator<Compared> : Hashable, Sendable {

    /// The type that the `SortComparator` provides a comparison for.
    associatedtype Compared

    /// The relative ordering of lhs, and rhs.
    ///
    /// The result of comparisons should be flipped if the current `order`
    /// is `reverse`.
    ///
    /// If `compare(lhs, rhs)` is `.orderedAscending`, then `compare(rhs, lhs)`
    /// must be `.orderedDescending`. If `compare(lhs, rhs)` is
    /// `.orderedDescending`, then `compare(rhs, lhs)` must be
    /// `.orderedAscending`.
    ///
    /// - Parameters:
    ///     - lhs: A value to compare.
    ///     - rhs: A value to compare.
    func compare(_ lhs: Self.Compared, _ rhs: Self.Compared) -> ComparisonResult

    /// If the `SortComparator`s resulting order is forward or reverse.
    var order: SortOrder { get set }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SortComparator where Self == String.Comparator {

    /// Compares `String`s as compared by the Finder.
    ///
    /// Uses a localized, numeric comparison in the current locale.
    ///
    /// The default `String.Comparator` used in `String` comparisons.
    public static var localizedStandard: String.Comparator { get }

    /// Compares `String`s using a localized comparison in the current
    /// locale.
    public static var localized: String.Comparator { get }
}

/// A serializable description of how to sort numeric and `String` types.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
public struct SortDescriptor<Compared> : SortComparator, Codable, Sendable {

    /// The key path to the field for comparison.
    ///
    /// This value is `nil` when `Compared` is not an NSObject
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var keyPath: PartialKeyPath<Compared>? { get }

    /// A `String.StandardComparator` value.
    ///
    /// This property is non-`nil` when the `SortDescriptor` value is created
    /// with one.
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public var stringComparator: String.StandardComparator? { get }

    /// Sort order.
    public var order: SortOrder

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public init<Value>(_ keyPath: any KeyPath<Compared, Value> & Sendable, order: SortOrder = .forward) where Value : Comparable

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public init<Value>(_ keyPath: any KeyPath<Compared, Value?> & Sendable, order: SortOrder = .forward) where Value : Comparable

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public init(_ keyPath: any KeyPath<Compared, String> & Sendable, comparator: String.StandardComparator = .localizedStandard)

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public init(_ keyPath: any KeyPath<Compared, String?> & Sendable, comparator: String.StandardComparator = .localizedStandard)

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public init(_ keyPath: any KeyPath<Compared, String> & Sendable, comparator: String.StandardComparator = .localizedStandard, order: SortOrder)

    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public init(_ keyPath: any KeyPath<Compared, String?> & Sendable, comparator: String.StandardComparator = .localizedStandard, order: SortOrder)

    public init(_ keyPath: any KeyPath<Compared, Bool> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Bool?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Double> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Double?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Float> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Float?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int8> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int8?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int16> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int16?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int32> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int32?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int64> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int64?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Int?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt8> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt8?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt16> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt16?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt32> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt32?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt64> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt64?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UInt?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Date> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, Date?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UUID> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, UUID?> & Sendable, order: SortOrder = .forward) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, String> & Sendable, comparator: String.StandardComparator = .localizedStandard) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, String?> & Sendable, comparator: String.StandardComparator = .localizedStandard) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, String> & Sendable, comparator: String.StandardComparator = .localizedStandard, order: SortOrder) where Compared : NSObject

    public init(_ keyPath: any KeyPath<Compared, String?> & Sendable, comparator: String.StandardComparator = .localizedStandard, order: SortOrder) where Compared : NSObject

    /// Creates a `SortDescriptor` describing the same sort as the
    /// `NSSortDescriptor` over the given `Compared` type.
    ///
    /// Returns `nil` if there is no `SortDescriptor` equivalent to the given
    /// `NSSortDescriptor`, or if the `NSSortDescriptor`s selector is not one of
    /// the standard string comparison algorithms, or `compare(_:)`.
    ///
    /// The comparison for the created `SortDescriptor` uses the
    /// `NSSortDescriptor`s associated selector directly, so in cases where
    /// using the `NSSortDescriptor`s comparison would crash, the
    /// `SortDescriptor`s comparison will as well.
    ///
    /// - Parameters:
    ///     - descriptor: The `NSSortDescriptor` to convert.
    ///     - comparedType: The type the resulting `SortDescriptor` compares.
    public init?(_ descriptor: NSSortDescriptor, comparing comparedType: Compared.Type) where Compared : NSObject

    /// The relative ordering of lhs, and rhs.
    ///
    /// The result of comparisons should be flipped if the current `order`
    /// is `reverse`.
    ///
    /// If `compare(lhs, rhs)` is `.orderedAscending`, then `compare(rhs, lhs)`
    /// must be `.orderedDescending`. If `compare(lhs, rhs)` is
    /// `.orderedDescending`, then `compare(rhs, lhs)` must be
    /// `.orderedAscending`.
    ///
    /// - Parameters:
    ///     - lhs: A value to compare.
    ///     - rhs: A value to compare.
    public func compare(_ lhs: Compared, _ rhs: Compared) -> ComparisonResult

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SortDescriptor<Compared>, b: SortDescriptor<Compared>) -> Bool

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// The orderings that sorts can be performed with.
@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
@frozen public enum SortOrder : Hashable, Codable, Sendable {

    /// The ordering where if compare(a, b) == .orderedAscending,
    /// a is placed before b.
    case forward

    /// The ordering where if compare(a, b) == .orderedAscending,
    /// a is placed after b.
    case reverse

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: SortOrder, b: SortOrder) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension SortOrder : BitwiseCopyable {
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public protocol StandardPredicateExpression<Output> : PredicateExpression, Decodable, Encodable, Sendable {
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
public struct StringStyle : FormatStyle, Sendable {

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: String) -> String

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: StringStyle, b: StringStyle) -> Bool

    /// The type of data to format.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatInput = String

    /// The type of the formatted data.
    @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
    public typealias FormatOutput = String

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

/// A term of address that may be used to refer to a third person
///
/// Not every term of address can be displayed in every language
@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
public struct TermOfAddress : Sendable, Equatable, Hashable {

    public var language: Locale.Language? { get }

    public var pronouns: [Morphology.Pronoun] { get }

    /// Term of address that uses gender-neutral pronouns (e.g. they/them/theirs
    /// in English), and an epicene grammatical gender when inflecting verbs and
    /// adjectives referring to the person
    public static let neutral: TermOfAddress

    /// Term of address that uses feminine pronouns (e.g. she/her/hers
    /// in English), and a feminine grammatical gender when inflecting verbs and
    /// adjectives referring to the person
    public static let feminine: TermOfAddress

    /// Term of address that uses masculine pronouns (e.g. he/him/his
    /// in English), and a masculine grammatical gender when inflecting verbs
    /// and adjectives
    public static let masculine: TermOfAddress

    /// The term of address that should be used for addressing the user
    ///
    /// This term of address will only compare equal to another `currentUser`
    @available(macOS 15, iOS 18, tvOS 18, watchOS 11, visionOS 2, *)
    public static let currentUser: TermOfAddress

    /// A term of address restricted to a given language
    public static func localized(language: Locale.Language, pronouns: [Morphology.Pronoun]) -> TermOfAddress

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: TermOfAddress, rhs: TermOfAddress) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension TermOfAddress : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

/**
 `TimeZone` defines the behavior of a time zone. Time zone values represent geopolitical regions. Consequently, these values have names for these regions. Time zone values also represent a temporal offset, either plus or minus, from Greenwich Mean Time (GMT) and an abbreviation (such as PST for Pacific Standard Time).

 `TimeZone` provides two static functions to get time zone values: `current` and `autoupdatingCurrent`. The `autoupdatingCurrent` time zone automatically tracks updates made by the user.

 Note that time zone database entries such as "America/Los_Angeles" are IDs, not names. An example of a time zone name is "Pacific Daylight Time". Although many `TimeZone` functions include the word "name", they refer to IDs.

 Cocoa does not provide any API to change the time zone of the computer, or of other applications.
 */
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct TimeZone : Hashable, Equatable, Sendable {

    /// Returns a time zone initialized with a given identifier.
    ///
    /// An example identifier is "America/Los_Angeles".
    ///
    /// If `identifier` is an unknown identifier, then returns `nil`.
    public init?(identifier: String)

    /// Returns a time zone initialized with a specific number of seconds from GMT.
    ///
    /// Time zones created with this never have daylight savings and the offset is constant no matter the date. The identifier and abbreviation do NOT follow the POSIX convention (of minutes-west).
    ///
    /// - parameter seconds: The number of seconds from GMT.
    /// - returns: A time zone, or `nil` if a valid time zone could not be created from `seconds`.
    public init?(secondsFromGMT seconds: Int)

    /// Returns a time zone identified by a given abbreviation.
    ///
    /// In general, you are discouraged from using abbreviations except for unique instances such as "GMT". Time Zone abbreviations are not standardized and so a given abbreviation may have multiple meanings--for example, "EST" refers to Eastern Time in both the United States and Australia
    ///
    /// - parameter abbreviation: The abbreviation for the time zone.
    /// - returns: A time zone identified by abbreviation determined by resolving the abbreviation to an identifier using the abbreviation dictionary and then returning the time zone for that identifier. Returns `nil` if there is no match for abbreviation.
    public init?(abbreviation: String)

    /// The time zone currently used by the system.
    public static var current: TimeZone { get }

    /// The time zone currently used by the system, automatically updating to the user's current preference.
    ///
    /// If this time zone is mutated, then it no longer tracks the system time zone.
    ///
    /// The autoupdating time zone only compares equal to itself.
    public static var autoupdatingCurrent: TimeZone { get }

    /// The geopolitical region identifier that identifies the time zone.
    public var identifier: String { get }

    /// The current difference in seconds between the time zone and Greenwich Mean Time.
    ///
    /// - parameter date: The date to use for the calculation. The default value is the current date.
    public func secondsFromGMT(for date: Date = Date()) -> Int

    /// Returns the abbreviation for the time zone at a given date.
    ///
    /// Note that the abbreviation may be different at different dates. For example, during daylight saving time the US/Eastern time zone has an abbreviation of "EDT." At other times, its abbreviation is "EST."
    /// - parameter date: The date to use for the calculation. The default value is the current date.
    public func abbreviation(for date: Date = Date()) -> String?

    /// Returns a Boolean value that indicates whether the receiver uses daylight saving time at a given date.
    ///
    /// - parameter date: The date to use for the calculation. The default value is the current date.
    public func isDaylightSavingTime(for date: Date = Date()) -> Bool

    /// Returns the daylight saving time offset for a given date.
    ///
    /// - parameter date: The date to use for the calculation. The default value is the current date.
    public func daylightSavingTimeOffset(for date: Date = Date()) -> TimeInterval

    /// Returns the next daylight saving time transition after a given date.
    ///
    /// - parameter date: A date.
    /// - returns: The next daylight saving time transition after `date`. Depending on the time zone, this function may return a change of the time zone's offset from GMT. Returns `nil` if the time zone of the receiver does not observe daylight savings time as of `date`.
    public func nextDaylightSavingTimeTransition(after date: Date) -> Date?

    /// Returns the mapping of abbreviations to time zone identifiers.
    public static var abbreviationDictionary: [String : String]

    /// Returns the date of the next (after the current instant) daylight saving time transition for the time zone. Depending on the time zone, the value of this property may represent a change of the time zone's offset from GMT. Returns `nil` if the time zone does not currently observe daylight saving time.
    public var nextDaylightSavingTimeTransition: Date? { get }

    /// Returns the name of the receiver localized for a given locale.
    public func localizedName(for style: TimeZone.NameStyle, locale: Locale?) -> String?

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public static var gmt: TimeZone { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: TimeZone, rhs: TimeZone) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension TimeZone {

    /// Returns an array of strings listing the identifier of all the time zones known to the system.
    public static var knownTimeZoneIdentifiers: [String] { get }

    /// Returns the time zone data version.
    public static var timeZoneDataVersion: String { get }
}

/// Constants you use to specify a style when presenting time zone names.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension TimeZone {

    public typealias NameStyle = NSTimeZone.NameStyle
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension TimeZone : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension TimeZone : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension TimeZone : ReferenceConvertible {

    public typealias ReferenceType = NSTimeZone
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension TimeZone {

    public struct SystemTimeZoneDidChangeMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = TimeZone

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public var previousTimeZone: TimeZone?

        public init(previousTimeZone: TimeZone?)

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> TimeZone.SystemTimeZoneDidChangeMessage?
    }
}

/// A URL is a type that can potentially contain the location of a resource on a remote server, the path of a local file on disk, or even an arbitrary piece of encoded data.
///
/// You can construct URLs and access their parts. For URLs that represent local files, you can also manipulate properties of those files directly, such as changing the file's last modification date. Finally, you can pass URLs to other APIs to retrieve the contents of those URLs. For example, you can use the URLSession classes to access the contents of remote resources, as described in URL Session Programming Guide.
///
/// URLs are the preferred way to refer to local files. Most objects that read data from or write data to a file have methods that accept a URL instead of a pathname as the file reference. For example, you can get the contents of a local file URL as `String` by calling `func init(contentsOf:encoding:) throws`, or as a `Data` by calling `func init(contentsOf:options:) throws`.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URL : Equatable, Sendable, Hashable {

    public typealias BookmarkResolutionOptions = NSURL.BookmarkResolutionOptions

    public typealias BookmarkCreationOptions = NSURL.BookmarkCreationOptions

    /// Initialize with string.
    ///
    /// Returns `nil` if a `URL` cannot be formed with the string (for example, if the string contains characters that are illegal in a URL, or is an empty string).
    public init?(string: String)

    /// Initialize with string, relative to another URL.
    ///
    /// Returns `nil` if a `URL` cannot be formed with the string (for example, if the string contains characters that are illegal in a URL, or is an empty string).
    public init?(string: String, relativeTo url: URL?)

    /// Initialize with a URL string and the option to add (or skip) IDNA- and percent-encoding of invalid characters.
    ///
    /// If `encodingInvalidCharacters` is false, and the URL string is invalid according to RFC 3986, `nil` is returned.
    /// If `encodingInvalidCharacters` is true, `URL` will try to encode the string to create a valid URL.
    /// If the URL string is still invalid after encoding, `nil` is returned.
    @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
    public init?(string: String, encodingInvalidCharacters: Bool)

    /// Initializes a newly created file URL referencing the local file or directory at path, relative to a base URL.
    ///
    /// If an empty string is used for the path, then the path is assumed to be ".".
    /// - Note: This function avoids an extra file system access to check if the file URL is a directory. You should use it if you know the answer already.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    public init(fileURLWithPath path: String, isDirectory: Bool, relativeTo base: URL?)

    /// Initializes a newly created file URL referencing the local file or directory at path, relative to a base URL.
    ///
    /// If an empty string is used for the path, then the path is assumed to be ".".
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    public init(fileURLWithPath path: String, relativeTo base: URL?)

    /// Initializes a newly created file URL referencing the local file or directory at path.
    ///
    /// If an empty string is used for the path, then the path is assumed to be ".".
    /// - note: This function avoids an extra file system access to check if the file URL is a directory. You should use it if you know the answer already.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    public init(fileURLWithPath path: String, isDirectory: Bool)

    /// Initializes a newly created file URL referencing the local file or directory at path.
    ///
    /// If an empty string is used for the path, then the path is assumed to be ".".
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use init(filePath:directoryHint:relativeTo:) instead")
    public init(fileURLWithPath path: String)

    /// Initializes a newly created URL using the contents of the given data, relative to a base URL.
    ///
    /// If the data representation is not a legal URL string as ASCII bytes, the URL object may not behave as expected. If the URL cannot be formed then this will return nil.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public init?(dataRepresentation: Data, relativeTo base: URL?, isAbsolute: Bool = false)

    /// Initializes a URL that refers to a location specified by resolving bookmark data.
    @available(swift 4.2)
    public init(resolvingBookmarkData data: Data, options: URL.BookmarkResolutionOptions = [], relativeTo url: URL? = nil, bookmarkDataIsStale: inout Bool) throws

    /// Creates and initializes a URL that refers to the location specified by resolving the alias file at `url`. If the `url` argument does not refer to an alias file as defined by the `.isAliasFileKey` property, the URL returned is the same as the `url` argument. This method fails and returns `nil` if the `url` argument is unreachable, or if the original file or directory could not be located or is not reachable, or if the original file or directory is on a volume that could not be located or mounted. The `URLBookmarkResolutionWithSecurityScope` option is not supported by this method.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public init(resolvingAliasFileAt url: URL, options: URL.BookmarkResolutionOptions = []) throws

    /// Initializes a newly created URL referencing the local file or directory at the file system representation of the path. File system representation is a null-terminated C string with canonical UTF-8 encoding.
    public init(fileURLWithFileSystemRepresentation path: UnsafePointer<Int8>, isDirectory: Bool, relativeTo base: URL?)

    /// Returns the data representation of the URL's relativeString.
    ///
    /// If the URL was initialized with `init?(dataRepresentation:relativeTo:isAbsolute:)`, the data representation returned are the same bytes as those used at initialization; otherwise, the data representation returned are the bytes of the `relativeString` encoded with UTF8 string encoding.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var dataRepresentation: Data { get }

    /// Returns the absolute string for the URL.
    public var absoluteString: String { get }

    /// Returns the relative portion of a URL.
    ///
    /// If `baseURL` is nil, or if the receiver is itself absolute, this is the same as `absoluteString`.
    public var relativeString: String { get }

    /// Returns the base URL.
    ///
    /// If the URL is itself absolute, then this value is nil.
    public var baseURL: URL? { get }

    /// Returns the absolute URL.
    ///
    /// If the URL is itself absolute, this will return self.
    public var absoluteURL: URL { get }

    /// Returns the scheme of the URL.
    public var scheme: String? { get }

    /// Returns true if the scheme is `file:`.
    public var isFileURL: Bool { get }

    /// Returns the host component of the URL if present, otherwise returns `nil`.
    ///
    /// - note: This function will resolve against the base `URL`.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use host(percentEncoded:) instead")
    public var host: String? { get }

    /// Returns the host component of the URL if present, otherwise returns `nil`.
    ///
    /// - Parameter percentEncoded: Whether the host should be percent encoded,
    ///   defaults to `true`.
    /// - Returns: The host component of the URL
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func host(percentEncoded: Bool = true) -> String?

    /// Returns the port component of the URL if present, otherwise returns `nil`.
    ///
    /// - note: This function will resolve against the base `URL`.
    public var port: Int? { get }

    /// Returns the user component of the URL if present, otherwise returns `nil`.
    ///
    /// - note: This function will resolve against the base `URL`.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use user(percentEncoded:) instead")
    public var user: String? { get }

    /// Returns the user component of the URL if present, otherwise returns `nil`.
    /// - Parameter percentEncoded: Whether the user should be percent encoded,
    ///   defaults to `true`.
    /// - Returns: The user component of the URL.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func user(percentEncoded: Bool = true) -> String?

    /// Returns the password component of the URL if present, otherwise returns `nil`.
    ///
    /// - note: This function will resolve against the base `URL`.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use password(percentEncoded:) instead")
    public var password: String? { get }

    /// Returns the password component of the URL if present, otherwise returns `nil`.
    /// - Parameter percentEncoded: Whether the password should be percent encoded,
    ///   defaults to `true`.
    /// - Returns: The password component of the URL.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func password(percentEncoded: Bool = true) -> String?

    /// Returns the path component of the URL if present, otherwise returns an empty string.
    ///
    /// - note: This function will resolve against the base `URL`.
    /// - returns: The path, or an empty string if the URL has an empty path.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use path(percentEncoded:) instead")
    public var path: String { get }

    /// Returns the path component of the URL if present, otherwise returns an empty string.
    /// - note: This function will resolve against the base `URL`.
    /// - Parameter percentEncoded: Whether the path should be percent encoded,
    ///   defaults to `true`.
    /// - Returns: The path component of the URL.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func path(percentEncoded: Bool = true) -> String

    /// Returns the relative path of the URL if present, otherwise returns an empty string. This is the same as `path` if `baseURL` is `nil`.
    ///
    /// - returns: The relative path, or an empty string if the URL has an empty path.
    public var relativePath: String { get }

    /// Returns the query component of the URL if present, otherwise returns `nil`.
    ///
    /// - note: This function will resolve against the base `URL`.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use query(percentEncoded:) instead")
    public var query: String? { get }

    /// Returns the password component of the URL if present, otherwise returns `nil`.
    /// - Parameter percentEncoded: Whether the query should be percent encoded,
    ///   defaults to `true`.
    /// - Returns: The query component of the URL.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func query(percentEncoded: Bool = true) -> String?

    /// Returns the fragment component of the URL if present, otherwise returns `nil`.
    ///
    /// - note: This function will resolve against the base `URL`.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use fragment(percentEncoded:) instead")
    public var fragment: String? { get }

    /// Returns the password component of the URL if present, otherwise returns `nil`.
    /// - Parameter percentEncoded: Whether the fragment should be percent encoded,
    ///   defaults to `true`.
    /// - Returns: The fragment component of the URL.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func fragment(percentEncoded: Bool = true) -> String?

    /// Passes the URL's path in file system representation to `block`.
    ///
    /// File system representation is a null-terminated C string with canonical UTF-8 encoding.
    /// - note: The pointer is not valid outside the context of the block.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func withUnsafeFileSystemRepresentation<ResultType>(_ block: (UnsafePointer<Int8>?) throws -> ResultType) rethrows -> ResultType

    /// Returns true if the URL path represents a directory.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var hasDirectoryPath: Bool { get }

    /// Returns the path components of the URL, or an empty array if the path is an empty string.
    public var pathComponents: [String] { get }

    /// Returns the last path component of the URL, or an empty string if the path is an empty string.
    public var lastPathComponent: String { get }

    /// Returns the path extension of the URL, or an empty string if the path is an empty string.
    public var pathExtension: String { get }

    /// Returns a URL constructed by appending the given path component to self.
    ///
    /// - parameter pathComponent: The path component to add.
    /// - parameter isDirectory: If `true`, then a trailing `/` is added to the resulting path.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    public func appendingPathComponent(_ pathComponent: String, isDirectory: Bool) -> URL

    /// Returns a URL constructed by appending the given path component to self.
    ///
    /// - note: This function performs a file system operation to determine if the path component is a directory. If so, it will append a trailing `/`. If you know in advance that the path component is a directory or not, then use `func appendingPathComponent(_:isDirectory:)`.
    /// - parameter pathComponent: The path component to add.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use appending(path:directoryHint:) instead")
    public func appendingPathComponent(_ pathComponent: String) -> URL

    /// Returns a URL constructed by removing the last path component of self.
    ///
    /// This function may either remove a path component or append `/..`.
    /// If the URL has an empty path that is not resolved against a base URL
    /// (e.g., `http://www.example.com`),
    /// then this function will return the URL unchanged.
    public func deletingLastPathComponent() -> URL

    /// Returns a URL constructed by appending the given path extension to self.
    ///
    /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will return the URL unchanged.
    ///
    /// Certain special characters (for example, Unicode Right-To-Left marks) cannot be used as path extensions. If any of those are contained in `pathExtension`, the function will return the URL unchanged.
    /// - parameter pathExtension: The extension to append.
    public func appendingPathExtension(_ pathExtension: String) -> URL

    /// Returns a URL constructed by removing any path extension.
    ///
    /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will return the URL unchanged.
    public func deletingPathExtension() -> URL

    /// Appends a path component to the URL.
    ///
    /// - parameter pathComponent: The path component to add.
    /// - parameter isDirectory: Use `true` if the resulting path is a directory.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    public mutating func appendPathComponent(_ pathComponent: String, isDirectory: Bool)

    /// Appends a path component to the URL.
    ///
    /// - note: This function performs a file system operation to determine if the path component is a directory. If so, it will append a trailing `/`. If you know in advance that the path component is a directory or not, then use `func appendingPathComponent(_:isDirectory:)`.
    /// - parameter pathComponent: The path component to add.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use append(path:directoryHint:) instead")
    public mutating func appendPathComponent(_ pathComponent: String)

    /// Appends the given path extension to self.
    ///
    /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will do nothing.
    /// Certain special characters (for example, Unicode Right-To-Left marks) cannot be used as path extensions. If any of those are contained in `pathExtension`, the function will return the URL unchanged.
    /// - parameter pathExtension: The extension to append.
    public mutating func appendPathExtension(_ pathExtension: String)

    /// Returns a URL constructed by removing the last path component of self.
    ///
    /// This function may either remove a path component or append `/..`.
    ///
    /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will do nothing.
    public mutating func deleteLastPathComponent()

    /// Returns a URL constructed by removing any path extension.
    ///
    /// If the URL has an empty path (e.g., `http://www.example.com`), then this function will do nothing.
    public mutating func deletePathExtension()

    /// Returns a `URL` with any instances of ".." or "." removed from its path.
    /// - note: This method does not consult the file system.
    public var standardized: URL { get }

    /// Standardizes the path of a file URL by removing dot segments.
    public mutating func standardize()

    /// Standardizes the path of a file URL.
    ///
    /// If the `isFileURL` is false, this method returns `self`.
    /// - note: This method consults the file system.
    public var standardizedFileURL: URL { get }

    /// Resolves any symlinks in the path of a file URL.
    ///
    /// If the `isFileURL` is false, this method returns `self`.
    public func resolvingSymlinksInPath() -> URL

    /// Resolves any symlinks in the path of a file URL.
    ///
    /// If the `isFileURL` is false, this method does nothing.
    public mutating func resolveSymlinksInPath()

    /// Returns whether the URL's resource exists and is reachable.
    ///
    /// This method synchronously checks if the resource's backing store is reachable. Checking reachability is appropriate when making decisions that do not require other immediate operations on the resource, e.g. periodic maintenance of UI state that depends on the existence of a specific document. When performing operations such as opening a file or copying resource properties, it is more efficient to simply try the operation and handle failures. This method is currently applicable only to URLs for file system resources. For other URL types, `false` is returned.
    public func checkResourceIsReachable() throws -> Bool

    /// Returns whether the promised item URL's resource exists and is reachable.
    ///
    /// This method synchronously checks if the resource's backing store is reachable. Checking reachability is appropriate when making decisions that do not require other immediate operations on the resource, e.g. periodic maintenance of UI state that depends on the existence of a specific document. When performing operations such as opening a file or copying resource properties, it is more efficient to simply try the operation and handle failures. This method is currently applicable only to URLs for file system resources. For other URL types, `false` is returned.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func checkPromisedItemIsReachable() throws -> Bool

    /// Sets the resource value identified by a given resource key.
    ///
    /// This method writes the new resource values out to the backing store. Attempts to set a read-only resource property or to set a resource property not supported by the resource are ignored and are not considered errors. This method is currently applicable only to URLs for file system resources.
    ///
    /// `URLResourceValues` keeps track of which of its properties have been set. Those values are the ones used by this function to determine which properties to write.
    public mutating func setResourceValues(_ values: URLResourceValues) throws

    /// Return a collection of resource values identified by the given resource keys.
    ///
    /// This method first checks if the URL object already caches the resource value. If so, it returns the cached resource value to the caller. If not, then this method synchronously obtains the resource value from the backing store, adds the resource value to the URL object's cache, and returns the resource value to the caller. The type of the resource value varies by resource property (see resource key definitions). If this method does not throw and the resulting value in the `URLResourceValues` is populated with nil, it means the resource property is not available for the specified resource and no errors occurred when determining the resource property was not available. This method is currently applicable only to URLs for file system resources.
    ///
    /// When this function is used from the main thread, resource values cached by the URL (except those added as temporary properties) are removed the next time the main thread's run loop runs. `func removeCachedResourceValue(forKey:)` and `func removeAllCachedResourceValues()` also may be used to remove cached resource values.
    ///
    /// Only the values for the keys specified in `keys` will be populated.
    public func resourceValues(forKeys keys: Set<URLResourceKey>) throws -> URLResourceValues

    /// Sets a temporary resource value on the URL object.
    ///
    /// Temporary resource values are for client use. Temporary resource values exist only in memory and are never written to the resource's backing store. Once set, a temporary resource value can be copied from the URL object with `func resourceValues(forKeys:)`. The values are stored in the loosely-typed `allValues` dictionary property.
    ///
    /// To remove a temporary resource value from the URL object, use `func removeCachedResourceValue(forKey:)`. Care should be taken to ensure the key that identifies a temporary resource value is unique and does not conflict with system defined keys (using reverse domain name notation in your temporary resource value keys is recommended). This method is currently applicable only to URLs for file system resources.
    @preconcurrency public mutating func setTemporaryResourceValue(_ value: any Sendable, forKey key: URLResourceKey)

    /// Removes all cached resource values and all temporary resource values from the URL object.
    ///
    /// This method is currently applicable only to URLs for file system resources.
    public mutating func removeAllCachedResourceValues()

    /// Removes the cached resource value identified by a given resource value key from the URL object.
    ///
    /// Removing a cached resource value may remove other cached resource values because some resource values are cached as a set of values, and because some resource values depend on other resource values (temporary resource values have no dependencies). This method is currently applicable only to URLs for file system resources.
    public mutating func removeCachedResourceValue(forKey key: URLResourceKey)

    /// Get resource values from URLs of 'promised' items.
    ///
    /// A promised item is not guaranteed to have its contents in the file system until you use `FileCoordinator` to perform a coordinated read on its URL, which causes the contents to be downloaded or otherwise generated. Promised item URLs are returned by various APIs, including currently:
    ///     NSMetadataQueryUbiquitousDataScope
    ///     NSMetadataQueryUbiquitousDocumentsScope
    ///     A `FilePresenter` presenting the contents of the directory located by -URLForUbiquitousContainerIdentifier: or a subdirectory thereof
    ///
    /// The following methods behave identically to their similarly named methods above (`func resourceValues(forKeys:)`, etc.), except that they allow you to get resource values and check for presence regardless of whether the promised item's contents currently exist at the URL. You must use these APIs instead of the normal URL resource value APIs if and only if any of the following are true:
    ///     You are using a URL that you know came directly from one of the above APIs
    ///     You are inside the accessor block of a coordinated read or write that used NSFileCoordinatorReadingImmediatelyAvailableMetadataOnly, NSFileCoordinatorWritingForDeleting, NSFileCoordinatorWritingForMoving, or NSFileCoordinatorWritingContentIndependentMetadataOnly
    ///
    /// Most of the URL resource value keys will work with these APIs. However, there are some that are tied to the item's contents that will not work, such as `contentAccessDateKey` or `generationIdentifierKey`. If one of these keys is used, the method will return a `URLResourceValues` value, but the value for that property will be nil.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func promisedItemResourceValues(forKeys keys: Set<URLResourceKey>) throws -> URLResourceValues

    /// Returns bookmark data for the URL, created with specified options and resource values.
    public func bookmarkData(options: URL.BookmarkCreationOptions = [], includingResourceValuesForKeys keys: Set<URLResourceKey>? = nil, relativeTo url: URL? = nil) throws -> Data

    /// Returns the resource values for properties identified by a specified array of keys contained in specified bookmark data. If the result dictionary does not contain a resource value for one or more of the requested resource keys, it means those resource properties are not available in the bookmark data.
    public static func resourceValues(forKeys keys: Set<URLResourceKey>, fromBookmarkData data: Data) -> URLResourceValues?

    /// Creates an alias file on disk at a specified location with specified bookmark data. bookmarkData must have been created with the URLBookmarkCreationSuitableForBookmarkFile option. bookmarkFileURL must either refer to an existing file (which will be overwritten), or to location in an existing directory.
    public static func writeBookmarkData(_ data: Data, to url: URL) throws

    /// Initializes and returns bookmark data derived from an alias file pointed to by a specified URL. If bookmarkFileURL refers to an alias file created prior to OS X v10.6 that contains Alias Manager information but no bookmark data, this method synthesizes bookmark data for the file.
    public static func bookmarkData(withContentsOf url: URL) throws -> Data

    /// Given an NSURL created by resolving a bookmark data created with security scope, make the resource referenced by the url accessible to the process. When access to this resource is no longer needed the client must call stopAccessingSecurityScopedResource. Each call to startAccessingSecurityScopedResource must be balanced with a call to stopAccessingSecurityScopedResource (Note: this is not reference counted).
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func startAccessingSecurityScopedResource() -> Bool

    /// Revokes the access granted to the url by a prior successful call to startAccessingSecurityScopedResource.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func stopAccessingSecurityScopedResource()

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: URL, rhs: URL) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension URL {

    /// Creates a URL from a file path by by copying and validating its UTF-8 contents.
    ///
    /// This initializer does not try to repair ill-formed UTF-8 code unit
    /// sequences. If any are found, the result of the initializer is `nil`.
    ///
    @available(macOS, introduced: 11.0, deprecated: 13.0, renamed: "init(filePath:)")
    @available(iOS, introduced: 14.0, deprecated: 16.0, renamed: "init(filePath:)")
    @available(watchOS, introduced: 7.0, deprecated: 9.0, renamed: "init(filePath:)")
    @available(tvOS, introduced: 14.0, deprecated: 16.0, renamed: "init(filePath:)")
    @available(visionOS, unavailable, renamed: "init(filePath:)")
    public init?(_ path: FilePath)

    /// Creates a URL from a file path by by copying and validating its UTF-8 contents.
    ///
    /// This initializer does not try to repair ill-formed UTF-8 code unit
    /// sequences. If any are found, the result of the initializer is `nil`.
    ///
    @available(macOS, introduced: 11.0, deprecated: 13.0, message: "Use init?(filePath:directoryHint:) instead")
    @available(iOS, introduced: 14.0, deprecated: 16.0, message: "Use init?(filePath:directoryHint:) instead")
    @available(watchOS, introduced: 7.0, deprecated: 9.0, message: "Use init?(filePath:directoryHint:) instead")
    @available(tvOS, introduced: 14.0, deprecated: 16.0, message: "Use init?(filePath:directoryHint:) instead")
    @available(visionOS, unavailable, message: "Use init?(filePath:directoryHint:) instead")
    public init?(_ path: FilePath, isDirectory: Bool)
}

extension URL {

    /// Creates a URL from a file path by by copying and validating its UTF-8 contents.
    ///
    /// This initializer does not try to repair ill-formed UTF-8 code unit
    /// sequences. If any are found, the result of the initializer is `nil`.
    ///
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public init?(filePath path: FilePath, directoryHint: URL.DirectoryHint = .inferFromPath)
}

extension URL {

    /// Strategies for parsing string representations of URLs to create an `URL` instance.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public struct ParseStrategy : Codable, Hashable, Sendable {

        /// Creates a new `ParseStrategy` with the given configurations.
        /// - Parameters:
        ///   - scheme: The strategy to use for parsing the `scheme`.
        ///   - user: The strategy to use for parsing the `user`.
        ///   - password: The strategy to use for parsing the `password`.
        ///   - host: The strategy to use for parsing the `host`.
        ///   - port: The strategy to use for parsing the `port`.
        ///   - path: The strategy to use for parsing the `path`.
        ///   - query: The strategy to use for parsing the `query`.
        ///   - fragment: The strategy to use for parsing the `fragment`.
        public init(scheme: URL.ParseStrategy.ComponentParseStrategy<String> = .required, user: URL.ParseStrategy.ComponentParseStrategy<String> = .optional, password: URL.ParseStrategy.ComponentParseStrategy<String> = .optional, host: URL.ParseStrategy.ComponentParseStrategy<String> = .required, port: URL.ParseStrategy.ComponentParseStrategy<Int> = .optional, path: URL.ParseStrategy.ComponentParseStrategy<String> = .optional, query: URL.ParseStrategy.ComponentParseStrategy<String> = .optional, fragment: URL.ParseStrategy.ComponentParseStrategy<String> = .optional)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: URL.ParseStrategy, b: URL.ParseStrategy) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL {

    /// Creates a new `URL` by parsing the given representation.
    /// - Parameters:
    ///   - value: A representation of a URL. The type of the representation is specified
    ///     by `ParseStrategy.ParseInput`.
    ///   - strategy: The parse strategy to parse `value` whose `ParseInput` is `URL`.
    public init<T>(_ value: T.ParseInput, strategy: T) throws where T : ParseStrategy, T.ParseOutput == URL
}

extension URL {

    /// Initializes a newly created file URL referencing the local file or directory at path, relative to a base URL.
    ///
    /// If an empty string is used for the path, then the path is assumed to be ".".
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public init(filePath path: String, directoryHint: URL.DirectoryHint = .inferFromPath, relativeTo base: URL? = nil)

    /// Returns a URL constructed by appending the given path to self.
    /// - Parameters:
    ///   - path: The path to add
    ///   - directoryHint: A hint to whether this URL will point to a directory
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func appending<S>(path: S, directoryHint: URL.DirectoryHint = .inferFromPath) -> URL where S : StringProtocol

    /// Appends a path to the receiver.
    ///
    /// - parameter path: The path to add.
    /// - parameter directoryHint: A hint to whether this URL will point to a directory
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public mutating func append<S>(path: S, directoryHint: URL.DirectoryHint = .inferFromPath) where S : StringProtocol

    /// Returns a URL constructed by appending the given path component to self. The path component
    /// is first percent-encoded before being appended to the receiver.
    /// - Parameters:
    ///   - component: A path component to append to the receiver.
    ///   - directoryHint: A hint to whether this URL will point to a directory.
    /// - Returns: The new URL
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func appending<S>(component: S, directoryHint: URL.DirectoryHint = .inferFromPath) -> URL where S : StringProtocol

    /// Appends a path component to the receiver. The path component is first
    /// percent-encoded before being appended to the receiver.
    /// - Parameters:
    ///   - component: A path component to append to the receiver.
    ///   - directoryHint: A hint to whether this URL will point to a directory.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public mutating func append<S>(component: S, directoryHint: URL.DirectoryHint = .inferFromPath) where S : StringProtocol

    /// Returns a URL constructed by appending the given list of `URLQueryItem` to self.
    /// - Parameter queryItems: A list of `URLQueryItem` to append to the receiver.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func appending(queryItems: [URLQueryItem]) -> URL

    /// Appends a list of `URLQueryItem` to the receiver.
    /// - Parameter queryItems: A list of `URLQueryItem` to append to the receiver.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public mutating func append(queryItems: [URLQueryItem])

    /// Returns a URL constructed by appending the given variadic list of path components to self.
    ///
    /// - Parameters:
    ///   - components: The list of components to add.
    ///   - directoryHint: A hint to whether this URL will point to a directory.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public func appending<S>(components: S..., directoryHint: URL.DirectoryHint = .inferFromPath) -> URL where S : StringProtocol

    /// Appends a variadic list of path components to the URL.
    ///
    /// - parameter components: The list of components to add.
    /// - parameter directoryHint: A hint to whether this URL will point to a directory.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public mutating func append<S>(components: S..., directoryHint: URL.DirectoryHint = .inferFromPath) where S : StringProtocol
}

extension URL {

    /// The working directory of the current process.
    /// Calling this property will issue a `getcwd` syscall.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static func currentDirectory() -> URL

    /// The home directory for the current user (~/).
    /// Complexity: O(1)
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var homeDirectory: URL { get }

    /// Returns the home directory for the specified user.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static func homeDirectory(forUser user: String) -> URL?

    /// The temporary directory for the current user.
    /// Complexity: O(1)
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var temporaryDirectory: URL { get }

    /// Discardable cache files directory for the
    /// current user. (~/Library/Caches).
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var cachesDirectory: URL { get }

    /// Supported applications (/Applications).
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var applicationDirectory: URL { get }

    /// Various user-visible documentation, support, and configuration
    /// files for the current user (~/Library).
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var libraryDirectory: URL { get }

    /// User home directories (/Users).
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var userDirectory: URL { get }

    /// Documents directory for the current user (~/Documents)
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var documentsDirectory: URL { get }

    /// Desktop directory for the current user (~/Desktop)
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var desktopDirectory: URL { get }

    /// Application support files for the current
    /// user (~/Library/Application Support)
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var applicationSupportDirectory: URL { get }

    /// Downloads directory for the current user (~/Downloads)
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var downloadsDirectory: URL { get }

    /// Movies directory for the current user (~/Movies)
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var moviesDirectory: URL { get }

    /// Music directory for the current user (~/Music)
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var musicDirectory: URL { get }

    /// Pictures directory for the current user (~/Pictures)
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var picturesDirectory: URL { get }

    /// The user’s Public sharing directory (~/Public)
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static var sharedPublicDirectory: URL { get }

    /// Trash directory for the current user (~/.Trash)
    /// Complexity: O(n) where n is the number of significant directories
    /// specified by `FileManager.SearchPathDirectory`
    @available(macOS 13.0, iOS 16.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public static var trashDirectory: URL { get }

    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public init(for directory: FileManager.SearchPathDirectory, in domain: FileManager.SearchPathDomainMask, appropriateFor url: URL? = nil, create shouldCreate: Bool = false) throws
}

extension URL {

    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public enum DirectoryHint : Sendable {

        /// Specifies that the `URL` does reference a directory
        case isDirectory

        /// Specifies that the `URL` does **not** reference a directory
        case notDirectory

        /// Specifies that `URL` should check with the file system to determine whether it references a directory
        case checkFileSystem

        /// Specifies that `URL` should infer whether it references a directory based on whether it has a trailing slash
        case inferFromPath

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: URL.DirectoryHint, b: URL.DirectoryHint) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URL : ReferenceConvertible {

    public typealias ReferenceType = NSURL
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URL : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URL {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "URL.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URL : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URL {

    /// Creates an instance initialized with the given resource name.
    ///
    /// Do not call this initializer directly. Instead, initialize a variable or
    /// constant using a file reference literal.
    public init(fileReferenceLiteralResourceName name: String)
}

extension URL {

    /// A template for constructing a URL from variable expansions.
    ///
    /// This is an template that can be expanded into
    /// a ``URL`` by calling ``URL(template:variables:)``.
    ///
    /// Templating has a rich set of options for substituting various parts of URLs. See
    /// [RFC 6570](https://datatracker.ietf.org/doc/html/rfc6570) for
    /// details.
    ///
    /// ### Example 1
    ///
    /// ```swift
    /// let template = URL.Template("http://www.example.com/foo{?query,number}")!
    /// let url = URL(
    ///     template: template,
    ///     variables: [
    ///         .query: "bar baz",
    ///         .number: "234",
    ///     ]
    /// )
    ///
    /// extension URL.Template.VariableName {
    ///     static var query: URL.Template.VariableName { .init("query") }
    ///     static var number: URL.Template.VariableName { .init("number") }
    /// }
    /// ```
    /// The resulting URL will be
    /// ```text
    /// http://www.example.com/foo?query=bar%20baz&number=234
    /// ```
    ///
    /// ### Usage
    ///
    /// Templates provide a description of a URL space and define how URLs can
    /// be constructed given specific variable values. Their intended use is,
    /// for example, to allow a server to communicate to a client how to
    /// construct URLs for particular resources.
    ///
    /// For each specific resource, an API contract is required to clearly
    /// define the variables applicable to that resource and its associated
    /// template. For example, such an API contract might specify that the
    /// variable `query` is mandatory and must be an alphanumeric string
    /// while the variable `number` is optional and must be a positive integer
    /// if provided. The server could then provide the client with a template
    /// such as `http://www.example.com/foo{?query,number}`, which the client
    /// can subsequently use to substitute variables accordingly.
    ///
    /// An API contract is necessary to define which substitutions are valid
    /// within a given URL space. There is no guarantee that every possible
    /// expansion of variable expressions corresponds to an existing resource
    /// URL; indeed, some expansions may not even produce a valid URL. Only
    /// the API specification itself can determine which expansions are
    /// expected to yield valid URLs corresponding to existing resources.
    ///
    /// ### Example 2
    ///
    /// Here’s an example, that illustrates how to define a specific set of variables:
    /// ```swift
    /// struct MyQueryTemplate: Sendable, Hashable {
    ///     var template: URL.Template
    ///
    ///     init?(_ template: String) {
    ///         guard let t = URL.Template(template) else { return nil }
    ///         self.template = t
    ///     }
    /// }
    ///
    /// struct MyQuery: Sendable, Hashable {
    ///     var query: String
    ///     var number: Int?
    ///
    ///     var variables: [URL.Template.VariableName: URL.Template.Value] {
    ///         var result: [URL.Template.VariableName: URL.Template.Value] = [
    ///             .query: .text(query)
    ///         ]
    ///         if let number {
    ///             result[.number] = .text("\(number)")
    ///         }
    ///         return result
    ///     }
    /// }
    ///
    /// extension URL.Template.VariableName {
    ///     static var query: URL.Template.VariableName { .init("query") }
    ///     static var number: URL.Template.VariableName { .init("number") }
    /// }
    ///
    /// extension URL {
    ///     init?(
    ///         template: MyQueryTemplate,
    ///         query: MyQuery
    ///     ) {
    ///         self.init(
    ///             template: template.template,
    ///             variables: query.variables
    ///         )
    ///     }
    /// }
    /// ```
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public struct Template : Sendable, Hashable {

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: URL.Template, b: URL.Template) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

extension URL {

    /// Creates a new `URL` by expanding the RFC 6570 template and variables.
    ///
    /// This will fail if variable expansion does not produce a valid,
    /// well-formed URL.
    ///
    /// All text will be converted to NFC (Unicode Normalization Form C) and UTF-8
    /// before being percent-encoded if needed.
    ///
    /// - Parameters:
    ///   - template: The RFC 6570 template to be expanded.
    ///   - variables: Variables to expand in the template.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public init?(template: URL.Template, variables: [URL.Template.VariableName : URL.Template.Value])
}

extension URL {

    /// Strategies for formatting an `URL`.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public struct FormatStyle : Codable, Hashable, Sendable {

        /// Creates a new `FormatStyle` with the given configurations.
        /// - Parameters:
        ///   - scheme: The strategy to use for formatting the `scheme`.
        ///   - user: The strategy to use for formatting the `user`.
        ///   - password: The strategy to use for formatting the `password`.
        ///   - host: The strategy to use for formatting the `host`.
        ///   - port: The strategy to use for formatting the `port`.
        ///   - path: The strategy to use for formatting the `path`.
        ///   - query: The strategy to use for formatting the `query`.
        ///   - fragment: The strategy to use for formatting the `fragment`.
        public init(scheme: URL.FormatStyle.ComponentDisplayOption = .always, user: URL.FormatStyle.ComponentDisplayOption = .never, password: URL.FormatStyle.ComponentDisplayOption = .never, host: URL.FormatStyle.HostDisplayOption = .always, port: URL.FormatStyle.ComponentDisplayOption = .omitIfHTTPFamily, path: URL.FormatStyle.ComponentDisplayOption = .always, query: URL.FormatStyle.ComponentDisplayOption = .never, fragment: URL.FormatStyle.ComponentDisplayOption = .never)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: URL.FormatStyle, b: URL.FormatStyle) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL {

    /// Converts `self` to its textual representation.
    /// - Parameter format: The format for formatting `self`.
    /// - Returns: A representation of `self` using the given `format`. The type of
    ///   the representation is specified by `FormatStyle.FormatOutput`
    public func formatted<F>(_ format: F) -> F.FormatOutput where F : FormatStyle, F.FormatInput == URL

    public func formatted() -> String
}

extension URL {

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public struct AsyncBytes : AsyncSequence, Sendable {

        /// The type of element produced by this asynchronous sequence.
        public typealias Element = UInt8

        /// The type of asynchronous iterator that produces elements of this
        /// asynchronous sequence.
        @frozen public struct AsyncIterator : AsyncIteratorProtocol, Sendable {

            /// Asynchronously advances to the next element and returns it, or ends the
            /// sequence if there is no next element.
            ///
            /// - Returns: The next element, if it exists, or `nil` to signal the end of
            ///   the sequence.
            @inlinable public mutating func next() async throws -> UInt8?

            @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
            public typealias Element = UInt8
        }

        /// Creates the asynchronous iterator that produces elements of this
        /// asynchronous sequence.
        ///
        /// - Returns: An instance of the `AsyncIterator` type used to produce
        /// elements of the asynchronous sequence.
        public func makeAsyncIterator() -> URL.AsyncBytes.AsyncIterator
    }

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public var resourceBytes: URL.AsyncBytes { get }

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public var lines: AsyncLineSequence<URL.AsyncBytes> { get }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension URL {

    public init?(resource: URLResource)
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.ParseStrategy {

    /// Specifies the strategy to use to parse each component.
    public enum ComponentParseStrategy<Component> : Codable, Hashable, CustomStringConvertible, Sendable where Component : Decodable, Component : Encodable, Component : Hashable, Component : Sendable {

        /// Denotes that the component is required to exists in order to consider the URL valid
        case required

        /// Denotes that the component is optional
        case optional

        /// If the component is missing, assume it has the attached default value
        case defaultValue(Component)

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: URL.ParseStrategy.ComponentParseStrategy<Component>, b: URL.ParseStrategy.ComponentParseStrategy<Component>) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.ParseStrategy {

    public func scheme(_ strategy: URL.ParseStrategy.ComponentParseStrategy<String> = .required) -> URL.ParseStrategy

    public func user(_ strategy: URL.ParseStrategy.ComponentParseStrategy<String> = .optional) -> URL.ParseStrategy

    public func password(_ strategy: URL.ParseStrategy.ComponentParseStrategy<String> = .optional) -> URL.ParseStrategy

    public func host(_ strategy: URL.ParseStrategy.ComponentParseStrategy<String> = .required) -> URL.ParseStrategy

    public func port(_ strategy: URL.ParseStrategy.ComponentParseStrategy<Int> = .optional) -> URL.ParseStrategy

    public func path(_ strategy: URL.ParseStrategy.ComponentParseStrategy<String> = .optional) -> URL.ParseStrategy

    public func query(_ strategy: URL.ParseStrategy.ComponentParseStrategy<String> = .optional) -> URL.ParseStrategy

    public func fragment(_ strategy: URL.ParseStrategy.ComponentParseStrategy<String> = .optional) -> URL.ParseStrategy
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.ParseStrategy : ParseStrategy {

    /// Creates an instance of the `ParseOutput` type from `value`.
    public func parse(_ value: String) throws -> URL

    /// The type of the representation describing the data.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias ParseInput = String

    /// The type of the data type.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias ParseOutput = URL
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.ParseStrategy : CustomConsumingRegexComponent {

    /// The output type for this regular expression.
    ///
    /// A `Regex` instance's output type depends on whether the `Regex` has
    /// captures and how it is created.
    ///
    /// - A `Regex` created from a string using the ``init(_:)`` initializer
    ///   has an output type of ``AnyRegexOutput``, whether it has captures or
    ///   not.
    /// - A `Regex` without captures created from a regex literal, the
    ///   ``init(_:as:)`` initializer, or a `RegexBuilder` closure has a
    ///   `Substring` output type, where the substring is the portion of the
    ///   string that was matched.
    /// - A `Regex` with captures created from a regex literal or the
    ///   ``init(_:as:)`` initializer has a tuple of substrings as its output
    ///   type. The first component of the tuple is the full portion of the string
    ///   that was matched, with the remaining components holding the captures.
    public typealias RegexOutput = URL

    /// Process the input string within the specified bounds, beginning at the given index, and return
    /// the end position (upper bound) of the match and the produced output.
    /// - Parameters:
    ///   - input: The string in which the match is performed.
    ///   - index: An index of `input` at which to begin matching.
    ///   - bounds: The bounds in `input` in which the match is performed.
    /// - Returns: The upper bound where the match terminates and a matched instance, or `nil` if
    ///   there isn't a match.
    public func consuming(_ input: String, startingAt index: String.Index, in bounds: Range<String.Index>) throws -> (upperBound: String.Index, output: URL)?
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.DirectoryHint : Equatable {
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.DirectoryHint : Hashable {
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template {

    /// Creates a new template from its text form.
    ///
    /// The template string needs to be a valid RFC 6570 template.
    ///
    /// This will parse the template and return `nil` if the template is invalid.
    public init?(_ template: String)
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template {

    /// The value of a variable used for expanding a template.
    ///
    /// A value can either be some text, a list, or an associate list (a dictionary).
    ///
    /// ### Examples
    /// ```swift
    /// let hello: URL.Template.Value = .text("Hello World!")
    /// let list: URL.Template.Value = .list(["red", "green", "blue"])
    /// let keys: URL.Template.Value = .associativeList([
    ///     "semi": ";",
    ///     "dot": ".",
    ///     "comma": ",",
    /// ])
    /// ```
    /// Alternatively, for constants, the `ExpressibleBy…Literal` implementations
    /// can be used, i.e.
    /// ```swift
    /// let hello: URL.Template.Value = "Hello World!"
    /// let list: URL.Template.Value = ["red", "green", "blue"]
    /// let keys: URL.Template.Value = [
    ///     "semi": ";",
    ///     "dot": ".",
    ///     "comma": ",",
    /// ]
    /// ```
    public struct Value : Sendable, Hashable {

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: URL.Template.Value, b: URL.Template.Value) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template {

    /// The name of a variable used for expanding a template.
    public struct VariableName : Sendable, Hashable {

        public init(_ key: String)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: URL.Template.VariableName, b: URL.Template.VariableName) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.FormatStyle {

    public enum Component : Int, Codable, Hashable, Sendable, CustomStringConvertible {

        case scheme

        case user

        case password

        case host

        case port

        case path

        case query

        case fragment

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.FormatStyle {

    /// Specifies the display option for a component, including whether to display or omit the
    /// component and the condition to do so.
    public struct ComponentDisplayOption : Codable, Hashable, CustomStringConvertible, Sendable {

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// Creates a display option to always display the component.
        public static var always: URL.FormatStyle.ComponentDisplayOption { get }

        /// Creates a display option to always omit the component.
        public static var never: URL.FormatStyle.ComponentDisplayOption { get }

        /// Creates a display option to display the component if the given condition is met.
        public static func displayWhen(_ component: URL.FormatStyle.Component, matches requirements: Set<String>) -> URL.FormatStyle.ComponentDisplayOption

        /// Creates a display option to omit the component if the given condition is met.
        public static func omitWhen(_ component: URL.FormatStyle.Component, matches requirements: Set<String>) -> URL.FormatStyle.ComponentDisplayOption

        /// Creates a display option to omit the component if the URL's scheme
        /// is `http` or `https`.
        public static var omitIfHTTPFamily: URL.FormatStyle.ComponentDisplayOption { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: URL.FormatStyle.ComponentDisplayOption, b: URL.FormatStyle.ComponentDisplayOption) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Specifies the display option for displaying the host component
    public struct HostDisplayOption : Codable, Hashable, CustomStringConvertible, Sendable {

        /// A textual representation of this instance.
        ///
        /// Calling this property directly is discouraged. Instead, convert an
        /// instance of any type to a string by using the `String(describing:)`
        /// initializer. This initializer works with any type, and uses the custom
        /// `description` property for types that conform to
        /// `CustomStringConvertible`:
        ///
        ///     struct Point: CustomStringConvertible {
        ///         let x: Int, y: Int
        ///
        ///         var description: String {
        ///             return "(\(x), \(y))"
        ///         }
        ///     }
        ///
        ///     let p = Point(x: 21, y: 30)
        ///     let s = String(describing: p)
        ///     print(s)
        ///     // Prints "(21, 30)"
        ///
        /// The conversion of `p` to a string in the assignment to `s` uses the
        /// `Point` type's `description` property.
        public var description: String { get }

        /// Creates a display option to always display the host.
        public static var always: URL.FormatStyle.HostDisplayOption { get }

        /// Creates a display option to always omit the host.
        public static var never: URL.FormatStyle.HostDisplayOption { get }

        /// Creates a display option to display the host if the given condition is met.
        public static func displayWhen(_ component: URL.FormatStyle.Component, matches requirements: Set<String>) -> URL.FormatStyle.HostDisplayOption

        /// Creates a display option to omit the host if the given condition is met.
        public static func omitWhen(_ component: URL.FormatStyle.Component, matches requirements: Set<String>) -> URL.FormatStyle.HostDisplayOption

        /// Creates a display option to omit the host if the URL's scheme
        /// is `http` or `https`.
        public static var omitIfHTTPFamily: URL.FormatStyle.HostDisplayOption { get }

        /// Creates a display option to manipulate the subdomains of a host
        /// - Parameters:
        ///   - subdomainsToOmit: specifies a set of subdomains to omit
        ///   - omitMultiLevelSubdomains: if `true`, multi-level subdomains
        ///     (more than two subdomains beyond the TLDs)  will be omitted.
        public static func omitSpecificSubdomains(_ subdomainsToOmit: Set<String> = Set(), includeMultiLevelSubdomains omitMultiLevelSubdomains: Bool = false) -> URL.FormatStyle.HostDisplayOption

        /// Creates a display option to manipulate the subdomains of a host
        /// - Parameters:
        ///   - subdomainsToOmit: specifies a set of subdomains to omit
        ///   - omitMultiLevelSubdomains: if `true`, multi-level subdomains
        ///     (more than two subdomains beyond the TLDs)  will be omitted.
        ///   - component: the component to test for condition.
        ///   - requirements: the requirements for the component.
        public static func omitSpecificSubdomains(_ subdomainsToOmit: Set<String> = Set(), includeMultiLevelSubdomains omitMultiLevelSubdomains: Bool = false, when component: URL.FormatStyle.Component, matches requirements: Set<String>) -> URL.FormatStyle.HostDisplayOption

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: URL.FormatStyle.HostDisplayOption, b: URL.FormatStyle.HostDisplayOption) -> Bool

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.FormatStyle {

    public func scheme(_ strategy: URL.FormatStyle.ComponentDisplayOption = .always) -> URL.FormatStyle

    public func user(_ strategy: URL.FormatStyle.ComponentDisplayOption = .never) -> URL.FormatStyle

    public func password(_ strategy: URL.FormatStyle.ComponentDisplayOption = .never) -> URL.FormatStyle

    public func host(_ strategy: URL.FormatStyle.HostDisplayOption = .always) -> URL.FormatStyle

    public func port(_ strategy: URL.FormatStyle.ComponentDisplayOption = .omitIfHTTPFamily) -> URL.FormatStyle

    public func path(_ strategy: URL.FormatStyle.ComponentDisplayOption = .always) -> URL.FormatStyle

    public func query(_ strategy: URL.FormatStyle.ComponentDisplayOption = .never) -> URL.FormatStyle

    public func fragment(_ strategy: URL.FormatStyle.ComponentDisplayOption = .never) -> URL.FormatStyle
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.FormatStyle : ParseableFormatStyle {

    /// A `ParseStrategy` that can be used to parse this `FormatStyle`'s output
    public var parseStrategy: URL.ParseStrategy { get }

    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias Strategy = URL.ParseStrategy
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.FormatStyle : FormatStyle {

    /// Creates a `FormatOutput` instance from `value`.
    public func format(_ value: URL) -> String

    /// The type of data to format.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatInput = URL

    /// The type of the formatted data.
    @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
    public typealias FormatOutput = String
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template.Value {

    /// A text value to be used with a ``URL.Template``.
    public static func text(_ text: String) -> URL.Template.Value

    /// A list value (an array of `String`s) to be used with a ``URL.Template``.
    public static func list(_ list: some Sequence<String>) -> URL.Template.Value

    /// An associative list value (ordered key-value pairs) to be used with a ``URL.Template``.
    public static func associativeList(_ list: some Sequence<(key: String, value: String)>) -> URL.Template.Value
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template.Value : ExpressibleByStringLiteral {

    /// Creates an instance initialized to the given string value.
    ///
    /// - Parameter value: The value of the new instance.
    public init(stringLiteral value: String)

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias ExtendedGraphemeClusterLiteralType = String

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias StringLiteralType = String

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias UnicodeScalarLiteralType = String
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template.Value : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    public init(arrayLiteral elements: String...)

    /// The type of the elements of an array literal.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias ArrayLiteralElement = String
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template.Value : ExpressibleByDictionaryLiteral {

    /// Creates an instance initialized with the given key-value pairs.
    public init(dictionaryLiteral elements: (String, String)...)

    /// The key type of a dictionary literal.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias Key = String

    /// The value type of a dictionary literal.
    @available(iOS 26.0, tvOS 26.0, watchOS 26.0, macOS 26.0, *)
    public typealias Value = String
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template.Value : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension URL.Template.VariableName : CustomStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension URL.FormatStyle.Component : RawRepresentable {
}

/// A structure designed to parse URLs based on RFC 3986 and to construct URLs from their constituent parts.
///
/// You can easily obtain a `URL` based on the contents of a `URLComponents` or vice versa.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLComponents : Hashable, Equatable, Sendable {

    /// Initialize with all components undefined.
    public init()

    /// Initialize with the components of a URL.
    ///
    /// If resolvingAgainstBaseURL is `true` and url is a relative URL, the components of url.absoluteURL are used. If the url string from the URL is malformed, nil is returned.
    public init?(url: URL, resolvingAgainstBaseURL resolve: Bool)

    /// Initialize with a URL string.
    ///
    /// If the URLString is malformed, nil is returned.
    public init?(string: String)

    /// Initialize with a URL string and the option to add (or skip) IDNA- and percent-encoding of invalid characters.
    /// If `encodingInvalidCharacters` is false, and the URL string is invalid according to RFC 3986, `nil` is returned.
    /// If `encodingInvalidCharacters` is true, `URLComponents` will try to encode the string to create a valid URL.
    /// If the URL string is still invalid after encoding, `nil` is returned.
    ///
    /// - Parameter string: The URL string.
    /// - Parameter encodingInvalidCharacters: True if `URLComponents` should try to encode an invalid URL string, false otherwise.
    /// - Returns: A `URLComponents` struct for a valid URL, or `nil` if the URL is invalid.
    @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
    public init?(string: String, encodingInvalidCharacters: Bool)

    /// Returns a URL created from the URLComponents.
    ///
    /// If the URLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the NSURLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
    public var url: URL? { get }

    /// Returns a URL created from the URLComponents relative to a base URL.
    ///
    /// If the URLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the URLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
    public func url(relativeTo base: URL?) -> URL?

    /// Returns a URL string created from the URLComponents.
    ///
    /// If the URLComponents has an authority component (user, password, host or port) and a path component, then the path must either begin with "/" or be an empty string. If the URLComponents does not have an authority component (user, password, host or port) and has a path component, the path component must not start with "//". If those requirements are not met, nil is returned.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var string: String? { get }

    /// The scheme subcomponent of the URL.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    /// Attempting to set the scheme with an invalid scheme string will cause an exception.
    public var scheme: String?

    /// The user subcomponent of the URL.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    ///
    /// Warning: IETF STD 66 (rfc3986) says the use of the format "user:password" in the userinfo subcomponent of a URI is deprecated because passing authentication information in clear text has proven to be a security risk. However, there are cases where this practice is still needed, and so the user and password components and methods are provided.
    public var user: String?

    /// The password subcomponent of the URL.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    ///
    /// Warning: IETF STD 66 (rfc3986) says the use of the format "user:password" in the userinfo subcomponent of a URI is deprecated because passing authentication information in clear text has proven to be a security risk. However, there are cases where this practice is still needed, and so the user and password components and methods are provided.
    public var password: String?

    /// The host subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    public var host: String?

    /// The port subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    /// Attempting to set a negative port number will cause a fatal error.
    public var port: Int?

    /// The path subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    public var path: String

    /// The query subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    public var query: String?

    /// The fragment subcomponent.
    ///
    /// The getter for this property removes any percent encoding this component may have (if the component allows percent encoding). Setting this property assumes the subcomponent or component string is not percent encoded and will add percent encoding (if the component allows percent encoding).
    public var fragment: String?

    /// The user subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlUserAllowed`).
    public var percentEncodedUser: String?

    /// The password subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlPasswordAllowed`).
    public var percentEncodedPassword: String?

    /// The host subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlHostAllowed`).
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use encodedHost instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use encodedHost instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use encodedHost instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use encodedHost instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use encodedHost instead")
    public var percentEncodedHost: String?

    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public var encodedHost: String?

    /// The path subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlPathAllowed`).
    public var percentEncodedPath: String

    /// The query subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlQueryAllowed`).
    public var percentEncodedQuery: String?

    /// The fragment subcomponent, percent-encoded.
    ///
    /// The getter for this property retains any percent encoding this component may have. Setting this properties assumes the component string is already correctly percent encoded. Attempting to set an incorrectly percent encoded string will cause a `fatalError`. Although ';' is a legal path character, it is recommended that it be percent-encoded for best compatibility with `URL` (`String.addingPercentEncoding(withAllowedCharacters:)` will percent-encode any ';' characters if you pass `CharacterSet.urlFragmentAllowed`).
    public var percentEncodedFragment: String?

    /// Returns the character range of the scheme in the string returned by `var string`.
    ///
    /// If the component does not exist, nil is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfScheme: Range<String.Index>? { get }

    /// Returns the character range of the user in the string returned by `var string`.
    ///
    /// If the component does not exist, nil is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfUser: Range<String.Index>? { get }

    /// Returns the character range of the password in the string returned by `var string`.
    ///
    /// If the component does not exist, nil is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfPassword: Range<String.Index>? { get }

    /// Returns the character range of the host in the string returned by `var string`.
    ///
    /// If the component does not exist, nil is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfHost: Range<String.Index>? { get }

    /// Returns the character range of the port in the string returned by `var string`.
    ///
    /// If the component does not exist, nil is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfPort: Range<String.Index>? { get }

    /// Returns the character range of the path in the string returned by `var string`.
    ///
    /// If the component does not exist, nil is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfPath: Range<String.Index>? { get }

    /// Returns the character range of the query in the string returned by `var string`.
    ///
    /// If the component does not exist, nil is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfQuery: Range<String.Index>? { get }

    /// Returns the character range of the fragment in the string returned by `var string`.
    ///
    /// If the component does not exist, nil is returned.
    /// - note: Zero length components are legal. For example, the URL string "scheme://:@/?#" has a zero length user, password, host, query and fragment; the URL strings "scheme:" and "" both have a zero length path.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var rangeOfFragment: Range<String.Index>? { get }

    /// Returns an array of query items for this `URLComponents`, in the order in which they appear in the original query string.
    ///
    /// Each `URLQueryItem` represents a single key-value pair,
    ///
    /// Note that a name may appear more than once in a single query string, so the name values are not guaranteed to be unique. If the `URLComponents` has an empty query component, returns an empty array. If the `URLComponents` has no query component, returns nil.
    ///
    /// The setter combines an array containing any number of `URLQueryItem`s, each of which represents a single key-value pair, into a query string and sets the `URLComponents` query property. Passing an empty array sets the query component of the `URLComponents` to an empty string. Passing nil removes the query component of the `URLComponents`.
    ///
    /// - note: If a name-value pair in a query is empty (i.e. the query string starts with '&', ends with '&', or has "&&" within it), you get a `URLQueryItem` with a zero-length name and a nil value. If a query's name-value pair has nothing before the equals sign, you get a zero-length name. If a query's name-value pair has nothing after the equals sign, you get a zero-length value. If a query's name-value pair has no equals sign, the query name-value pair string is the name and you get a nil value.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var queryItems: [URLQueryItem]?

    /// Returns an array of query items for this `URLComponents`, in the order in which they appear in the original query string. Any percent-encoding in a query item name or value is retained
    ///
    /// The setter combines an array containing any number of `URLQueryItem`s, each of which represents a single key-value pair, into a query string and sets the `URLComponents` query property. This property assumes the query item names and values are already correctly percent-encoded, and that the query item names do not contain the query item delimiter characters '&' and '='. Attempting to set an incorrectly percent-encoded query item or a query item name with the query item delimiter characters '&' and '=' will cause a `fatalError`.
    @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
    public var percentEncodedQueryItems: [URLQueryItem]?

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: URLComponents, rhs: URLComponents) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLComponents : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLComponents : ReferenceConvertible {

    public typealias ReferenceType = NSURLComponents
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLComponents : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

/// Describes errors in the URL error domain.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLError {

    /// The domain of the error.
    public static var errorDomain: String { get }

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }

    /// The error code itself.
    public struct Code : RawRepresentable, Hashable, Sendable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public let rawValue: Int

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias RawValue = Int
    }
}

extension URLError {

    /// Reasons used by URLError to indicate why a background URLSessionTask was cancelled.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public enum BackgroundTaskCancelledReason : Int, Sendable {

        case userForceQuitApplication

        case backgroundUpdatesDisabled

        case insufficientSystemResources

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }
}

extension URLError {

    /// Reasons used by URLError to indicate that a URLSessionTask failed because of unsatisfiable network constraints.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public enum NetworkUnavailableReason : Int, Sendable {

        case cellular

        case expensive

        case constrained

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init?(rawValue: Int)

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 13.0, tvOS 13.0, watchOS 6.0, macOS 10.15, *)
        public typealias RawValue = Int

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: Int { get }
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLError {

    /// The URL which caused a load to fail.
    public var failingURL: URL? { get }

    /// The string for the URL which caused a load to fail.
    @available(macOS, deprecated: 15.4, message: "Use failingURL instead")
    @available(iOS, deprecated: 18.4, message: "Use failingURL instead")
    @available(watchOS, deprecated: 11.4, message: "Use failingURL instead")
    @available(tvOS, deprecated: 18.4, message: "Use failingURL instead")
    @available(visionOS, deprecated: 2.4, message: "Use failingURL instead")
    public var failureURLString: String? { get }

    /// The state of a failed SSL handshake.
    public var failureURLPeerTrust: SecTrust? { get }

    /// The reason why a background URLSessionTask was cancelled.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public var backgroundTaskCancelledReason: URLError.BackgroundTaskCancelledReason? { get }

    /// The reason why the network is unavailable when the task failed due to unsatisfiable network constraints.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public var networkUnavailableReason: URLError.NetworkUnavailableReason? { get }

    /// An opaque data blob to resume a failed download task.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public var downloadTaskResumeData: Data? { get }

    /// An opaque data blob to resume a failed upload task.
    @available(macOS 14.0, iOS 17.0, watchOS 10.0, tvOS 17.0, *)
    public var uploadTaskResumeData: Data? { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLError {

    public static var unknown: URLError.Code { get }

    public static var cancelled: URLError.Code { get }

    public static var badURL: URLError.Code { get }

    public static var timedOut: URLError.Code { get }

    public static var unsupportedURL: URLError.Code { get }

    public static var cannotFindHost: URLError.Code { get }

    public static var cannotConnectToHost: URLError.Code { get }

    public static var networkConnectionLost: URLError.Code { get }

    public static var dnsLookupFailed: URLError.Code { get }

    public static var httpTooManyRedirects: URLError.Code { get }

    public static var resourceUnavailable: URLError.Code { get }

    public static var notConnectedToInternet: URLError.Code { get }

    public static var redirectToNonExistentLocation: URLError.Code { get }

    public static var badServerResponse: URLError.Code { get }

    public static var userCancelledAuthentication: URLError.Code { get }

    public static var userAuthenticationRequired: URLError.Code { get }

    public static var zeroByteResource: URLError.Code { get }

    public static var cannotDecodeRawData: URLError.Code { get }

    public static var cannotDecodeContentData: URLError.Code { get }

    public static var cannotParseResponse: URLError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    public static var appTransportSecurityRequiresSecureConnection: URLError.Code { get }

    public static var fileDoesNotExist: URLError.Code { get }

    public static var fileIsDirectory: URLError.Code { get }

    public static var noPermissionsToReadFile: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var dataLengthExceedsMaximum: URLError.Code { get }

    public static var secureConnectionFailed: URLError.Code { get }

    public static var serverCertificateHasBadDate: URLError.Code { get }

    public static var serverCertificateUntrusted: URLError.Code { get }

    public static var serverCertificateHasUnknownRoot: URLError.Code { get }

    public static var serverCertificateNotYetValid: URLError.Code { get }

    public static var clientCertificateRejected: URLError.Code { get }

    public static var clientCertificateRequired: URLError.Code { get }

    public static var cannotLoadFromNetwork: URLError.Code { get }

    public static var cannotCreateFile: URLError.Code { get }

    public static var cannotOpenFile: URLError.Code { get }

    public static var cannotCloseFile: URLError.Code { get }

    public static var cannotWriteToFile: URLError.Code { get }

    public static var cannotRemoveFile: URLError.Code { get }

    public static var cannotMoveFile: URLError.Code { get }

    public static var downloadDecodingFailedMidStream: URLError.Code { get }

    public static var downloadDecodingFailedToComplete: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var internationalRoamingOff: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var callIsActive: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var dataNotAllowed: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var requestBodyStreamExhausted: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var backgroundSessionRequiresSharedContainer: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var backgroundSessionInUseByAnotherProcess: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var backgroundSessionWasDisconnected: URLError.Code { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLError.Code {

    public static var unknown: URLError.Code { get }

    public static var cancelled: URLError.Code { get }

    public static var badURL: URLError.Code { get }

    public static var timedOut: URLError.Code { get }

    public static var unsupportedURL: URLError.Code { get }

    public static var cannotFindHost: URLError.Code { get }

    public static var cannotConnectToHost: URLError.Code { get }

    public static var networkConnectionLost: URLError.Code { get }

    public static var dnsLookupFailed: URLError.Code { get }

    public static var httpTooManyRedirects: URLError.Code { get }

    public static var resourceUnavailable: URLError.Code { get }

    public static var notConnectedToInternet: URLError.Code { get }

    public static var redirectToNonExistentLocation: URLError.Code { get }

    public static var badServerResponse: URLError.Code { get }

    public static var userCancelledAuthentication: URLError.Code { get }

    public static var userAuthenticationRequired: URLError.Code { get }

    public static var zeroByteResource: URLError.Code { get }

    public static var cannotDecodeRawData: URLError.Code { get }

    public static var cannotDecodeContentData: URLError.Code { get }

    public static var cannotParseResponse: URLError.Code { get }

    @available(macOS 10.11, iOS 9.0, *)
    public static var appTransportSecurityRequiresSecureConnection: URLError.Code { get }

    public static var fileDoesNotExist: URLError.Code { get }

    public static var fileIsDirectory: URLError.Code { get }

    public static var noPermissionsToReadFile: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var dataLengthExceedsMaximum: URLError.Code { get }

    public static var secureConnectionFailed: URLError.Code { get }

    public static var serverCertificateHasBadDate: URLError.Code { get }

    public static var serverCertificateUntrusted: URLError.Code { get }

    public static var serverCertificateHasUnknownRoot: URLError.Code { get }

    public static var serverCertificateNotYetValid: URLError.Code { get }

    public static var clientCertificateRejected: URLError.Code { get }

    public static var clientCertificateRequired: URLError.Code { get }

    public static var cannotLoadFromNetwork: URLError.Code { get }

    public static var cannotCreateFile: URLError.Code { get }

    public static var cannotOpenFile: URLError.Code { get }

    public static var cannotCloseFile: URLError.Code { get }

    public static var cannotWriteToFile: URLError.Code { get }

    public static var cannotRemoveFile: URLError.Code { get }

    public static var cannotMoveFile: URLError.Code { get }

    public static var downloadDecodingFailedMidStream: URLError.Code { get }

    public static var downloadDecodingFailedToComplete: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var internationalRoamingOff: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var callIsActive: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var dataNotAllowed: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var requestBodyStreamExhausted: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var backgroundSessionRequiresSharedContainer: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var backgroundSessionInUseByAnotherProcess: URLError.Code { get }

    @available(macOS 10.10, iOS 8.0, *)
    public static var backgroundSessionWasDisconnected: URLError.Code { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.BackgroundTaskCancelledReason : Equatable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.BackgroundTaskCancelledReason : Hashable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.BackgroundTaskCancelledReason : RawRepresentable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.NetworkUnavailableReason : Equatable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.NetworkUnavailableReason : Hashable {
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLError.NetworkUnavailableReason : RawRepresentable {
}

/// A single name-value pair, for use with `URLComponents`.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLQueryItem : Hashable, Equatable, Sendable {

    public var name: String

    public var value: String?

    public init(name: String, value: String?)

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public static func == (lhs: URLQueryItem, rhs: URLQueryItem) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLQueryItem : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLQueryItem : ReferenceConvertible {

    public typealias ReferenceType = NSURLQueryItem
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLRequest : ReferenceConvertible, Equatable, Hashable, Sendable {

    public typealias ReferenceType = NSURLRequest

    public typealias CachePolicy = NSURLRequest.CachePolicy

    public typealias NetworkServiceType = NSURLRequest.NetworkServiceType

    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    public typealias Attribution = NSURLRequest.Attribution

    /// Creates and initializes a URLRequest with the given URL and cache policy.
    /// - parameter: url The URL for the request. 
    /// - parameter: cachePolicy The cache policy for the request. Defaults to `.useProtocolCachePolicy`
    /// - parameter: timeoutInterval The timeout interval for the request. See the commentary for the `timeoutInterval` for more information on timeout intervals. Defaults to 60.0
    public init(url: URL, cachePolicy: URLRequest.CachePolicy = .useProtocolCachePolicy, timeoutInterval: TimeInterval = 60.0)

    /// The URL of the receiver.
    public var url: URL?

    /// The cache policy of the receiver.
    public var cachePolicy: URLRequest.CachePolicy

    /// Returns the timeout interval of the receiver.
    /// - discussion: The timeout interval specifies the limit on the idle
    /// interval allotted to a request in the process of loading. The "idle
    /// interval" is defined as the period of time that has passed since the
    /// last instance of load activity occurred for a request that is in the
    /// process of loading. Hence, when an instance of load activity occurs
    /// (e.g. bytes are received from the network for a request), the idle
    /// interval for a request is reset to 0. If the idle interval ever
    /// becomes greater than or equal to the timeout interval, the request
    /// is considered to have timed out. This timeout interval is measured
    /// in seconds.
    public var timeoutInterval: TimeInterval

    /// The main document URL associated with this load.
    /// - discussion: This URL is used for the cookie "same domain as main
    /// document" policy, attributing this request as a sub-resource of a
    /// user-specified URL, and possibly other things in the future.
    public var mainDocumentURL: URL?

    /// The URLRequest.NetworkServiceType associated with this request.
    /// - discussion: This will return URLRequest.NetworkServiceType.default for requests that have
    /// not explicitly set a networkServiceType
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var networkServiceType: URLRequest.NetworkServiceType

    /// `true` if the receiver is allowed to use the built in cellular radios to
    /// satisfy the request, `false` otherwise.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var allowsCellularAccess: Bool

    /// `true` if the receiver is allowed to use an interface marked as expensive to
    /// satify the request, `false` otherwise.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public var allowsExpensiveNetworkAccess: Bool

    /// `true` if the receiver is allowed to use an interface marked as constrained to
    /// satify the request, `false` otherwise.
    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
    public var allowsConstrainedNetworkAccess: Bool

    /// `true` if server endpoint is known to support HTTP/3. Enables QUIC racing
    /// without HTTP/3 service discovery. Defaults to `false`.
    /// The default may be `true` in a future OS update.
    @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
    public var assumesHTTP3Capable: Bool

    /// Set to indicate whether the user or developer specified the URL.
    @available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
    public var attribution: URLRequest.Attribution

    /// `true` if the request is required to do DNSSEC validation during DNS lookup.
    /// `false` otherwise. Defaults to `false`.
    @available(macOS 13.0, iOS 16.1, watchOS 9.1, tvOS 16.1, *)
    public var requiresDNSSECValidation: Bool

    /// `true` if the request is allowed to store and use DNS answers, potentially beyond TTL expiry, in a persistent
    /// per-process cache, `false` otherwise. Defaults to `false`. This should only be set to
    /// `true` for hostnames whose resolutions are not expected to change across networks.
    @available(macOS 15.0, iOS 18.0, watchOS 11.0, tvOS 18.0, visionOS 2.0, *)
    public var allowsPersistentDNS: Bool

    /// The HTTP request method of the receiver.
    public var httpMethod: String?

    /// A dictionary containing all the HTTP header fields of the
    /// receiver.
    public var allHTTPHeaderFields: [String : String]?

    /// The value which corresponds to the given header
    /// field. Note that, in keeping with the HTTP RFC, HTTP header field
    /// names are case-insensitive.
    /// - parameter: field the header field name to use for the lookup (case-insensitive).
    public func value(forHTTPHeaderField field: String) -> String?

    /// If a value was previously set for the given header
    /// field, that value is replaced with the given value. Note that, in
    /// keeping with the HTTP RFC, HTTP header field names are
    /// case-insensitive.
    public mutating func setValue(_ value: String?, forHTTPHeaderField field: String)

    /// This method provides a way to add values to header
    /// fields incrementally. If a value was previously set for the given
    /// header field, the given value is appended to the previously-existing
    /// value. The appropriate field delimiter, a comma in the case of HTTP,
    /// is added by the implementation, and should not be added to the given
    /// value by the caller. Note that, in keeping with the HTTP RFC, HTTP
    /// header field names are case-insensitive.
    public mutating func addValue(_ value: String, forHTTPHeaderField field: String)

    /// This data is sent as the message body of the request, as
    /// in done in an HTTP POST request.
    public var httpBody: Data?

    /// The stream is returned for examination only; it is
    /// not safe for the caller to manipulate the stream in any way.  Also
    /// note that the HTTPBodyStream and HTTPBody are mutually exclusive - only
    /// one can be set on a given request.  Also note that the body stream is
    /// preserved across copies, but is LOST when the request is coded via the 
    /// NSCoding protocol
    public var httpBodyStream: InputStream?

    /// `true` if cookies will be sent with and set for this request; otherwise `false`.
    public var httpShouldHandleCookies: Bool

    @available(macOS 15.2, iOS 18.2, watchOS 11.2, tvOS 18.2, visionOS 2.2, *)
    public var cookiePartitionIdentifier: String?

    /// `true` if the receiver should transmit before the previous response
    /// is received.  `false` if the receiver should wait for the previous response
    /// before transmitting.
    @available(macOS, introduced: 10.10, deprecated: 15.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
    @available(iOS, introduced: 8.0, deprecated: 18.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
    @available(watchOS, introduced: 2.0, deprecated: 11.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
    @available(tvOS, introduced: 9.0, deprecated: 18.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
    @available(visionOS, introduced: 1.0, deprecated: 2.4, message: "Only supported in the classic loading mode, please adopt HTTP/2 and HTTP/3 instead")
    public var httpShouldUsePipelining: Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: URLRequest, rhs: URLRequest) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension URLRequest : CustomStringConvertible, CustomDebugStringConvertible, CustomReflectable {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
public struct URLResource : Hashable, Codable, Sendable {

    public let bundle: Bundle

    public let name: String

    public let subdirectory: String?

    public var locale: Locale

    public init(name: String, subdirectory: String? = nil, locale: Locale = .current, bundle: Bundle = .main)

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (a: URLResource, b: URLResource) -> Bool

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

/// URLs to file system resources support the properties defined below.
///
/// Note that not all property values will exist for all file system URLs. For example, if a file is located on a volume that does not support creation dates, it is valid to request the creation date property, but the returned value will be nil, and no error will be generated.
///
/// Only the fields requested by the keys you pass into the `URL` function to receive this value will be populated. The others will return `nil` regardless of the underlying property on the file system. As a convenience, volume resource values can be requested from any file system URL. The value returned will reflect the property value for the volume on which the resource is located.
@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public struct URLResourceValues {

    public init()

    /// A loosely-typed dictionary containing all keys and values.
    ///
    /// If you have set temporary keys or non-standard keys, you can find them in here.
    public var allValues: [URLResourceKey : Any] { get }

    /// The resource name provided by the file system.
    public var name: String?

    /// Localized or extension-hidden name as displayed to users.
    public var localizedName: String? { get }

    /// True for regular files.
    public var isRegularFile: Bool? { get }

    /// True for directories.
    public var isDirectory: Bool? { get }

    /// True for symlinks.
    public var isSymbolicLink: Bool? { get }

    /// True for the root directory of a volume.
    public var isVolume: Bool? { get }

    /// True for packaged directories.
    ///
    /// - note: You can only set or clear this property on directories; if you try to set this property on non-directory objects, the property is ignored. If the directory is a package for some other reason (extension type, etc), setting this property to false will have no effect.
    public var isPackage: Bool?

    /// True if resource is an application.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var isApplication: Bool? { get }

    /// True for system-immutable resources.
    public var isSystemImmutable: Bool? { get }

    /// True for user-immutable resources
    public var isUserImmutable: Bool?

    /// True for resources normally not displayed to users.
    ///
    /// - note: If the resource is a hidden because its name starts with a period, setting this property to false will not change the property.
    public var isHidden: Bool?

    /// True for resources whose filename extension is removed from the localized name property.
    public var hasHiddenExtension: Bool?

    /// The date the resource was created.
    public var creationDate: Date?

    /// The date the resource was last accessed.
    public var contentAccessDate: Date?

    /// The time the resource content was last modified.
    public var contentModificationDate: Date?

    /// The time the resource's attributes were last modified.
    public var attributeModificationDate: Date? { get }

    /// Number of hard links to the resource.
    public var linkCount: Int? { get }

    /// The resource's parent directory, if any.
    public var parentDirectory: URL? { get }

    /// URL of the volume on which the resource is stored.
    public var volume: URL? { get }

    /// Uniform type identifier (UTI) for the resource.
    @available(macOS, introduced: 10.10, deprecated: 100000.0, message: "Use .contentType instead")
    @available(iOS, introduced: 8.0, deprecated: 100000.0, message: "Use .contentType instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use .contentType instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use .contentType instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use .contentType instead")
    public var typeIdentifier: String? { get }

    /// User-visible type or "kind" description.
    public var localizedTypeDescription: String? { get }

    /// The label number assigned to the resource.
    public var labelNumber: Int?

    /// The user-visible label text.
    public var localizedLabel: String? { get }

    /// An identifier which can be used to compare two file system objects for equality using `isEqual`.
    ///
    /// Two object identifiers are equal if they have the same file system path or if the paths are linked to same inode on the same file system. This identifier is not persistent across system restarts.
    public var fileResourceIdentifier: (any NSCopying & NSSecureCoding & NSObjectProtocol)? { get }

    /// An identifier that can be used to identify the volume the file system object is on.
    ///
    /// Other objects on the same volume will have the same volume identifier and can be compared using for equality using `isEqual`. This identifier is not persistent across system restarts.
    public var volumeIdentifier: (any NSCopying & NSSecureCoding & NSObjectProtocol)? { get }

    /// The file system's internal inode identifier for the item. This value is not stable for all file systems or
    /// across all mounts, so it should be used sparingly and not persisted. It is useful, for example, to match URLs from
    /// the URL enumerator with paths from FSEvents.
    @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
    public var fileIdentifier: UInt64? { get }

    /// A 64-bit value assigned by APFS that identifies a file's content data stream. Only cloned files and their originals can have the same identifier.
    @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
    public var fileContentIdentifier: Int64? { get }

    /// The optimal block size when reading or writing this file's data, or nil if not available.
    public var preferredIOBlockSize: Int? { get }

    /// True if this process (as determined by EUID) can read the resource.
    public var isReadable: Bool? { get }

    /// True if this process (as determined by EUID) can write to the resource.
    public var isWritable: Bool? { get }

    /// True if this process (as determined by EUID) can execute a file resource or search a directory resource.
    public var isExecutable: Bool? { get }

    /// The file system object's security information encapsulated in a FileSecurity object.
    public var fileSecurity: NSFileSecurity?

    /// True if resource should be excluded from backups, false otherwise.
    ///
    /// This property is only useful for excluding cache and other application support files which are not needed in a backup. Some operations commonly made to user documents will cause this property to be reset to false and so this property should not be used on user documents.
    public var isExcludedFromBackup: Bool?

    /// The URL's path as a file system path.
    public var path: String? { get }

    /// The URL's path as a canonical absolute file system path.
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public var canonicalPath: String? { get }

    /// True if this URL is a file system trigger directory. Traversing or opening a file system trigger will cause an attempt to mount a file system on the trigger directory.
    public var isMountTrigger: Bool? { get }

    /// An opaque generation identifier which can be compared using `==` to determine if the data in a document has been modified.
    ///
    /// For URLs which refer to the same file inode, the generation identifier will change when the data in the file's data fork is changed (changes to extended attributes or other file system metadata do not change the generation identifier). For URLs which refer to the same directory inode, the generation identifier will change when direct children of that directory are added, removed or renamed (changes to the data of the direct children of that directory will not change the generation identifier). The generation identifier is persistent across system restarts. The generation identifier is tied to a specific document on a specific volume and is not transferred when the document is copied to another volume. This property is not supported by all volumes.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var generationIdentifier: (any NSCopying & NSSecureCoding & NSObjectProtocol)? { get }

    /// The document identifier -- a value assigned by the kernel to a document (which can be either a file or directory) and is used to identify the document regardless of where it gets moved on a volume.
    ///
    /// The document identifier survives "safe save" operations; i.e it is sticky to the path it was assigned to (`replaceItem(at:,withItemAt:,backupItemName:,options:,resultingItem:) throws` is the preferred safe-save API). The document identifier is persistent across system restarts. The document identifier is not transferred when the file is copied. Document identifiers are only unique within a single volume. This property is not supported by all volumes.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var documentIdentifier: Int? { get }

    /// The date the resource was created, or renamed into or within its parent directory. Note that inconsistent behavior may be observed when this attribute is requested on hard-linked items. This property is not supported by all volumes.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var addedToDirectoryDate: Date? { get }

    /// True if the file may have extended attributes. False guarantees there are none.
    @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
    public var mayHaveExtendedAttributes: Bool? { get }

    /// True if the file can be deleted by the file system when asked to free space.
    @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
    public var isPurgeable: Bool? { get }

    /// True if the file has sparse regions.
    @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
    public var isSparse: Bool? { get }

    /// True for cloned files and their originals that may share all, some, or no data blocks.
    @available(macOS 11.0, iOS 14.0, tvOS 14.0, watchOS 7.0, *)
    public var mayShareFileContent: Bool? { get }

    /// Returns the file system object type.
    public var fileResourceType: URLFileResourceType? { get }

    /// Returns the count of file system objects contained in the directory. If the URL is not a directory or the file system cannot cheaply compute the value, `nil` is returned.
    @available(macOS 14.0, iOS 17.0, tvOS 17.0, watchOS 10.0, *)
    public var directoryEntryCount: Int? { get }

    /// The user-visible volume format.
    public var volumeLocalizedFormatDescription: String? { get }

    /// Total volume capacity in bytes.
    public var volumeTotalCapacity: Int? { get }

    /// Total free space in bytes.
    public var volumeAvailableCapacity: Int? { get }

    /// Total available capacity in bytes for "Important" resources, including space expected to be cleared by purging non-essential and cached resources.
    ///
    /// "Important" means something that the user or application clearly expects to be present on the local system, but is ultimately replaceable. This would include items that the user has explicitly requested via the UI, and resources that an application requires in order to provide functionality.
    /// Examples: A video that the user has explicitly requested to watch but has not yet finished watching or an audio file that the user has requested to download.
    /// This value should not be used in determining if there is room for an irreplaceable resource. In the case of irreplaceable resources, always attempt to save the resource regardless of available capacity and handle failure as gracefully as possible.
    @available(macOS 10.13, iOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var volumeAvailableCapacityForImportantUsage: Int64? { get }

    /// Total available capacity in bytes for "Opportunistic" resources, including space expected to be cleared by purging non-essential and cached resources.
    ///
    /// "Opportunistic" means something that the user is likely to want but does not expect to be present on the local system, but is ultimately non-essential and replaceable. This would include items that will be created or downloaded without an explicit request from the user on the current device.
    /// Examples: A background download of a newly available episode of a TV series that a user has been recently watching, a piece of content explicitly requested on another device, and a new document saved to a network server by the current user from another device.
    @available(macOS 10.13, iOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var volumeAvailableCapacityForOpportunisticUsage: Int64? { get }

    /// Total number of resources on the volume.
    public var volumeResourceCount: Int? { get }

    /// True if the volume format supports persistent object identifiers and can look up file system objects by their IDs.
    public var volumeSupportsPersistentIDs: Bool? { get }

    /// True if the volume format supports symbolic links.
    public var volumeSupportsSymbolicLinks: Bool? { get }

    /// True if the volume format supports hard links.
    public var volumeSupportsHardLinks: Bool? { get }

    /// True if the volume format supports a journal used to speed recovery in case of unplanned restart (such as a power outage or crash). This does not necessarily mean the volume is actively using a journal.
    public var volumeSupportsJournaling: Bool? { get }

    /// True if the volume is currently using a journal for speedy recovery after an unplanned restart.
    public var volumeIsJournaling: Bool? { get }

    /// True if the volume format supports sparse files, that is, files which can have 'holes' that have never been written to, and thus do not consume space on disk. A sparse file may have an allocated size on disk that is less than its logical length.
    public var volumeSupportsSparseFiles: Bool? { get }

    /// For security reasons, parts of a file (runs) that have never been written to must appear to contain zeroes. True if the volume keeps track of allocated but unwritten runs of a file so that it can substitute zeroes without actually writing zeroes to the media.
    public var volumeSupportsZeroRuns: Bool? { get }

    /// True if the volume format treats upper and lower case characters in file and directory names as different. Otherwise an upper case character is equivalent to a lower case character, and you can't have two names that differ solely in the case of the characters.
    public var volumeSupportsCaseSensitiveNames: Bool? { get }

    /// True if the volume format preserves the case of file and directory names.  Otherwise the volume may change the case of some characters (typically making them all upper or all lower case).
    public var volumeSupportsCasePreservedNames: Bool? { get }

    /// True if the volume supports reliable storage of times for the root directory.
    public var volumeSupportsRootDirectoryDates: Bool? { get }

    /// True if the volume supports returning volume size values (`volumeTotalCapacity` and `volumeAvailableCapacity`).
    public var volumeSupportsVolumeSizes: Bool? { get }

    /// True if the volume can be renamed.
    public var volumeSupportsRenaming: Bool? { get }

    /// True if the volume implements whole-file flock(2) style advisory locks, and the O_EXLOCK and O_SHLOCK flags of the open(2) call.
    public var volumeSupportsAdvisoryFileLocking: Bool? { get }

    /// True if the volume implements extended security (ACLs).
    public var volumeSupportsExtendedSecurity: Bool? { get }

    /// True if the volume should be visible via the GUI (i.e., appear on the Desktop as a separate volume).
    public var volumeIsBrowsable: Bool? { get }

    /// The largest file size (in bytes) supported by this file system, or nil if this cannot be determined.
    public var volumeMaximumFileSize: Int? { get }

    /// True if the volume's media is ejectable from the drive mechanism under software control.
    public var volumeIsEjectable: Bool? { get }

    /// True if the volume's media is removable from the drive mechanism.
    public var volumeIsRemovable: Bool? { get }

    /// True if the volume's device is connected to an internal bus, false if connected to an external bus, or nil if not available.
    public var volumeIsInternal: Bool? { get }

    /// True if the volume is automounted. Note: do not mistake this with the functionality provided by kCFURLVolumeSupportsBrowsingKey.
    public var volumeIsAutomounted: Bool? { get }

    /// True if the volume is stored on a local device.
    public var volumeIsLocal: Bool? { get }

    /// True if the volume is read-only.
    public var volumeIsReadOnly: Bool? { get }

    /// The volume's creation date, or nil if this cannot be determined.
    public var volumeCreationDate: Date? { get }

    /// The `URL` needed to remount a network volume, or nil if not available.
    public var volumeURLForRemounting: URL? { get }

    /// The volume's persistent `UUID` as a string, or nil if a persistent `UUID` is not available for the volume.
    public var volumeUUIDString: String? { get }

    /// The name of the volume
    public var volumeName: String?

    /// The user-presentable name of the volume
    public var volumeLocalizedName: String? { get }

    /// True if the volume is encrypted.
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public var volumeIsEncrypted: Bool? { get }

    /// True if the volume is the root filesystem.
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public var volumeIsRootFileSystem: Bool? { get }

    /// True if the volume supports transparent decompression of compressed files using decmpfs.
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public var volumeSupportsCompression: Bool? { get }

    /// True if the volume supports clonefile(2).
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public var volumeSupportsFileCloning: Bool? { get }

    /// True if the volume supports renamex_np(2)'s RENAME_SWAP option.
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public var volumeSupportsSwapRenaming: Bool? { get }

    /// True if the volume supports renamex_np(2)'s RENAME_EXCL option.
    @available(macOS 10.12, iOS 10.0, tvOS 10.0, watchOS 3.0, *)
    public var volumeSupportsExclusiveRenaming: Bool? { get }

    /// True if the volume supports making files immutable with isUserImmutable or isSystemImmutable.
    @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
    public var volumeSupportsImmutableFiles: Bool? { get }

    /// True if the volume supports setting POSIX access permissions with fileSecurity.
    @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
    public var volumeSupportsAccessPermissions: Bool? { get }

    /// Returns the name of the file system type.
    @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
    public var volumeTypeName: String? { get }

    /// Returns the file system subtype.
    @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
    public var volumeSubtype: Int? { get }

    /// Returns the file system device location.
    @available(macOS 13.3, iOS 16.4, tvOS 16.4, watchOS 9.4, *)
    public var volumeMountFromLocation: String? { get }

    /// True if this item is synced to the cloud, false if it is only a local file.
    public var isUbiquitousItem: Bool? { get }

    /// True if this item has conflicts outstanding.
    public var ubiquitousItemHasUnresolvedConflicts: Bool? { get }

    /// True if data is being downloaded for this item.
    public var ubiquitousItemIsDownloading: Bool? { get }

    /// True if there is data present in the cloud for this item.
    public var ubiquitousItemIsUploaded: Bool? { get }

    /// True if data is being uploaded for this item.
    public var ubiquitousItemIsUploading: Bool? { get }

    /// Returns the download status of this item.
    public var ubiquitousItemDownloadingStatus: URLUbiquitousItemDownloadingStatus? { get }

    /// Returns the error when downloading the item from iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h
    public var ubiquitousItemDownloadingError: NSError? { get }

    /// Returns the error when uploading the item to iCloud failed, see the NSUbiquitousFile section in FoundationErrors.h
    public var ubiquitousItemUploadingError: NSError? { get }

    /// Returns whether a download of this item has already been requested with an API like `startDownloadingUbiquitousItem(at:) throws`.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var ubiquitousItemDownloadRequested: Bool? { get }

    /// Returns the name of this item's container as displayed to users.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var ubiquitousItemContainerDisplayName: String? { get }

    /// True if the item is excluded from sync, which means it is locally on disk but won't be available on the server. An excluded item is no longer ubiquitous.
    @available(macOS 11.3, iOS 14.5, watchOS 7.4, tvOS 14.5, *)
    public var ubiquitousItemIsExcludedFromSync: Bool?

    /// True if ubiquitous item is shared.
    @available(macOS 10.13, iOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var ubiquitousItemIsShared: Bool? { get }

    /// The current user's role for this shared item, or nil if not shared.
    @available(macOS 10.13, iOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var ubiquitousSharedItemCurrentUserRole: URLUbiquitousSharedItemRole? { get }

    /// The permissions for the current user, or nil if not shared.
    @available(macOS 10.13, iOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var ubiquitousSharedItemCurrentUserPermissions: URLUbiquitousSharedItemPermissions? { get }

    /// The name components for the owner, or nil if not shared.
    @available(macOS 10.13, iOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var ubiquitousSharedItemOwnerNameComponents: PersonNameComponents? { get }

    /// The name components for the most recent editor, or nil if not shared.
    @available(macOS 10.13, iOS 11.0, *)
    @available(tvOS, unavailable)
    @available(watchOS, unavailable)
    public var ubiquitousSharedItemMostRecentEditorNameComponents: PersonNameComponents? { get }

    /// The protection level for this file
    @available(macOS 11.0, iOS 9.0, *)
    public var fileProtection: URLFileProtection? { get }

    /// Total file size in bytes
    ///
    /// - note: Only applicable to regular files.
    public var fileSize: Int? { get }

    /// Total size allocated on disk for the file in bytes (number of blocks times block size)
    ///
    /// - note: Only applicable to regular files.
    public var fileAllocatedSize: Int? { get }

    /// Total displayable size of the file in bytes (this may include space used by metadata), or nil if not available.
    ///
    /// - note: Only applicable to regular files.
    public var totalFileSize: Int? { get }

    /// Total allocated size of the file in bytes (this may include space used by metadata), or nil if not available. This can be less than the value returned by `totalFileSize` if the resource is compressed.
    ///
    /// - note: Only applicable to regular files.
    public var totalFileAllocatedSize: Int? { get }

    /// true if the resource is a Finder alias file or a symlink, false otherwise
    ///
    /// - note: Only applicable to regular files.
    public var isAliasFile: Bool? { get }
}

extension URLResourceValues {

    /// The supported sync controls on the item.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public var ubiquitousItemSupportedSyncControls: NSFileManagerSupportedSyncControls? { get }

    /// True if the sync of the item has been paused.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public var ubiquitousItemIsSyncPaused: Bool? { get }
}

/// Represents UUID strings, which can be used to uniquely identify types, interfaces, and other items.
@available(macOS 10.8, iOS 6.0, tvOS 9.0, watchOS 2.0, *)
public struct UUID : Hashable, Equatable, CustomStringConvertible, Sendable {

    public var uuid: (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8) { get }

    public init()

    /// Create a UUID from a string such as "E621E1F8-C36C-495A-93FC-0C247A3E6E5F".
    ///
    /// Returns nil for invalid strings.
    public init?(uuidString string: String)

    /// Create a UUID from a `uuid_t`.
    public init(uuid: uuid_t)

    /// Returns a string created from the UUID, such as "E621E1F8-C36C-495A-93FC-0C247A3E6E5F"
    public var uuidString: String { get }

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: UUID, rhs: UUID) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.8, iOS 6.0, tvOS 9.0, watchOS 2.0, *)
extension UUID : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.8, iOS 6.0, tvOS 9.0, watchOS 2.0, *)
extension UUID : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension UUID : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
    public static func < (lhs: UUID, rhs: UUID) -> Bool
}

@available(macOS 10.10, iOS 8.0, tvOS 9.0, watchOS 2.0, *)
extension UUID : ReferenceConvertible {

    public typealias ReferenceType = NSUUID
}

/// Returns the bundle most likely to contain resources for the calling code.
///
/// Code in an app, app extension, framework, etc. will return the bundle associated with that target.
/// Code in a Swift Package target will return the resource bundle associated with that target.
@available(macOS 12, iOS 15, tvOS 15, watchOS 8, visionOS 1, *)
@freestanding(expression) public macro bundle() -> Bundle = #externalMacro(module: "FoundationMacros", type: "BundleMacro")

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public var kCFStringEncodingASCII: CFStringEncoding { get }

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public func pow(_ x: Decimal, _ y: Int) -> Decimal

public typealias uuid_string_t = (Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8, Int8)

public typealias uuid_t = (UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8, UInt8)

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NSObject {

    /// A publisher that emits events when the value of a KVO-compliant property changes.
    public struct KeyValueObservingPublisher<Subject, Value> : Equatable where Subject : NSObject {

        public let object: Subject

        public let keyPath: KeyPath<Subject, Value>

        public let options: NSKeyValueObservingOptions

        public init(object: Subject, keyPath: KeyPath<Subject, Value>, options: NSKeyValueObservingOptions)

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (lhs: NSObject.KeyValueObservingPublisher<Subject, Value>, rhs: NSObject.KeyValueObservingPublisher<Subject, Value>) -> Bool
    }
}

@available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
extension FilePath {

    /// Creates a file path from a URL
    ///
    /// The result is nil if `url` doesn't refer to a local file.
    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    public init?(_ url: URL)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension NSAttributedString {

    public convenience init(contentsOf url: URL, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws

    public convenience init(markdown: Data, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws

    public convenience init(markdown: String, options: AttributedString.MarkdownParsingOptions = .init(), baseURL: URL? = nil) throws
}

extension Dimension {

    /// Creates a `Dimension` which the specified `locale` prefers.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public convenience init(forLocale: Locale)
}

extension UnitTemperature {

    /// Creates a `UnitTemperature` which the specified `locale` prefers for the specific `usage`.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public convenience init(forLocale: Locale, usage: MeasurementFormatUnitUsage<UnitTemperature> = .general)
}

extension UnitLength {

    /// Creates a `UnitLength` which the specified `locale` prefers for the specific `usage`.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public convenience init(forLocale: Locale, usage: MeasurementFormatUnitUsage<UnitLength> = .general)
}

extension UnitEnergy {

    /// Creates a `UnitEnergy` which the specified `locale` prefers for the specific `usage`.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public convenience init(forLocale: Locale, usage: MeasurementFormatUnitUsage<UnitEnergy> = .general)
}

extension UnitMass {

    /// Creates a `UnitMass` which the specified `locale` prefers for the specific `usage`.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public convenience init(forLocale: Locale, usage: MeasurementFormatUnitUsage<UnitMass> = .general)
}

extension UnitPressure {

    /// Creates a `UnitPressure` which the specified `locale` prefers for the specific `usage`.
    @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
    public convenience init(forLocale: Locale, usage: MeasurementFormatUnitUsage<UnitPressure> = .general)
}

extension UnitSpeed {

    /// Creates a `UnitSpeed` which the specified `locale` prefers for the specific `usage`.
    @available(macOS 14, iOS 16, tvOS 17, watchOS 9, *)
    public convenience init(forLocale: Locale, usage: MeasurementFormatUnitUsage<UnitSpeed> = .general)
}

extension UnitVolume {

    /// Creates a `UnitVolume` which the specified `locale` prefers for the specific `usage`.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public convenience init(forLocale: Locale, usage: MeasurementFormatUnitUsage<UnitVolume> = .general)
}

extension NSValue {

    @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
    public func value<StoredType>(of type: StoredType.Type) -> StoredType?
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension RunLoop : Scheduler {

    /// The scheduler time type used by the run loop.
    public struct SchedulerTimeType : Strideable, Codable, Hashable, Sendable {

        /// The date represented by this type.
        public var date: Date

        /// Initializes a run loop scheduler time with the given date.
        ///
        /// - Parameter date: The date to represent.
        public init(_ date: Date)

        /// Returns the distance to another run loop scheduler time.
        ///
        /// - Parameter other: Another dispatch queue time.
        /// - Returns: The time interval between this time and the provided time.
        public func distance(to other: RunLoop.SchedulerTimeType) -> RunLoop.SchedulerTimeType.Stride

        /// Returns a run loop scheduler time calculated by advancing this instance’s time by the given interval.
        ///
        /// - Parameter n: A time interval to advance.
        /// - Returns: A dispatch queue time advanced by the given interval from this instance’s time.
        public func advanced(by n: RunLoop.SchedulerTimeType.Stride) -> RunLoop.SchedulerTimeType

        /// The interval by which run loop times advance.
        public struct Stride : ExpressibleByFloatLiteral, Comparable, SignedNumeric, Codable, SchedulerTimeIntervalConvertible, Sendable {

            /// A type that represents a floating-point literal.
            ///
            /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
            /// where available.
            public typealias FloatLiteralType = TimeInterval

            /// A type that represents an integer literal.
            ///
            /// The standard library integer and floating-point types are all valid types
            /// for `IntegerLiteralType`.
            public typealias IntegerLiteralType = TimeInterval

            /// A type that can represent the absolute value of any possible value of the
            /// conforming type.
            public typealias Magnitude = TimeInterval

            /// The value of this time interval in seconds.
            public var magnitude: TimeInterval

            /// The value of this time interval in seconds.
            public var timeInterval: TimeInterval { get }

            /// Creates an instance initialized to the specified integer value.
            ///
            /// Do not call this initializer directly. Instead, initialize a variable or
            /// constant using an integer literal. For example:
            ///
            ///     let x = 23
            ///
            /// In this example, the assignment to the `x` constant calls this integer
            /// literal initializer behind the scenes.
            ///
            /// - Parameter value: The value to create.
            public init(integerLiteral value: TimeInterval)

            /// Creates an instance initialized to the specified floating-point value.
            ///
            /// Do not call this initializer directly. Instead, initialize a variable or
            /// constant using a floating-point literal. For example:
            ///
            ///     let x = 21.5
            ///
            /// In this example, the assignment to the `x` constant calls this
            /// floating-point literal initializer behind the scenes.
            ///
            /// - Parameter value: The value to create.
            public init(floatLiteral value: TimeInterval)

            public init(_ timeInterval: TimeInterval)

            /// Creates a new instance from the given integer, if it can be represented
            /// exactly.
            ///
            /// If the value passed as `source` is not representable exactly, the result
            /// is `nil`. In the following example, the constant `x` is successfully
            /// created from a value of `100`, while the attempt to initialize the
            /// constant `y` from `1_000` fails because the `Int8` type can represent
            /// `127` at maximum:
            ///
            ///     let x = Int8(exactly: 100)
            ///     // x == Optional(100)
            ///     let y = Int8(exactly: 1_000)
            ///     // y == nil
            ///
            /// - Parameter source: A value to convert to this type.
            public init?<T>(exactly source: T) where T : BinaryInteger

            /// Returns a Boolean value indicating whether the value of the first
            /// argument is less than that of the second argument.
            ///
            /// This function is the only requirement of the `Comparable` protocol. The
            /// remainder of the relational operator functions are implemented by the
            /// standard library for any type that conforms to `Comparable`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func < (lhs: RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride) -> Bool

            /// Multiplies two values and produces their product.
            ///
            /// The multiplication operator (`*`) calculates the product of its two
            /// arguments. For example:
            ///
            ///     2 * 3                   // 6
            ///     100 * 21                // 2100
            ///     -10 * 15                // -150
            ///     3.5 * 2.25              // 7.875
            ///
            /// You cannot use `*` with arguments of different types. To multiply values
            /// of different types, convert one of the values to the other value's type.
            ///
            ///     let x: Int8 = 21
            ///     let y: Int = 1000000
            ///     Int(x) * y              // 21000000
            ///
            /// - Parameters:
            ///   - lhs: The first value to multiply.
            ///   - rhs: The second value to multiply.
            public static func * (lhs: RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride) -> RunLoop.SchedulerTimeType.Stride

            /// Adds two values and produces their sum.
            ///
            /// The addition operator (`+`) calculates the sum of its two arguments. For
            /// example:
            ///
            ///     1 + 2                   // 3
            ///     -10 + 15                // 5
            ///     -15 + -5                // -20
            ///     21.5 + 3.25             // 24.75
            ///
            /// You cannot use `+` with arguments of different types. To add values of
            /// different types, convert one of the values to the other value's type.
            ///
            ///     let x: Int8 = 21
            ///     let y: Int = 1000000
            ///     Int(x) + y              // 1000021
            ///
            /// - Parameters:
            ///   - lhs: The first value to add.
            ///   - rhs: The second value to add.
            public static func + (lhs: RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride) -> RunLoop.SchedulerTimeType.Stride

            /// Subtracts one value from another and produces their difference.
            ///
            /// The subtraction operator (`-`) calculates the difference of its two
            /// arguments. For example:
            ///
            ///     8 - 3                   // 5
            ///     -10 - 5                 // -15
            ///     100 - -5                // 105
            ///     10.5 - 100.0            // -89.5
            ///
            /// You cannot use `-` with arguments of different types. To subtract values
            /// of different types, convert one of the values to the other value's type.
            ///
            ///     let x: UInt8 = 21
            ///     let y: UInt = 1000000
            ///     y - UInt(x)             // 999979
            ///
            /// - Parameters:
            ///   - lhs: A numeric value.
            ///   - rhs: The value to subtract from `lhs`.
            public static func - (lhs: RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride) -> RunLoop.SchedulerTimeType.Stride

            /// Multiplies two values and stores the result in the left-hand-side
            /// variable.
            ///
            /// - Parameters:
            ///   - lhs: The first value to multiply.
            ///   - rhs: The second value to multiply.
            public static func *= (lhs: inout RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride)

            /// Adds two values and stores the result in the left-hand-side variable.
            ///
            /// - Parameters:
            ///   - lhs: The first value to add.
            ///   - rhs: The second value to add.
            public static func += (lhs: inout RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride)

            /// Subtracts the second value from the first and stores the difference in the
            /// left-hand-side variable.
            ///
            /// - Parameters:
            ///   - lhs: A numeric value.
            ///   - rhs: The value to subtract from `lhs`.
            public static func -= (lhs: inout RunLoop.SchedulerTimeType.Stride, rhs: RunLoop.SchedulerTimeType.Stride)

            /// Converts the specified number of seconds into an instance of this scheduler time type.
            public static func seconds(_ s: Int) -> RunLoop.SchedulerTimeType.Stride

            /// Converts the specified number of seconds, as a floating-point value, into an instance of this scheduler time type.
            public static func seconds(_ s: Double) -> RunLoop.SchedulerTimeType.Stride

            /// Converts the specified number of milliseconds into an instance of this scheduler time type.
            public static func milliseconds(_ ms: Int) -> RunLoop.SchedulerTimeType.Stride

            /// Converts the specified number of microseconds into an instance of this scheduler time type.
            public static func microseconds(_ us: Int) -> RunLoop.SchedulerTimeType.Stride

            /// Converts the specified number of nanoseconds into an instance of this scheduler time type.
            public static func nanoseconds(_ ns: Int) -> RunLoop.SchedulerTimeType.Stride

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: RunLoop.SchedulerTimeType.Stride, b: RunLoop.SchedulerTimeType.Stride) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Options that affect the operation of the run loop scheduler.
    public struct SchedulerOptions : Sendable {
    }

    /// Performs the action at the next possible opportunity.
    public func schedule(options: RunLoop.SchedulerOptions?, _ action: @escaping () -> Void)

    /// Performs the action at some time after the specified date.
    public func schedule(after date: RunLoop.SchedulerTimeType, tolerance: RunLoop.SchedulerTimeType.Stride, options: RunLoop.SchedulerOptions?, _ action: @escaping () -> Void)

    /// Performs the action at some time after the specified date, at the specified frequency, optionally taking into account tolerance if possible.
    public func schedule(after date: RunLoop.SchedulerTimeType, interval: RunLoop.SchedulerTimeType.Stride, tolerance: RunLoop.SchedulerTimeType.Stride, options: RunLoop.SchedulerOptions?, _ action: @escaping () -> Void) -> any Cancellable

    /// This scheduler’s definition of the current moment in time.
    public var now: RunLoop.SchedulerTimeType { get }

    /// The minimum tolerance allowed by the scheduler.
    public var minimumTolerance: RunLoop.SchedulerTimeType.Stride { get }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == URL.ParseStrategy {

    public static func url(scheme: URL.ParseStrategy.ComponentParseStrategy<String> = .required, user: URL.ParseStrategy.ComponentParseStrategy<String> = .optional, password: URL.ParseStrategy.ComponentParseStrategy<String> = .optional, host: URL.ParseStrategy.ComponentParseStrategy<String> = .required, port: URL.ParseStrategy.ComponentParseStrategy<Int> = .optional, path: URL.ParseStrategy.ComponentParseStrategy<String> = .optional, query: URL.ParseStrategy.ComponentParseStrategy<String> = .optional, fragment: URL.ParseStrategy.ComponentParseStrategy<String> = .optional) -> Self
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension FileManager {

    @available(*, deprecated, renamed: "replaceItemAt(_:withItemAt:backupItemName:options:)")
    public func replaceItemAtURL(originalItemURL: NSURL, withItemAtURL newItemURL: NSURL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> NSURL?

    @available(swift 4)
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func replaceItemAt(_ originalItemURL: URL, withItemAt newItemURL: URL, backupItemName: String? = nil, options: FileManager.ItemReplacementOptions = []) throws -> URL?

    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    @nonobjc public func enumerator(at url: URL, includingPropertiesForKeys keys: [URLResourceKey]?, options mask: FileManager.DirectoryEnumerationOptions = [], errorHandler handler: ((URL, any Error) -> Bool)? = nil) -> FileManager.DirectoryEnumerator?
}

extension FileHandle {

    @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
    public func readToEnd() throws -> Data?

    @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
    public func read(upToCount count: Int) throws -> Data?

    @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
    public func offset() throws -> UInt64

    @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
    @discardableResult
    public func seekToEnd() throws -> UInt64

    @available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *)
    public func write<T>(contentsOf data: T) throws where T : DataProtocol
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSCoder {

    public func decodeObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: String) -> DecodedObjectType? where DecodedObjectType : NSObject, DecodedObjectType : NSCoding

    @nonobjc public func decodeObject(of classes: [AnyClass]?, forKey key: String) -> Any?

    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @nonobjc public func decodeTopLevelObject() throws -> Any?

    @available(swift 4)
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    @available(macOS, introduced: 10.11, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @available(iOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @available(visionOS, introduced: 1.0, deprecated: 100000.0, message: "Use decodeTopLevelObject(of:forKey:) instead")
    @nonobjc public func decodeTopLevelObject(forKey key: String) throws -> Any?

    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public func decodeTopLevelObject<DecodedObjectType>(of cls: DecodedObjectType.Type, forKey key: String) throws -> DecodedObjectType? where DecodedObjectType : NSObject, DecodedObjectType : NSCoding

    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    @nonobjc public func decodeTopLevelObject(of classes: [AnyClass]?, forKey key: String) throws -> Any?

    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    @nonobjc public func decodeArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, forKey key: String) -> [DecodedObject]? where DecodedObject : NSObject, DecodedObject : NSSecureCoding

    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    @nonobjc public func decodeArrayOfObjects(ofClasses classes: [AnyClass], forKey key: String) -> [Any]?

    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    @nonobjc public func decodeDictionary<DecodedKey, DecodedObject>(withKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, forKey key: String) -> [DecodedKey : DecodedObject]? where DecodedKey : NSObject, DecodedKey : NSCopying, DecodedKey : NSSecureCoding, DecodedObject : NSObject, DecodedObject : NSSecureCoding

    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    @nonobjc public func decodeDictionary(withKeysOfClasses keyClasses: [AnyClass], objectsOfClasses classes: [AnyClass], forKey key: String) -> [AnyHashable : Any]?
}

extension NSKeyedArchiver {

    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    @nonobjc public func encodeEncodable<T>(_ value: T, forKey key: String) throws where T : Encodable
}

extension NSKeyedUnarchiver {

    @available(swift 4)
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    @available(macOS, introduced: 10.11, deprecated: 10.14, message: "Use unarchivedObject(ofClass:from:) instead")
    @available(iOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
    @available(tvOS, introduced: 9.0, deprecated: 12.0, message: "Use unarchivedObject(ofClass:from:) instead")
    @available(watchOS, introduced: 2.0, deprecated: 5.0, message: "Use unarchivedObject(ofClass:from:) instead")
    @nonobjc public class func unarchiveTopLevelObjectWithData(_ data: Data) throws -> Any?

    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    @nonobjc public static func unarchivedObject<DecodedObjectType>(ofClass cls: DecodedObjectType.Type, from data: Data) throws -> DecodedObjectType? where DecodedObjectType : NSObject, DecodedObjectType : NSCoding

    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    @nonobjc public static func unarchivedObject(ofClasses classes: [AnyClass], from data: Data) throws -> Any?

    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    @nonobjc public func decodeDecodable<T>(_ type: T.Type, forKey key: String) -> T? where T : Decodable

    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    @nonobjc public func decodeTopLevelDecodable<T>(_ type: T.Type, forKey key: String) throws -> T? where T : Decodable

    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    @nonobjc public static func unarchivedArrayOfObjects<DecodedObject>(ofClass cls: DecodedObject.Type, from data: Data) throws -> [DecodedObject]? where DecodedObject : NSObject, DecodedObject : NSSecureCoding

    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    @nonobjc public static func unarchivedArrayOfObjects(ofClasses classes: [AnyClass], from data: Data) throws -> [Any]?

    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    @nonobjc public static func unarchivedDictionary<DecodedKey, DecodedObject>(ofKeyClass keyClass: DecodedKey.Type, objectClass: DecodedObject.Type, from data: Data) throws -> [DecodedKey : DecodedObject]? where DecodedKey : NSObject, DecodedKey : NSCopying, DecodedKey : NSSecureCoding, DecodedObject : NSObject, DecodedObject : NSSecureCoding

    @available(macOS 11.0, iOS 14.0, watchOS 7.0, tvOS 14.0, *)
    @nonobjc public static func unarchivedDictionary(keysOfClasses keyClasses: [AnyClass], objectsOfClasses objectClasses: [AnyClass], from data: Data) throws -> [AnyHashable : Any]?
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Range where Bound == AttributedString.Index {

    /// Indicates whether the range is valid for use with the provided attributed string.
    /// - Parameter text: An attributed string used to validate the range.
    /// - Returns: `true` when the range is valid for use with the provided attributed string; otherwise, false. A range is valid if its lower and upper bounds are each either valid in the attributed string or equivalent to the string's `endIndex`.
    public func isValid(within text: some AttributedStringProtocol) -> Bool

    /// Indicates whether the range is valid for use with the provided discontiguous attributed string.
    /// - Parameter text: A discontiguous attributed string used to validate the range.
    /// - Returns: `true` when the range is valid for use with the provided discontiguous attributed string; otherwise, false. A range is valid if its lower and upper bounds are each either valid in the discontiguous attributed string or equivalent to the string's `endIndex`.
    public func isValid(within text: DiscontiguousAttributedSubstring) -> Bool
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension RangeSet where Bound == AttributedString.Index {

    /// Indicates whether the range set is valid for use with the provided attributed string.
    /// - Parameter text: An attributed string used to validate the range set.
    /// - Returns: `true` when the range set is valid for use with the provided attributed string; otherwise, false. A range set is valid if each of its ranges are valid in the attributed string.
    public func isValid(within text: some AttributedStringProtocol) -> Bool

    /// Indicates whether the range set is valid for use with the provided discontiguous attributed string.
    /// - Parameter text: A discontigious attributed string used to validate the range set.
    /// - Returns: `true` when the range set is valid for use with the provided discontiguous attributed string; otherwise, false. A range set is valid if each of its ranges are valid in the discontiguous attributed string.
    public func isValid(within text: DiscontiguousAttributedSubstring) -> Bool
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Range where Bound == Date {

    /// Formats the date range as an interval.
    public func formatted() -> String

    /// Formats the date range using the specified date and time format styles.
    public func formatted(date: Date.IntervalFormatStyle.DateStyle, time: Date.IntervalFormatStyle.TimeStyle) -> String

    /// Formats the date range using the specified style.
    public func formatted<S>(_ style: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Range<Date>
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == Date.ParseStrategy {

    public typealias DateStyle = Date.FormatStyle.DateStyle

    public typealias TimeStyle = Date.FormatStyle.TimeStyle

    /// Creates a regex component to match a localized date string following the specified format and capture the string as a `Date`.
    /// - Parameters:
    ///   - format: The date format that describes the localized date string. For example, `"\(month: .twoDigits)_\(day: .twoDigits)_\(year: .twoDigits)"` matches "05_04_22" as May 4th, 2022 in the Gregorian calendar.
    ///   - locale: The locale of the date string to be matched.
    ///   - timeZone: The time zone to create the matched date with.
    ///   - calendar: The calendar with which to interpret the date string. If nil, the default calendar of the specified `locale` is used.
    /// - Returns: A `RegexComponent` to match a localized date string.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public static func date(format: Date.FormatString, locale: Locale, timeZone: TimeZone, calendar: Calendar? = nil, twoDigitStartDate: Date = Date(timeIntervalSince1970: 0)) -> Self

    /// Creates a regex component to match a localized date and time string and capture the string as a `Date`. The date string is expected to follow the format of what `Date.FormatStyle(date:time:locale:calendar:)` produces.
    /// - Parameters:
    ///   - date: The style that describes the date part of the string. For example, `.numeric` matches "10/21/2015", and `.abbreviated` matches "Oct 21, 2015" as October 21, 2015 in the `en_US` locale.
    ///   - time: The style that describes the time part of the string.
    ///   - locale: The locale of the string to be matched.
    ///   - timeZone: The time zone to create the matched date with. Ignored if the string contains a time zone and matches the specified style.
    ///   - calendar: The calendar with which to interpret the date string. If set to nil, the default calendar of the specified `locale` is used.
    /// - Returns: A `RegexComponent` to match a localized date string.
    ///
    /// - Note:
    /// If the string contains a time zone and matches the specified style, then the `timeZone` argument is ignored. For example, "Oct 21, 2015 4:29:24 PM PDT" matches `.dateTime(date: .abbreviated, time: .complete, ...)` and is captured as `October 13, 2022, 20:29:24 PDT` regardless of the `timeZone` value.
    public static func dateTime(date: Date.FormatStyle.DateStyle, time: Date.FormatStyle.TimeStyle, locale: Locale, timeZone: TimeZone, calendar: Calendar? = nil) -> Date.ParseStrategy

    /// Creates a regex component to match a localized date string and capture the string as a `Date`. The string is expected to follow the format of what `Date.FormatStyle(date:locale:calendar:)` produces. `Date` created by this regex component would be at 00:00:00 in the specified time zone.
    /// - Parameters:
    ///   - style: The style that describes the date string. For example, `.numeric` matches "10/21/2015", and `.abbreviated` matches "Oct 21, 2015" as October 21, 2015 in the `en_US` locale. `.omitted` is invalid.
    ///   - locale: The locale of the string to be matched. Generally speaking, the language of the locale is used to parse the date parts if the string contains localized numbers or words, and the region of the locale specifies the order of the date parts. For example, "3/5/2015" represents March 5th, 2015 in `en_US`, but represents May 3rd, 2015 in `en_GB`.
    ///   - timeZone: The time zone to create the matched date with. For example, parsing "Oct 21, 2015" with the PDT time zone returns a date representing October 21, 2015 at 00:00:00 PDT.
    ///   - calendar: The calendar with which to interpret the date string. If nil, the default calendar of the specified `locale` is used.
    /// - Returns: A `RegexComponent` to match a localized date string.
    public static func date(_ style: Date.FormatStyle.DateStyle, locale: Locale, timeZone: TimeZone, calendar: Calendar? = nil) -> Date.ParseStrategy
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension BinaryFloatingPoint {

    /// Format `self` with `FloatingPointFormatStyle()`.
    public func formatted() -> String

    /// Format `self` with the given format.
    public func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : FormatStyle

    /// Format `self` with the given format. `self` is first converted to `S.FormatInput` type, then format with the given format.
    public func formatted<S>(_ format: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput : BinaryFloatingPoint
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension BinaryFloatingPoint {

    /// Initialize an instance by parsing `value` with the given `strategy`.
    public init<S>(_ value: S.ParseInput, strategy: S) throws where S : ParseStrategy, S.ParseOutput : BinaryFloatingPoint

    /// Initialize an instance by parsing `value` with the given `strategy`.
    public init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : ParseStrategy

    /// Initialize an instance by parsing `value` with a `ParseStrategy` created with the given `format` and the `lenient` argument.
    public init(_ value: String, format: FloatingPointFormatStyle<Self>, lenient: Bool = true) throws

    public init(_ value: String, format: FloatingPointFormatStyle<Self>.Percent, lenient: Bool = true) throws

    public init(_ value: String, format: FloatingPointFormatStyle<Self>.Currency, lenient: Bool = true) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension BinaryInteger {

    /// Format `self` using `IntegerFormatStyle()`
    public func formatted() -> String

    /// Format `self` with the given format.
    public func formatted<S>(_ format: S) -> S.FormatOutput where Self == S.FormatInput, S : FormatStyle

    /// Format `self` with the given format. `self` is first converted to `S.FormatInput` type, then format with the given format.
    public func formatted<S>(_ format: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput : BinaryInteger
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension BinaryInteger {

    /// Initialize an instance by parsing `value` with the given `strategy`.
    public init<S>(_ value: S.ParseInput, strategy: S) throws where S : ParseStrategy, S.ParseOutput : BinaryInteger

    /// Initialize an instance by parsing `value` with the given `strategy`.
    public init<S>(_ value: S.ParseInput, strategy: S) throws where Self == S.ParseOutput, S : ParseStrategy

    public init(_ value: String, format: IntegerFormatStyle<Self>, lenient: Bool = true) throws

    public init(_ value: String, format: IntegerFormatStyle<Self>.Percent, lenient: Bool = true) throws

    public init(_ value: String, format: IntegerFormatStyle<Self>.Currency, lenient: Bool = true) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {

    public struct FormatStyle : Sendable {

        public var locale: Locale

        public init(locale: Locale = .autoupdatingCurrent)

        public var attributed: Decimal.FormatStyle.Attributed { get }

        public typealias Configuration = NumberFormatStyleConfiguration

        public func grouping(_ group: Decimal.FormatStyle.Configuration.Grouping) -> Decimal.FormatStyle

        public func precision(_ p: Decimal.FormatStyle.Configuration.Precision) -> Decimal.FormatStyle

        public func sign(strategy: Decimal.FormatStyle.Configuration.SignDisplayStrategy) -> Decimal.FormatStyle

        public func decimalSeparator(strategy: Decimal.FormatStyle.Configuration.DecimalSeparatorDisplayStrategy) -> Decimal.FormatStyle

        public func rounded(rule: Decimal.FormatStyle.Configuration.RoundingRule = .toNearestOrEven, increment: Int? = nil) -> Decimal.FormatStyle

        public func scale(_ multiplicand: Double) -> Decimal.FormatStyle

        public func notation(_ notation: Decimal.FormatStyle.Configuration.Notation) -> Decimal.FormatStyle

        /// Creates a `FormatOutput` instance from `value`.
        public func format(_ value: Decimal) -> String

        /// If the format allows selecting a locale, returns a copy of this format with the new locale set. Default implementation returns an unmodified self.
        public func locale(_ locale: Locale) -> Decimal.FormatStyle
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {

    /// Format `self` using `Decimal.FormatStyle`
    public func formatted() -> String

    /// Format `self` with the given format.
    public func formatted<S>(_ format: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Decimal
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == Decimal.FormatStyle {

    /// Creates a regex component to match a localized number string and capture it as a `Decimal`.
    /// - Parameter locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized number string.
    public static func localizedDecimal(locale: Locale) -> Self
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == Decimal.FormatStyle.Currency {

    /// Creates a regex component to match a localized currency string and capture it as a `Decimal`. For example, `localizedIntegerCurrency(code: "USD", locale: Locale(identifier: "en_US"))` matches "$52,249.98" and captures it as 52249.98.
    /// - Parameters:
    ///   - code: The currency code of the currency symbol or name in the string.
    ///   - locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized currency number.
    public static func localizedCurrency(code: Locale.Currency, locale: Locale) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {

    public struct ParseStrategy<Format> : ParseStrategy, Codable, Hashable where Format : FormatStyle, Format.FormatInput == Decimal {

        public var formatStyle: Format

        public var lenient: Bool

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Decimal.ParseStrategy<Format>, b: Decimal.ParseStrategy<Format>) -> Bool

        /// The type of the representation describing the data.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias ParseInput = String

        /// The type of the data type.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias ParseOutput = Decimal

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Decimal {

    /// Initialize an instance by parsing `value` with the given `strategy`.
    public init<S>(_ value: S.ParseInput, strategy: S) throws where S : ParseStrategy, S.ParseOutput == Decimal

    public init(_ value: String, format: Decimal.FormatStyle, lenient: Bool = true) throws

    public init(_ value: String, format: Decimal.FormatStyle.Percent, lenient: Bool = true) throws

    public init(_ value: String, format: Decimal.FormatStyle.Currency, lenient: Bool = true) throws
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == FloatingPointFormatStyle<Double> {

    /// Creates a regex component to match a localized number string and capture it as a `Double`.
    /// - Parameter locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized double string.
    public static func localizedDouble(locale: Locale) -> Self
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == FloatingPointFormatStyle<Double>.Percent {

    /// Creates a regex component to match a localized string representing a percentage and capture it as a `Double`.
    /// - Parameter locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized percentage string.
    public static func localizedDoublePercentage(locale: Locale) -> Self
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == IntegerFormatStyle<Int> {

    /// Creates a regex component to match a localized integer string and capture it as a `Int`.
    /// - Parameter locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized integer string.
    public static func localizedInteger(locale: Locale) -> Self
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == IntegerFormatStyle<Int>.Percent {

    /// Creates a regex component to match a localized string representing a percentage and capture it as a `Int`.
    /// - Parameter locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized string representing a percentage.
    public static func localizedIntegerPercentage(locale: Locale) -> Self
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == IntegerFormatStyle<Int>.Currency {

    /// Creates a regex component to match a localized currency string and capture it as a `Int`. For example, `localizedIntegerCurrency(code: "USD", locale: Locale(identifier: "en_US"))` matches "$52,249" and captures it as 52249.
    /// - Parameters:
    ///   - code: The currency code of the currency symbol or name in the string.
    ///   - locale: The locale with which the string is formatted.
    /// - Returns: A `RegexComponent` to match a localized currency string.
    public static func localizedIntegerCurrency(code: Locale.Currency, locale: Locale) -> Self
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointRoundingRule {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension FloatingPointRoundingRule : Codable {
}

@available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
extension Duration {

    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func formatted<S>(_ v: S) -> S.FormatOutput where S : FormatStyle, S.FormatInput == Duration

    /// Formats `self` using the hour-minute-second time pattern
    /// - Returns: A formatted string to describe the duration, such as "1:30:56" for a duration of 1 hour, 30 minutes, and 56 seconds
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public func formatted() -> String
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Duration {

    /// Format style to format a `Duration` in a localized positional format.
    /// For example, one hour and ten minutes is displayed as “1:10:00” in
    /// the U.S. English locale, or “1.10.00” in the Finnish locale.
    @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
    public struct TimeFormatStyle : FormatStyle, Sendable {

        /// The units to display a Duration with and configurations for the units.
        public struct Pattern : Hashable, Codable, Sendable {

            /// Displays a duration in hours and minutes.
            public static var hourMinute: Duration.TimeFormatStyle.Pattern { get }

            /// Displays a duration in terms of hours and minutes with the specified configurations.
            /// - Parameters:
            ///   - padHourToLength: Padding for the hour field. For example, one hour is formatted as "01:00" in en_US locale when this value is set to 2.
            ///   - roundSeconds: Rounding rule for the remaining second values.
            /// - Returns: A pattern to format a duration with.
            public static func hourMinute(padHourToLength: Int, roundSeconds: FloatingPointRoundingRule = .toNearestOrEven) -> Duration.TimeFormatStyle.Pattern

            /// Displays a duration in hours, minutes, and seconds.
            public static var hourMinuteSecond: Duration.TimeFormatStyle.Pattern { get }

            /// Displays a duration in terms of hours, minutes, and seconds with the specified configurations.
            /// - Parameters:
            ///   - padHourToLength: Padding for the hour field. For example, one hour is formatted as "01:00:00" in en_US locale when this value is set to 2.
            ///   - fractionalSecondsLength: The length of the fractional seconds. For example, one hour is formatted as "1:00:00.00" in en_US locale when this value is set to 2.
            ///   - roundFractionalSeconds: Rounding rule for the fractional second values.
            /// - Returns: A pattern to format a duration with.
            public static func hourMinuteSecond(padHourToLength: Int, fractionalSecondsLength: Int = 0, roundFractionalSeconds: FloatingPointRoundingRule = .toNearestOrEven) -> Duration.TimeFormatStyle.Pattern

            /// Displays a duration in minutes and seconds. For example, one hour is formatted as "60:00" in en_US locale.
            public static var minuteSecond: Duration.TimeFormatStyle.Pattern { get }

            /// Displays a duration in minutes and seconds with the specified configurations.
            /// - Parameters:
            ///   - padMinuteToLength: Padding for the minute field. For example, five minutes is formatted as "05:00" in en_US locale when this value is set to 2.
            ///   - fractionalSecondsLength: The length of the fractional seconds. For example, one hour is formatted as "1:00:00.00" in en_US locale when this value is set to 2.
            ///   - roundFractionalSeconds: Rounding rule for the fractional second values.
            /// - Returns: A pattern to format a duration with.
            public static func minuteSecond(padMinuteToLength: Int, fractionalSecondsLength: Int = 0, roundFractionalSeconds: FloatingPointRoundingRule = .toNearestOrEven) -> Duration.TimeFormatStyle.Pattern

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Duration.TimeFormatStyle.Pattern, b: Duration.TimeFormatStyle.Pattern) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// The locale to use when formatting the duration.
        public var locale: Locale

        /// The pattern to display a Duration with.
        public var pattern: Duration.TimeFormatStyle.Pattern

        /// The attributed format style corresponding to this style.
        public var attributed: Duration.TimeFormatStyle.Attributed { get }

        /// Creates an instance using the provided pattern and locale.
        /// - Parameters:
        ///   - pattern: A `Pattern` to specify the units to include in the displayed string and the behavior of the units.
        ///   - locale: The `Locale` used to create the string representation of the duration.
        public init(pattern: Duration.TimeFormatStyle.Pattern, locale: Locale = .autoupdatingCurrent)

        /// Creates a locale-aware string representation from a duration value.
        /// - Parameter value: The value to format.
        /// - Returns: A string representation of the duration.
        public func format(_ value: Duration) -> String

        /// Modifies the format style to use the specified locale.
        /// - Parameter locale: The locale to use when formatting a duration.
        /// - Returns: A format style with the provided locale.
        public func locale(_ locale: Locale) -> Duration.TimeFormatStyle

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Duration.TimeFormatStyle, b: Duration.TimeFormatStyle) -> Bool

        /// The type of data to format.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias FormatInput = Duration

        /// The type of the formatted data.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias FormatOutput = String

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension Duration {

    /// A `FormatStyle` that displays a duration as a list of duration units, such as "2 hours, 43 minutes, 26 seconds" in English.
    @available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
    public struct UnitsFormatStyle : FormatStyle, Sendable {

        /// Specifies the width of the unit and the spacing of the value and the unit.
        public struct UnitWidth : Codable, Hashable, Sendable {

            /// Shows the full unit name, such as "3 hours" for a 3-hour duration in the en_US locale.
            public static var wide: Duration.UnitsFormatStyle.UnitWidth { get }

            /// Shows the abbreviated unit name, such as "3 hr" for a 3-hour duration in the en_US locale.
            public static var abbreviated: Duration.UnitsFormatStyle.UnitWidth { get }

            /// Shows the abbreviated unit name with a condensed space between the value and unit, such as "3hr" for a 3-hour duration in the en_US locale.
            public static var condensedAbbreviated: Duration.UnitsFormatStyle.UnitWidth { get }

            /// Shows the shortest unit name, such as "3h" for a 3-hour duration in the en_US locale.
            public static var narrow: Duration.UnitsFormatStyle.UnitWidth { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Duration.UnitsFormatStyle.UnitWidth, b: Duration.UnitsFormatStyle.UnitWidth) -> Bool

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }
        }

        /// Units that a duration can be displayed as with `UnitsFormatStyle`.
        public struct Unit : Codable, Hashable, Sendable {

            /// The unit for weeks. One week is always 604800 seconds.
            public static var weeks: Duration.UnitsFormatStyle.Unit { get }

            /// The unit for days. One day is always 86400 seconds.
            public static var days: Duration.UnitsFormatStyle.Unit { get }

            /// The unit for hours. One day is 3600 seconds.
            public static var hours: Duration.UnitsFormatStyle.Unit { get }

            /// The unit for minutes. One minute is 60 seconds.
            public static var minutes: Duration.UnitsFormatStyle.Unit { get }

            /// The unit for seconds.
            public static var seconds: Duration.UnitsFormatStyle.Unit { get }

            /// The unit for milliseconds.
            public static var milliseconds: Duration.UnitsFormatStyle.Unit { get }

            /// The unit for microseconds.
            public static var microseconds: Duration.UnitsFormatStyle.Unit { get }

            /// The unit for nanoseconds.
            public static var nanoseconds: Duration.UnitsFormatStyle.Unit { get }

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Duration.UnitsFormatStyle.Unit, b: Duration.UnitsFormatStyle.Unit) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// Specifies how zero value units are handled.
        public struct ZeroValueUnitsDisplayStrategy : Codable, Hashable, Sendable {

            /// Excludes zero-value units from the formatted string.
            public static var hide: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy { get }

            /// Displays zero-value units with zero padding to the specified length.
            public static func show(length: Int) -> Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy, b: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// Specifies how a duration is displayed if it cannot be represented exactly with the allowed units.
        ///
        /// For example, you can change this option to show a duration of 1 hour and 15 minutes as "1.25 hr", "1 hr", or "1.5 hr" with different lengths and rounding rules when hour is the only allowed unit.
        public struct FractionalPartDisplayStrategy : Codable, Hashable, Sendable {

            public var minimumLength: Int

            public var maximumLength: Int

            public var roundingRule: FloatingPointRoundingRule

            public var roundingIncrement: Double?

            /// Displays the remaining part as the fractional part of the smallest unit.
            /// - Parameters:
            ///   - lengthLimits: The range of the length of the fractional part.
            ///   - roundingRule: Rounding rule for the remaining value.
            ///   - roundingIncrement: Rounding increment for the remaining value.
            public init<Range>(lengthLimits: Range, roundingRule: FloatingPointRoundingRule = .toNearestOrEven, roundingIncrement: Double? = nil) where Range : RangeExpression, Range.Bound == Int

            /// Displays the remaining part as the fractional part of the smallest unit.
            /// - Parameters:
            ///   - length: The length of the fractional part.
            ///   - rule: Rounding rule for the remaining value.
            ///   - increment: Rounding increment for the remaining value.
            public static func show(length: Int, rounded rule: FloatingPointRoundingRule = .toNearestOrEven, increment: Double? = nil) -> Duration.UnitsFormatStyle.FractionalPartDisplayStrategy

            /// Excludes the remaining part.
            public static var hide: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy { get }

            /// Excludes the remaining part with the specified rounding rule.
            /// - Parameter rounded: Rounding rule for the remaining value.
            public static func hide(rounded: FloatingPointRoundingRule = .toNearestOrEven) -> Duration.UnitsFormatStyle.FractionalPartDisplayStrategy

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy, b: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// The locale to use when formatting the duration.
        public var locale: Locale

        /// The units that may be included in the output string.
        public var allowedUnits: Set<Duration.UnitsFormatStyle.Unit>

        /// The width of the unit and the spacing between the value and the unit.
        public var unitWidth: Duration.UnitsFormatStyle.UnitWidth

        /// The maximum number of time units to include in the output string.
        public var maximumUnitCount: Int?

        /// The strategy for how zero-value units are handled.
        public var zeroValueUnitsDisplay: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy

        /// The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
        public var fractionalPartDisplay: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy

        /// The padding or truncating behavior of the unit value.
        ///
        /// For example, set this to `2...` to force 2-digit padding on all units.
        public var valueLengthLimits: Range<Int>?

        /// Creates an instance using the provided specifications.
        /// - Parameters:
        ///   - allowedUnits: The units that may be included in the output string.
        ///   - width: The width of the unit and the spacing between the value and the unit.
        ///   - maximumUnitCount: The maximum number of time units to include in the output string.
        ///   - zeroValueUnits: The strategy for how zero-value units are handled.
        ///   - valueLength: The padding or truncating behavior of the unit value. Negative values are ignored.
        ///   - fractionalPart: The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
        public init(allowedUnits: Set<Duration.UnitsFormatStyle.Unit>, width: Duration.UnitsFormatStyle.UnitWidth, maximumUnitCount: Int? = nil, zeroValueUnits: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLength: Int? = nil, fractionalPart: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide)

        /// Creates an instance using the provided specifications.
        /// - Parameters:
        ///   - allowedUnits: The units that may be included in the output string.
        ///   - width: The width of the unit and the spacing between the value and the unit.
        ///   - maximumUnitCount: The maximum number of time units to include in the output string.
        ///   - zeroValueUnits: The strategy for how zero-value units are handled.
        ///   - valueLengthLimits: The padding or truncating behavior of the unit value. Values with negative bounds are ignored.
        ///   - fractionalPart: The strategy for displaying a duration if it cannot be represented exactly with the allowed units.
        public init<ValueRange>(allowedUnits: Set<Duration.UnitsFormatStyle.Unit>, width: Duration.UnitsFormatStyle.UnitWidth, maximumUnitCount: Int? = nil, zeroValueUnits: Duration.UnitsFormatStyle.ZeroValueUnitsDisplayStrategy = .hide, valueLengthLimits: ValueRange, fractionalPart: Duration.UnitsFormatStyle.FractionalPartDisplayStrategy = .hide) where ValueRange : RangeExpression, ValueRange.Bound == Int

        /// Creates a locale-aware string representation from a duration value.
        /// - Parameter duration: The value to format.
        /// - Returns: A string representation of the duration.
        public func format(_ duration: Duration) -> String

        /// A modifier to set the locale of the format style.
        /// - Parameter locale: The locale to apply to the format style.
        /// - Returns: A copy of this format with the new locale set.
        public func locale(_ locale: Locale) -> Duration.UnitsFormatStyle

        /// Returns a `Duration.UnitsFormatStyle.Attributed` style to format a duration as an attributed string using the configuration of this format style. Units in the string are annotated with the `durationField` and `measurement` attribute keys and the `DurationFieldAttribute` and `MeasurementAttribute` attribute values.
        ///
        /// For example, formatting a duration of 2 hours, 43 minutes, 26.25 second in `en_US` locale yeilds the following conceptually
        /// ```
        /// 2 { durationField: .hours, component: .value }
        /// hours { durationField: .hours, component: .unit }
        /// , { nil }
        /// 43 { durationField: .minutes, component: .value }
        /// minutes { durationField: .minutes, component: .unit }
        /// , { nil }
        /// 26.25 { durationField: .seconds, component: .value }
        /// seconds { durationField: .seconds, component: .unit }
        /// ```
        public var attributed: Duration.UnitsFormatStyle.Attributed { get }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Duration.UnitsFormatStyle, b: Duration.UnitsFormatStyle) -> Bool

        /// The type of data to format.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias FormatInput = Duration

        /// The type of the formatted data.
        @available(iOS 16.0, tvOS 16.0, watchOS 9.0, macOS 13.0, *)
        public typealias FormatOutput = String

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Sequence {

    public func formatted<S>(_ style: S) -> S.FormatOutput where Self == S.FormatInput, S : FormatStyle
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension Sequence where Self.Element == String {

    public func formatted() -> String
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension NSSortDescriptor {

    /// Creates an `NSSortDescriptor` representing the same sort as the given
    /// `SortDescriptor`.
    ///
    /// - Parameters:
    ///     - sortDescriptor: The `SortDescriptor` to convert.
    @backDeployed(before: iOS 17, macOS 14, tvOS 17, watchOS 10)
    public convenience init<Compared>(_ sortDescriptor: SortDescriptor<Compared>) where Compared : NSObject

    @available(macOS, deprecated: 14, message: "Use `init(_:) where Compared: NSObject` instead. Attempt to convert SortDescriptor with Compared being non-NSObject will result in a fatalError at runtime.")
    @available(iOS, deprecated: 17, message: "Use `init(_:) where Compared: NSObject` instead. Attempt to convert SortDescriptor with Compared being non-NSObject will result in a fatalError at runtime.")
    @available(tvOS, deprecated: 17, message: "Use `init(_:) where Compared: NSObject` instead. Attempt to convert SortDescriptor with Compared being non-NSObject will result in a fatalError at runtime.")
    @available(watchOS, deprecated: 10, message: "Use `init(_:) where Compared: NSObject` instead. Attempt to convert SortDescriptor with Compared being non-NSObject will result in a fatalError at runtime.")
    public convenience init<Compared>(_ sortDescriptor: SortDescriptor<Compared>)
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension String {

    /// Compares `String`s using one of a fixed set of standard comparison
    /// algorithms.
    public struct StandardComparator : SortComparator, Codable, Sendable {

        /// The type that the `SortComparator` provides a comparison for.
        public typealias Compared = String

        /// Compares `String`s as compared by the Finder.
        ///
        /// Uses a localized, numeric comparison in the current locale.
        ///
        /// The default `SortComparator` used in `String` comparisons.
        public static let localizedStandard: String.StandardComparator

        /// Compares `String`s using a localized comparison in the current
        /// locale.
        public static let localized: String.StandardComparator

        /// Compares `String`s lexically.
        public static let lexical: String.StandardComparator

        /// If the `SortComparator`s resulting order is forward or reverse.
        public var order: SortOrder

        /// Create a `StandardComparator` from the given `StandardComparator`
        /// with the given new `order`.
        ///
        /// - Parameters:
        ///     - base: The standard comparator to modify the order of.
        ///     - order: The initial order of the new `StandardComparator`.
        public init(_ base: String.StandardComparator, order: SortOrder = .forward)

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// The relative ordering of lhs, and rhs.
        ///
        /// The result of comparisons should be flipped if the current `order`
        /// is `reverse`.
        ///
        /// If `compare(lhs, rhs)` is `.orderedAscending`, then `compare(rhs, lhs)`
        /// must be `.orderedDescending`. If `compare(lhs, rhs)` is
        /// `.orderedDescending`, then `compare(rhs, lhs)` must be
        /// `.orderedAscending`.
        ///
        /// - Parameters:
        ///     - lhs: A value to compare.
        ///     - rhs: A value to compare.
        public func compare(_ lhs: String, _ rhs: String) -> ComparisonResult

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: String.StandardComparator, b: String.StandardComparator) -> Bool

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// A `String` comparison performed using the given comparison options
    /// and locale.
    public struct Comparator : SortComparator, Codable, Sendable {

        /// The options to use for comparison.
        public let options: String.CompareOptions

        /// The locale to use for comparison if the comparator is localized,
        /// otherwise nil.
        public let locale: Locale?

        /// If the `SortComparator`s resulting order is forward or reverse.
        public var order: SortOrder

        /// Creates a `String.Comparator` with the given `CompareOptions` and
        /// `Locale`.
        ///
        /// - Parameters:
        ///     - options: The options to use for comparison.
        ///     - locale: The locale to use for comparison. If `nil`, the
        ///       comparison is unlocalized.
        ///     - order: The initial order to use for ordered comparison.
        public init(options: String.CompareOptions, locale: Locale? = Locale.current, order: SortOrder = .forward)

        /// Creates a `String.Comparator` that represents the same comparison
        /// as the given `String.StandardComparator`.
        ///
        /// - Parameters:
        ///    - standardComparison: The `String.StandardComparator` to convert.
        public init(_ standardComparison: String.StandardComparator)

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws

        /// The relative ordering of lhs, and rhs.
        ///
        /// The result of comparisons should be flipped if the current `order`
        /// is `reverse`.
        ///
        /// If `compare(lhs, rhs)` is `.orderedAscending`, then `compare(rhs, lhs)`
        /// must be `.orderedDescending`. If `compare(lhs, rhs)` is
        /// `.orderedDescending`, then `compare(rhs, lhs)` must be
        /// `.orderedAscending`.
        ///
        /// - Parameters:
        ///     - lhs: A value to compare.
        ///     - rhs: A value to compare.
        public func compare(_ lhs: String, _ rhs: String) -> ComparisonResult

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: String.Comparator, b: String.Comparator) -> Bool

        /// The type that the `SortComparator` provides a comparison for.
        @available(iOS 15.0, tvOS 15.0, watchOS 8.0, macOS 12.0, *)
        public typealias Compared = String

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension StringProtocol {

    /// A capitalized representation of the string that is produced
    /// using the current locale.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var localizedCapitalized: String { get }

    /// Returns a capitalized representation of the string
    /// using the specified locale.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func capitalized(with locale: Locale?) -> String

    /// A lowercase version of the string that is produced using the current
    /// locale.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var localizedLowercase: String { get }

    /// Returns a version of the string with all letters
    /// converted to lowercase, taking into account the specified
    /// locale.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public func lowercased(with locale: Locale?) -> String

    /// An uppercase version of the string that is produced using the current
    /// locale.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public var localizedUppercase: String { get }

    /// Returns a version of the string with all letters
    /// converted to uppercase, taking into account the specified
    /// locale.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public func uppercased(with locale: Locale?) -> String
}

extension String {

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    public init(_ characters: Slice<AttributedString.CharacterView>)
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Dictionary where Key == NSAttributedString.Key, Value == Any {

    public init(_ container: AttributeContainer)

    public init<S>(_ container: AttributeContainer, including scope: KeyPath<AttributeScopes, S.Type>) throws where S : AttributeScope

    public init<S>(_ container: AttributeContainer, including scope: S.Type) throws where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension NSAttributedString {

    public convenience init(_ attrStr: AttributedString)

    public convenience init<S>(_ attrStr: AttributedString, including scope: KeyPath<AttributeScopes, S.Type>) throws where S : AttributeScope

    public convenience init<S>(_ attrStr: AttributedString, including scope: S.Type) throws where S : AttributeScope
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension String.Index {

    public init?<S>(_ sourcePosition: AttributedString.Index, within target: S) where S : StringProtocol
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension _NSRange {

    public init<R, S>(_ region: R, in target: S) where R : RangeExpression, S : AttributedStringProtocol, R.Bound == AttributedString.Index

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init?<S>(_ markdownSourcePosition: AttributedString.MarkdownSourcePosition, in target: S) where S : StringProtocol
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Range where Bound == AttributedString.Index {

    public init?<S>(_ range: NSRange, in string: S) where S : AttributedStringProtocol

    public init?<R, S>(_ region: R, in attributedString: S) where R : RangeExpression, S : AttributedStringProtocol, R.Bound == String.Index
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Range where Bound == String.Index {

    public init?<R, S>(_ region: R, in string: S) where R : RangeExpression, S : StringProtocol, R.Bound == AttributedString.Index

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init?<S>(_ markdownSourcePosition: AttributedString.MarkdownSourcePosition, in target: S) where S : StringProtocol
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Array : DataProtocol where Element == UInt8 {

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    public var regions: CollectionOfOne<[UInt8]> { get }

    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Regions = CollectionOfOne<[UInt8]>
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension ArraySlice : DataProtocol where Element == UInt8 {

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    public var regions: CollectionOfOne<ArraySlice<UInt8>> { get }

    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Regions = CollectionOfOne<ArraySlice<UInt8>>
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension ContiguousArray : DataProtocol where Element == UInt8 {

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    public var regions: CollectionOfOne<ContiguousArray<UInt8>> { get }

    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Regions = CollectionOfOne<ContiguousArray<UInt8>>
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension EmptyCollection : DataProtocol where Element == UInt8 {

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    public var regions: EmptyCollection<Data> { get }

    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Regions = EmptyCollection<Data>
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Repeated : DataProtocol where Element == UInt8 {

    public typealias Regions = Repeated<Data>

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    public var regions: Repeated<Data> { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Array : MutableDataProtocol where Element == UInt8 {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension ContiguousArray : MutableDataProtocol where Element == UInt8 {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Array : ContiguousBytes where Element == UInt8 {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension ArraySlice : ContiguousBytes where Element == UInt8 {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension ContiguousArray : ContiguousBytes where Element == UInt8 {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UnsafeRawBufferPointer : ContiguousBytes {

    /// Calls the given closure with the contents of underlying storage.
    ///
    /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
    ///         the same buffer pointer will be passed in every time.
    /// - warning: The buffer argument to the body should not be stored or used
    ///            outside of the lifetime of the call to the closure.
    @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UnsafeMutableRawBufferPointer : ContiguousBytes {

    /// Calls the given closure with the contents of underlying storage.
    ///
    /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
    ///         the same buffer pointer will be passed in every time.
    /// - warning: The buffer argument to the body should not be stored or used
    ///            outside of the lifetime of the call to the closure.
    @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UnsafeBufferPointer : ContiguousBytes where Element == UInt8 {

    /// Calls the given closure with the contents of underlying storage.
    ///
    /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
    ///         the same buffer pointer will be passed in every time.
    /// - warning: The buffer argument to the body should not be stored or used
    ///            outside of the lifetime of the call to the closure.
    @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UnsafeMutableBufferPointer : ContiguousBytes where Element == UInt8 {

    /// Calls the given closure with the contents of underlying storage.
    ///
    /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
    ///         the same buffer pointer will be passed in every time.
    /// - warning: The buffer argument to the body should not be stored or used
    ///            outside of the lifetime of the call to the closure.
    @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension EmptyCollection : ContiguousBytes where Element == UInt8 {

    /// Calls the given closure with the contents of underlying storage.
    ///
    /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
    ///         the same buffer pointer will be passed in every time.
    /// - warning: The buffer argument to the body should not be stored or used
    ///            outside of the lifetime of the call to the closure.
    @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CollectionOfOne : ContiguousBytes where Element == UInt8 {

    /// Calls the given closure with the contents of underlying storage.
    ///
    /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
    ///         the same buffer pointer will be passed in every time.
    /// - warning: The buffer argument to the body should not be stored or used
    ///            outside of the lifetime of the call to the closure.
    @inlinable public func withUnsafeBytes<R>(_ body: (UnsafeRawBufferPointer) throws -> R) rethrows -> R
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Slice : ContiguousBytes where Base : ContiguousBytes {

    /// Calls the given closure with the contents of underlying storage.
    ///
    /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
    ///         the same buffer pointer will be passed in every time.
    /// - warning: The buffer argument to the body should not be stored or used
    ///            outside of the lifetime of the call to the closure.
    public func withUnsafeBytes<ResultType>(_ body: (UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Slice : DataProtocol where Base : DataProtocol {

    public typealias Regions = [Base.Regions.Element.SubSequence]

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    public var regions: [Base.Regions.Element.SubSequence] { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UnsafeRawBufferPointer : DataProtocol {

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    public var regions: CollectionOfOne<UnsafeRawBufferPointer> { get }

    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Regions = CollectionOfOne<UnsafeRawBufferPointer>
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UnsafeBufferPointer : DataProtocol where Element == UInt8 {

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    public var regions: CollectionOfOne<UnsafeBufferPointer<UInt8>> { get }

    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Regions = CollectionOfOne<UnsafeBufferPointer<UInt8>>
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal {

    public typealias RoundingMode = NSDecimalNumber.RoundingMode

    public typealias CalculationError = NSDecimalNumber.CalculationError
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal : CustomStringConvertible {

    public init?(string: String, locale: Locale? = nil)

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal {

    public static let leastFiniteMagnitude: Decimal

    public static let greatestFiniteMagnitude: Decimal

    public static let leastNormalMagnitude: Decimal

    public static let leastNonzeroMagnitude: Decimal

    public static let pi: Decimal

    public static var quietNaN: Decimal { get }

    public static var nan: Decimal { get }

    public static var radix: Int { get }

    public init(_ value: UInt8)

    public init(_ value: Int8)

    public init(_ value: UInt16)

    public init(_ value: Int16)

    public init(_ value: UInt32)

    public init(_ value: Int32)

    public init(_ value: UInt64)

    public init(_ value: Int64)

    public init(_ value: UInt)

    public init(_ value: Int)

    public init(_ value: Double)

    public init(sign: FloatingPointSign, exponent: Int, significand: Decimal)

    public init(signOf: Decimal, magnitudeOf magnitude: Decimal)

    public var exponent: Int { get }

    public var significand: Decimal { get }

    public var sign: FloatingPointSign { get }

    public var ulp: Decimal { get }

    /// The IEEE 754 "class" of this type.
    public var floatingPointClass: FloatingPointClassification { get }

    public var isCanonical: Bool { get }

    /// `true` if `self` is negative, `false` otherwise.
    public var isSignMinus: Bool { get }

    /// `true` if `self` is +0.0 or -0.0, `false` otherwise.
    public var isZero: Bool { get }

    /// `true` if `self` is subnormal, `false` otherwise.
    public var isSubnormal: Bool { get }

    /// `true` if `self` is normal (not zero, subnormal, infinity, or NaN),
    /// `false` otherwise.
    public var isNormal: Bool { get }

    /// `true` if `self` is zero, subnormal, or normal (not infinity or NaN),
    /// `false` otherwise.
    public var isFinite: Bool { get }

    /// `true` if `self` is infinity, `false` otherwise.
    public var isInfinite: Bool { get }

    /// `true` if `self` is NaN, `false` otherwise.
    public var isNaN: Bool { get }

    /// `true` if `self` is a signaling NaN, `false` otherwise.
    public var isSignaling: Bool { get }

    /// `true` if `self` is a signaling NaN, `false` otherwise.
    public var isSignalingNaN: Bool { get }

    public var nextUp: Decimal { get }

    public var nextDown: Decimal { get }

    public func isEqual(to other: Decimal) -> Bool

    public func isLess(than other: Decimal) -> Bool

    public func isLessThanOrEqualTo(_ other: Decimal) -> Bool

    public func isTotallyOrdered(belowOrEqualTo other: Decimal) -> Bool
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal : ExpressibleByFloatLiteral {

    /// Creates an instance initialized to the specified floating-point value.
    ///
    /// Do not call this initializer directly. Instead, initialize a variable or
    /// constant using a floating-point literal. For example:
    ///
    ///     let x = 21.5
    ///
    /// In this example, the assignment to the `x` constant calls this
    /// floating-point literal initializer behind the scenes.
    ///
    /// - Parameter value: The value to create.
    public init(floatLiteral value: Double)

    /// A type that represents a floating-point literal.
    ///
    /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
    /// where available.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias FloatLiteralType = Double
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal : ExpressibleByIntegerLiteral {

    /// Creates an instance initialized to the specified integer value.
    ///
    /// Do not call this initializer directly. Instead, initialize a variable or
    /// constant using an integer literal. For example:
    ///
    ///     let x = 23
    ///
    /// In this example, the assignment to the `x` constant calls this integer
    /// literal initializer behind the scenes.
    ///
    /// - Parameter value: The value to create.
    public init(integerLiteral value: Int)

    /// A type that represents an integer literal.
    ///
    /// The standard library integer and floating-point types are all valid types
    /// for `IntegerLiteralType`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias IntegerLiteralType = Int
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    public func hash(into hasher: inout Hasher)

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal : Equatable {

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func == (lhs: Decimal, rhs: Decimal) -> Bool
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal : Comparable {

    /// Returns a Boolean value indicating whether the value of the first
    /// argument is less than that of the second argument.
    ///
    /// This function is the only requirement of the `Comparable` protocol. The
    /// remainder of the relational operator functions are implemented by the
    /// standard library for any type that conforms to `Comparable`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    public static func < (lhs: Decimal, rhs: Decimal) -> Bool
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal : SignedNumeric {

    /// The magnitude of this value.
    ///
    /// For any numeric value `x`, `x.magnitude` is the absolute value of `x`.
    /// You can use the `magnitude` property in operations that are simpler to
    /// implement in terms of unsigned values, such as printing the value of an
    /// integer, which is just printing a '-' character in front of an absolute
    /// value.
    ///
    ///     let x = -200
    ///     // x.magnitude == 200
    ///
    /// The global `abs(_:)` function provides more familiar syntax when you need
    /// to find an absolute value. In addition, because `abs(_:)` always returns
    /// a value of the same type, even in a generic context, using the function
    /// instead of the `magnitude` property is encouraged.
    public var magnitude: Decimal { get }

    /// Creates a new instance from the given integer, if it can be represented
    /// exactly.
    ///
    /// If the value passed as `source` is not representable exactly, the result
    /// is `nil`. In the following example, the constant `x` is successfully
    /// created from a value of `100`, while the attempt to initialize the
    /// constant `y` from `1_000` fails because the `Int8` type can represent
    /// `127` at maximum:
    ///
    ///     let x = Int8(exactly: 100)
    ///     // x == Optional(100)
    ///     let y = Int8(exactly: 1_000)
    ///     // y == nil
    ///
    /// - Parameter source: A value to convert to this type.
    public init?<T>(exactly source: T) where T : BinaryInteger

    /// Adds two values and stores the result in the left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func += (lhs: inout Decimal, rhs: Decimal)

    /// Subtracts the second value from the first and stores the difference in the
    /// left-hand-side variable.
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func -= (lhs: inout Decimal, rhs: Decimal)

    /// Multiplies two values and stores the result in the left-hand-side
    /// variable.
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func *= (lhs: inout Decimal, rhs: Decimal)

    public static func /= (lhs: inout Decimal, rhs: Decimal)

    /// Adds two values and produces their sum.
    ///
    /// The addition operator (`+`) calculates the sum of its two arguments. For
    /// example:
    ///
    ///     1 + 2                   // 3
    ///     -10 + 15                // 5
    ///     -15 + -5                // -20
    ///     21.5 + 3.25             // 24.75
    ///
    /// You cannot use `+` with arguments of different types. To add values of
    /// different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) + y              // 1000021
    ///
    /// - Parameters:
    ///   - lhs: The first value to add.
    ///   - rhs: The second value to add.
    public static func + (lhs: Decimal, rhs: Decimal) -> Decimal

    /// Subtracts one value from another and produces their difference.
    ///
    /// The subtraction operator (`-`) calculates the difference of its two
    /// arguments. For example:
    ///
    ///     8 - 3                   // 5
    ///     -10 - 5                 // -15
    ///     100 - -5                // 105
    ///     10.5 - 100.0            // -89.5
    ///
    /// You cannot use `-` with arguments of different types. To subtract values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: UInt8 = 21
    ///     let y: UInt = 1000000
    ///     y - UInt(x)             // 999979
    ///
    /// - Parameters:
    ///   - lhs: A numeric value.
    ///   - rhs: The value to subtract from `lhs`.
    public static func - (lhs: Decimal, rhs: Decimal) -> Decimal

    /// Multiplies two values and produces their product.
    ///
    /// The multiplication operator (`*`) calculates the product of its two
    /// arguments. For example:
    ///
    ///     2 * 3                   // 6
    ///     100 * 21                // 2100
    ///     -10 * 15                // -150
    ///     3.5 * 2.25              // 7.875
    ///
    /// You cannot use `*` with arguments of different types. To multiply values
    /// of different types, convert one of the values to the other value's type.
    ///
    ///     let x: Int8 = 21
    ///     let y: Int = 1000000
    ///     Int(x) * y              // 21000000
    ///
    /// - Parameters:
    ///   - lhs: The first value to multiply.
    ///   - rhs: The second value to multiply.
    public static func * (lhs: Decimal, rhs: Decimal) -> Decimal

    public static func / (lhs: Decimal, rhs: Decimal) -> Decimal

    /// Replaces this value with its additive inverse.
    ///
    /// The following example uses the `negate()` method to negate the value of
    /// an integer `x`:
    ///
    ///     var x = 21
    ///     x.negate()
    ///     // x == -21
    ///
    /// The resulting value must be representable within the value's type. In
    /// particular, negating a signed, fixed-width integer type's minimum
    /// results in a value that cannot be represented.
    ///
    ///     var y = Int8.min
    ///     y.negate()
    ///     // Overflow error
    public mutating func negate()

    /// A type that can represent the absolute value of any possible value of the
    /// conforming type.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Magnitude = Decimal
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Decimal : Strideable {

    /// Returns the distance from this value to the given value, expressed as a 
    /// stride.
    ///
    /// If this type's `Stride` type conforms to `BinaryInteger`, then for two
    /// values `x` and `y`, and a distance `n = x.distance(to: y)`,
    /// `x.advanced(by: n) == y`. Using this method with types that have a
    /// noninteger `Stride` may result in an approximation.
    ///
    /// - Parameter other: The value to calculate the distance to.
    /// - Returns: The distance from this value to `other`.
    ///
    /// - Complexity: O(1)
    public func distance(to other: Decimal) -> Decimal

    /// Returns a value that is offset the specified distance from this value.
    ///
    /// Use the `advanced(by:)` method in generic code to offset a value by a
    /// specified distance. If you're working directly with numeric values, use
    /// the addition operator (`+`) instead of this method.
    ///
    ///     func addOne<T: Strideable>(to x: T) -> T
    ///         where T.Stride: ExpressibleByIntegerLiteral
    ///     {
    ///         return x.advanced(by: 1)
    ///     }
    ///
    ///     let x = addOne(to: 5)
    ///     // x == 6
    ///     let y = addOne(to: 3.5)
    ///     // y = 4.5
    ///
    /// If this type's `Stride` type conforms to `BinaryInteger`, then for a
    /// value `x`, a distance `n`, and a value `y = x.advanced(by: n)`,
    /// `x.distance(to: y) == n`. Using this method with types that have a
    /// noninteger `Stride` may result in an approximation. If the result of
    /// advancing by `n` is not representable as a value of this type, then a
    /// runtime error may occur.
    ///
    /// - Parameter n: The distance to advance this value.
    /// - Returns: A value that is offset from this value by `n`.
    ///
    /// - Complexity: O(1)
    public func advanced(by n: Decimal) -> Decimal

    /// A type that represents the distance between two values.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Stride = Decimal
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Error {

    /// Retrieve the localized description for this error.
    public var localizedDescription: String { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension RegexComponent where Self == Date.HTTPFormatStyle {

    /// Creates a regex component to match an HTTP date and time, such as "2015-11-14'T'15:05:03'Z'", and capture the string as a `Date` using the time zone as specified in the string.
    public static var http: Date.HTTPFormatStyle { get }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension RegexComponent where Self == DateComponents.HTTPFormatStyle {

    /// Creates a regex component to match an HTTP date and time, such as "2015-11-14'T'15:05:03'Z'", and capture the string as a `DateComponents` using the time zone as specified in the string.
    public static var httpComponents: DateComponents.HTTPFormatStyle { get }
}

@available(macOS 13.0, iOS 16.0, tvOS 16.0, watchOS 9.0, *)
extension RegexComponent where Self == Date.ISO8601FormatStyle {

    /// Creates a regex component to match an ISO 8601 date and time, such as "2015-11-14'T'15:05:03'Z'", and capture the string as a `Date` using the time zone as specified in the string.
    public static var iso8601: Date.ISO8601FormatStyle { get }

    /// Creates a regex component to match an ISO 8601 date and time string, including time zone, and capture the string as a `Date` using the time zone as specified in the string.
    /// - Parameters:
    ///   - includingFractionalSeconds: Specifies if the string contains fractional seconds.
    ///   - dateSeparator: The separator between date components.
    ///   - dateTimeSeparator: The separator between date and time parts.
    ///   - timeSeparator: The separator between time components.
    ///   - timeZoneSeparator: The separator between time parts in the time zone.
    /// - Returns: A `RegexComponent` to match an ISO 8601 string, including time zone.
    public static func iso8601WithTimeZone(includingFractionalSeconds: Bool = false, dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted) -> Self

    /// Creates a regex component to match an ISO 8601 date and time string without time zone, and capture the string as a `Date` using the specified `timeZone`. If the string contains time zone designators, matches up until the start of time zone designators.
    /// - Parameters:
    ///   - timeZone: The time zone to create the captured `Date` with.
    ///   - includingFractionalSeconds: Specifies if the string contains fractional seconds.
    ///   - dateSeparator: The separator between date components.
    ///   - dateTimeSeparator: The separator between date and time parts.
    ///   - timeSeparator: The separator between time components.
    /// - Returns: A `RegexComponent` to match an ISO 8601 string.
    public static func iso8601(timeZone: TimeZone, includingFractionalSeconds: Bool = false, dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Date.ISO8601FormatStyle.TimeSeparator = .colon) -> Self

    /// Creates a regex component to match an ISO 8601 date string, such as "2015-11-14", and capture the string as a `Date`. The captured `Date` would be at midnight in the specified `timeZone`.
    /// - Parameters:
    ///   - timeZone: The time zone to create the captured `Date` with.
    ///   - dateSeparator: The separator between date components.
    /// - Returns:  A `RegexComponent` to match an ISO 8601 date string, not any time zone that may be in the string.
    public static func iso8601Date(timeZone: TimeZone, dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash) -> Self
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension RegexComponent where Self == DateComponents.ISO8601FormatStyle {

    /// Creates a regex component to match an ISO 8601 date and time, such as "2015-11-14'T'15:05:03'Z'", and capture the string as a `DateComponents` using the time zone as specified in the string.
    public static var iso8601Components: DateComponents.ISO8601FormatStyle { get }

    /// Creates a regex component to match an ISO 8601 date and time string, including time zone, and capture the string as a `DateComponents` using the time zone as specified in the string.
    /// - Parameters:
    ///   - includingFractionalSeconds: Specifies if the string contains fractional seconds.
    ///   - dateSeparator: The separator between date components.
    ///   - dateTimeSeparator: The separator between date and time parts.
    ///   - timeSeparator: The separator between time components.
    ///   - timeZoneSeparator: The separator between time parts in the time zone.
    /// - Returns: A `RegexComponent` to match an ISO 8601 string, including time zone.
    public static func iso8601ComponentsWithTimeZone(includingFractionalSeconds: Bool = false, dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Date.ISO8601FormatStyle.TimeSeparator = .colon, timeZoneSeparator: Date.ISO8601FormatStyle.TimeZoneSeparator = .omitted) -> Self

    /// Creates a regex component to match an ISO 8601 date and time string without time zone, and capture the string as a `DateComponents` using the specified `timeZone`. If the string contains time zone designators, matches up until the start of time zone designators.
    /// - Parameters:
    ///   - timeZone: The time zone to create the captured `DateComponents` with.
    ///   - includingFractionalSeconds: Specifies if the string contains fractional seconds.
    ///   - dateSeparator: The separator between date components.
    ///   - dateTimeSeparator: The separator between date and time parts.
    ///   - timeSeparator: The separator between time components.
    /// - Returns: A `RegexComponent` to match an ISO 8601 string.
    public static func iso8601Components(timeZone: TimeZone, includingFractionalSeconds: Bool = false, dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash, dateTimeSeparator: Date.ISO8601FormatStyle.DateTimeSeparator = .standard, timeSeparator: Date.ISO8601FormatStyle.TimeSeparator = .colon) -> Self

    /// Creates a regex component to match an ISO 8601 date string, such as "2015-11-14", and capture the string as a `DateComponents`. The captured `DateComponents` would be at midnight in the specified `timeZone`.
    /// - Parameters:
    ///   - timeZone: The time zone to create the captured `Date` with.
    ///   - dateSeparator: The separator between date components.
    /// - Returns:  A `RegexComponent` to match an ISO 8601 date string, not any time zone that may be in the string.
    public static func iso8601DateComponents(timeZone: TimeZone, dateSeparator: Date.ISO8601FormatStyle.DateSeparator = .dash) -> Self
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension KeyedEncodingContainer {

    public mutating func encodePredicateExpression<T, each Input>(_ expression: T, forKey key: KeyedEncodingContainer<K>.Key, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T : PredicateExpression, T : Encodable, T.Output == Bool

    public mutating func encodePredicateExpressionIfPresent<T, each Input>(_ expression: T?, forKey key: KeyedEncodingContainer<K>.Key, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T : PredicateExpression, T : Encodable, T.Output == Bool
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension KeyedDecodingContainer {

    public mutating func decodePredicateExpression<each Input>(forKey key: KeyedDecodingContainer<K>.Key, input: repeat (each Input).Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Bool>, variable: (repeat PredicateExpressions.Variable<each Input>))

    public mutating func decodePredicateExpressionIfPresent<each Input>(forKey key: KeyedDecodingContainer<K>.Key, input: repeat (each Input).Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Bool>, variable: (repeat PredicateExpressions.Variable<each Input>))?
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension UnkeyedEncodingContainer {

    public mutating func encodePredicateExpression<T, each Input>(_ expression: T, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T : PredicateExpression, T : Encodable, T.Output == Bool

    public mutating func encodePredicateExpressionIfPresent<T, each Input>(_ expression: T?, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T : PredicateExpression, T : Encodable, T.Output == Bool
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension UnkeyedDecodingContainer {

    public mutating func decodePredicateExpression<each Input>(input: repeat (each Input).Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Bool>, variable: (repeat PredicateExpressions.Variable<each Input>))

    public mutating func decodePredicateExpressionIfPresent<each Input>(input: repeat (each Input).Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Bool>, variable: (repeat PredicateExpressions.Variable<each Input>))?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension KeyedEncodingContainer {

    public mutating func encodePredicateExpression<T, each Input>(_ expression: T, forKey key: KeyedEncodingContainer<K>.Key, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T : PredicateExpression, T : Encodable

    public mutating func encodePredicateExpressionIfPresent<T, each Input>(_ expression: T?, forKey key: KeyedEncodingContainer<K>.Key, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T : PredicateExpression, T : Encodable
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension KeyedDecodingContainer {

    public mutating func decodePredicateExpression<each Input, Output>(forKey key: KeyedDecodingContainer<K>.Key, input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Output>, variable: (repeat PredicateExpressions.Variable<each Input>))

    public mutating func decodePredicateExpressionIfPresent<each Input, Output>(forKey key: KeyedDecodingContainer<K>.Key, input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Output>, variable: (repeat PredicateExpressions.Variable<each Input>))?
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension UnkeyedEncodingContainer {

    public mutating func encodePredicateExpression<T, each Input>(_ expression: T, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T : PredicateExpression, T : Encodable

    public mutating func encodePredicateExpressionIfPresent<T, each Input>(_ expression: T?, variable: repeat PredicateExpressions.Variable<each Input>, predicateConfiguration: PredicateCodableConfiguration) throws where T : PredicateExpression, T : Encodable
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension UnkeyedDecodingContainer {

    public mutating func decodePredicateExpression<each Input, Output>(input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Output>, variable: (repeat PredicateExpressions.Variable<each Input>))

    public mutating func decodePredicateExpressionIfPresent<each Input, Output>(input: repeat (each Input).Type, output: Output.Type, predicateConfiguration: PredicateCodableConfiguration) throws -> (expression: any PredicateExpression<Output>, variable: (repeat PredicateExpressions.Variable<each Input>))?
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension NSPredicate {

    public convenience init?<Input>(_ predicate: Predicate<Input>) where Input : NSObject
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension NSExpression {

    public convenience init?<Input, Output>(_ expression: Expression<Input, Output>) where Input : NSObject
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension Sequence {

    public func filter(_ predicate: Predicate<Self.Element>) throws -> [Self.Element]
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String {

    public init(_ cocoaString: NSString)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String : CVarArg {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String {

    public struct Encoding : RawRepresentable, Sendable, Equatable {

        /// The corresponding value of the raw type.
        ///
        /// A new instance initialized with `rawValue` will be equivalent to this
        /// instance. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     let selectedSize = PaperSize.Letter
        ///     print(selectedSize.rawValue)
        ///     // Prints "Letter"
        ///
        ///     print(selectedSize == PaperSize(rawValue: selectedSize.rawValue)!)
        ///     // Prints "true"
        public var rawValue: UInt

        /// Creates a new instance with the specified raw value.
        ///
        /// If there is no value of the type that corresponds with the specified raw
        /// value, this initializer returns `nil`. For example:
        ///
        ///     enum PaperSize: String {
        ///         case A4, A5, Letter, Legal
        ///     }
        ///
        ///     print(PaperSize(rawValue: "Legal"))
        ///     // Prints "Optional(PaperSize.Legal)"
        ///
        ///     print(PaperSize(rawValue: "Tabloid"))
        ///     // Prints "nil"
        ///
        /// - Parameter rawValue: The raw value to use for the new instance.
        public init(rawValue: UInt)

        public static let ascii: String.Encoding

        public static let nextstep: String.Encoding

        public static let japaneseEUC: String.Encoding

        public static let utf8: String.Encoding

        public static let isoLatin1: String.Encoding

        public static let symbol: String.Encoding

        public static let nonLossyASCII: String.Encoding

        public static let shiftJIS: String.Encoding

        public static let isoLatin2: String.Encoding

        public static let unicode: String.Encoding

        public static let windowsCP1251: String.Encoding

        public static let windowsCP1252: String.Encoding

        public static let windowsCP1253: String.Encoding

        public static let windowsCP1254: String.Encoding

        public static let windowsCP1250: String.Encoding

        public static let iso2022JP: String.Encoding

        public static let macOSRoman: String.Encoding

        public static let utf16: String.Encoding

        public static let utf16BigEndian: String.Encoding

        public static let utf16LittleEndian: String.Encoding

        public static let utf32: String.Encoding

        public static let utf32BigEndian: String.Encoding

        public static let utf32LittleEndian: String.Encoding

        /// The raw type that can be used to represent all values of the conforming
        /// type.
        ///
        /// Every distinct value of the conforming type has a corresponding unique
        /// value of the `RawValue` type, but there may be values of the `RawValue`
        /// type that don't have a corresponding value of the conforming type.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias RawValue = UInt
    }

    public typealias EncodingConversionOptions = NSString.EncodingConversionOptions

    public typealias EnumerationOptions = NSString.EnumerationOptions
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String {

    public typealias CompareOptions = NSString.CompareOptions
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String {

    /// Returns a `String` initialized by converting given `data` into
    /// Unicode characters using a given `encoding`.
    public init?(data: Data, encoding: String.Encoding)

    /// Creates a new string equivalent to the given bytes interpreted in the specified encoding.
    /// Note: This API does not interpret embedded nulls as termination of the string. Use `String?(validatingCString:)` instead for null-terminated C strings.
    /// - Parameters:
    ///   - bytes: A sequence of bytes to interpret using `encoding`.
    ///   - encoding: The encoding to use to interpret `bytes`.
    public init?<S>(bytes: S, encoding: String.Encoding) where S : Sequence, S.Element == UInt8

    /// Produces a string created by reading data from the file at a given path interpreted using a given encoding.
    public init(contentsOfFile path: String, encoding enc: String.Encoding) throws

    /// Produces a string created by reading data from a given URL interpreted using a given encoding.
    public init(contentsOf url: URL, encoding enc: String.Encoding) throws

    /// Produces a string created by reading data from the file at a given path and returns by reference the encoding used to interpret the file.
    public init(contentsOfFile path: String, usedEncoding: inout String.Encoding) throws

    /// Produces a string created by reading data from a given URL and returns by reference the encoding used to interpret the data.
    public init(contentsOf url: URL, usedEncoding: inout String.Encoding) throws
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension StringProtocol {

    /// Writes the contents of the `String` to a file at a given path using a given encoding.
    public func write<T>(toFile path: T, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws where T : StringProtocol

    /// Writes the contents of the `String` to the URL specified by url using the specified encoding.
    public func write(to url: URL, atomically useAuxiliaryFile: Bool, encoding enc: String.Encoding) throws
}

@available(macOS 15, iOS 18, tvOS 18, watchOS 11, *)
extension String {

    public func data(using encoding: String.Encoding, allowLossyConversion: Bool = false) -> Data?
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension StringProtocol {

    /// A copy of the string with each word changed to its corresponding
    /// capitalized spelling.
    ///
    /// This property performs the canonical (non-localized) mapping. It is
    /// suitable for programming operations that require stable results not
    /// depending on the current locale.
    ///
    /// A capitalized string is a string with the first character in each word
    /// changed to its corresponding uppercase value, and all remaining
    /// characters set to their corresponding lowercase values. A "word" is any
    /// sequence of characters delimited by spaces, tabs, or line terminators.
    /// Some common word delimiting punctuation isn't considered, so this
    /// property may not generally produce the desired results for multiword
    /// strings. See the `getLineStart(_:end:contentsEnd:for:)` method for
    /// additional information.
    ///
    /// Case transformations aren’t guaranteed to be symmetrical or to produce
    /// strings of the same lengths as the originals.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public var capitalized: String { get }

    /// Finds and returns the range in the `String` of the first
    /// character from a given character set found in a given range with
    /// given options.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func rangeOfCharacter(from aSet: CharacterSet, options mask: String.CompareOptions = [], range aRange: Range<Self.Index>? = nil) -> Range<Self.Index>?

    /// Returns a `Data` containing a representation of
    /// the `String` encoded using a given encoding.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func data(using encoding: String.Encoding, allowLossyConversion: Bool = false) -> Data?

    /// Returns an array containing substrings from the string that have been
    /// divided by the given separator.
    ///
    /// The substrings in the resulting array appear in the same order as the
    /// original string. Adjacent occurrences of the separator string produce
    /// empty strings in the result. Similarly, if the string begins or ends
    /// with the separator, the first or last substring, respectively, is empty.
    /// The following example shows this behavior:
    ///
    ///     let list1 = "Karin, Carrie, David"
    ///     let items1 = list1.components(separatedBy: ", ")
    ///     // ["Karin", "Carrie", "David"]
    ///
    ///     // Beginning with the separator:
    ///     let list2 = ", Norman, Stanley, Fletcher"
    ///     let items2 = list2.components(separatedBy: ", ")
    ///     // ["", "Norman", "Stanley", "Fletcher"
    ///
    /// If the list has no separators, the array contains only the original
    /// string itself.
    ///
    ///     let name = "Karin"
    ///     let list = name.components(separatedBy: ", ")
    ///     // ["Karin"]
    ///
    /// - Parameter separator: The separator string.
    /// - Returns: An array containing substrings that have been divided from the
    ///   string using `separator`.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func components<T>(separatedBy separator: T) -> [String] where T : StringProtocol

    /// Returns the range of characters representing the line or lines
    /// containing a given range.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func lineRange(for range: some RangeExpression<String.Index>) -> Range<Self.Index>

    /// Returns the range of characters representing the
    /// paragraph or paragraphs containing a given range.
    @available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
    public func paragraphRange(for range: some RangeExpression<String.Index>) -> Range<Self.Index>
}

extension String {

    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public init(_ key: URL.Template.VariableName)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension EncodingError : LocalizedError {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension DecodingError : LocalizedError {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension KeyedEncodingContainer {

    public mutating func encode<T, C>(_ wrapper: CodableConfiguration<T?, C>, forKey key: KeyedEncodingContainer<K>.Key) throws where T : DecodableWithConfiguration, T : EncodableWithConfiguration, C : DecodingConfigurationProviding, C : EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension KeyedDecodingContainer {

    public func decode<T, C>(_: CodableConfiguration<T?, C>.Type, forKey key: KeyedDecodingContainer<K>.Key) throws -> CodableConfiguration<T?, C> where T : DecodableWithConfiguration, T : EncodableWithConfiguration, C : DecodingConfigurationProviding, C : EncodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration, T.EncodingConfiguration == C.EncodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension KeyedEncodingContainer {

    public mutating func encode<T, C>(_ t: T, forKey key: KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : EncodableWithConfiguration, C : EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration

    public mutating func encodeIfPresent<T, C>(_ t: T?, forKey key: KeyedEncodingContainer<K>.Key, configuration: C.Type) throws where T : EncodableWithConfiguration, C : EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration

    public mutating func encode<T>(_ t: T, forKey key: KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : EncodableWithConfiguration

    public mutating func encodeIfPresent<T>(_ t: T?, forKey key: KeyedEncodingContainer<K>.Key, configuration: T.EncodingConfiguration) throws where T : EncodableWithConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension KeyedDecodingContainer {

    public func decode<T, C>(_: T.Type, forKey key: KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration

    public func decodeIfPresent<T, C>(_: T.Type, forKey key: KeyedDecodingContainer<K>.Key, configuration: C.Type) throws -> T? where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration

    public func decode<T>(_: T.Type, forKey key: KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T where T : DecodableWithConfiguration

    public func decodeIfPresent<T>(_: T.Type, forKey key: KeyedDecodingContainer<K>.Key, configuration: T.DecodingConfiguration) throws -> T? where T : DecodableWithConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension UnkeyedEncodingContainer {

    public mutating func encode<T, C>(_ t: T, configuration: C.Type) throws where T : EncodableWithConfiguration, C : EncodingConfigurationProviding, T.EncodingConfiguration == C.EncodingConfiguration

    public mutating func encode<T>(_ t: T, configuration: T.EncodingConfiguration) throws where T : EncodableWithConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension UnkeyedDecodingContainer {

    public mutating func decode<T, C>(_: T.Type, configuration: C.Type) throws -> T where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration

    public mutating func decodeIfPresent<T, C>(_: T.Type, configuration: C.Type) throws -> T? where T : DecodableWithConfiguration, C : DecodingConfigurationProviding, T.DecodingConfiguration == C.DecodingConfiguration

    public mutating func decode<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T where T : DecodableWithConfiguration

    public mutating func decodeIfPresent<T>(_: T.Type, configuration: T.DecodingConfiguration) throws -> T? where T : DecodableWithConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Optional : EncodableWithConfiguration where Wrapped : EncodableWithConfiguration {

    public func encode(to encoder: any Encoder, configuration: Wrapped.EncodingConfiguration) throws

    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias EncodingConfiguration = Wrapped.EncodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Optional : DecodableWithConfiguration where Wrapped : DecodableWithConfiguration {

    public init(from decoder: any Decoder, configuration: Wrapped.DecodingConfiguration) throws

    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias DecodingConfiguration = Wrapped.DecodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Array : EncodableWithConfiguration where Element : EncodableWithConfiguration {

    public func encode(to encoder: any Encoder, configuration: Element.EncodingConfiguration) throws

    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias EncodingConfiguration = Element.EncodingConfiguration
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension Array : DecodableWithConfiguration where Element : DecodableWithConfiguration {

    public init(from decoder: any Decoder, configuration: Element.DecodingConfiguration) throws

    @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
    public typealias DecodingConfiguration = Element.DecodingConfiguration
}

@available(macOS 14, iOS 17, tvOS 17, watchOS 10, *)
extension ComparisonResult : Codable {

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Never : SortComparator {

    /// The type that the `SortComparator` provides a comparison for.
    public typealias Compared = Never

    /// The relative ordering of lhs, and rhs.
    ///
    /// The result of comparisons should be flipped if the current `order`
    /// is `reverse`.
    ///
    /// If `compare(lhs, rhs)` is `.orderedAscending`, then `compare(rhs, lhs)`
    /// must be `.orderedDescending`. If `compare(lhs, rhs)` is
    /// `.orderedDescending`, then `compare(rhs, lhs)` must be
    /// `.orderedAscending`.
    ///
    /// - Parameters:
    ///     - lhs: A value to compare.
    ///     - rhs: A value to compare.
    public func compare(_ lhs: Never, _ rhs: Never) -> ComparisonResult

    /// If the `SortComparator`s resulting order is forward or reverse.
    public var order: SortOrder
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Sequence {

    /// Returns the elements of the sequence, sorted using the given comparator
    /// to compare elements.
    ///
    /// - Parameters:
    ///   - comparator: the comparator to use in ordering elements
    /// - Returns: an array of the elements sorted using `comparator`.
    public func sorted<Comparator>(using comparator: Comparator) -> [Self.Element] where Comparator : SortComparator, Self.Element == Comparator.Compared

    /// Returns the elements of the sequence, sorted using the given array of
    /// `SortComparator`s to compare elements.
    ///
    /// - Parameters:
    ///   - comparators: an array of comparators used to compare elements. The
    ///   first comparator specifies the primary comparator to be used in
    ///   sorting the sequence's elements. Any subsequent comparators are used
    ///   to further refine the order of elements with equal values.
    /// - Returns: an array of the elements sorted using `comparators`.
    public func sorted<S, Comparator>(using comparators: S) -> [Self.Element] where S : Sequence, Comparator : SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension Sequence {

    /// If `lhs` is ordered before `rhs` in the ordering described by the given
    /// sequence of `SortComparator`s
    ///
    /// The first element of the sequence of comparators specifies the primary
    /// comparator to be used in sorting the sequence's elements. Any subsequent
    /// comparators are used to further refine the order of elements with equal
    /// values.
    public func compare<Comparator>(_ lhs: Comparator.Compared, _ rhs: Comparator.Compared) -> ComparisonResult where Comparator : SortComparator, Comparator == Self.Element
}

@available(iOS 15.0, macOS 12.0, tvOS 15.0, watchOS 8.0, *)
extension MutableCollection where Self : RandomAccessCollection {

    /// Sorts the collection using the given comparator to compare elements.
    /// - Parameters:
    ///     - comparator: the sort comparator used to compare elements.
    public mutating func sort<Comparator>(using comparator: Comparator) where Comparator : SortComparator, Self.Element == Comparator.Compared

    /// Sorts the collection using the given array of `SortComparator`s to
    /// compare elements.
    ///
    /// - Parameters:
    ///   - comparators: an array of comparators used to compare elements. The
    ///   first comparator specifies the primary comparator to be used in
    ///   sorting the sequence's elements. Any subsequent comparators are used
    ///   to further refine the order of elements with equal values.
    public mutating func sort<S, Comparator>(using comparators: S) where S : Sequence, Comparator : SortComparator, Comparator == S.Element, Self.Element == Comparator.Compared
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSSortDescriptor {

    public convenience init<Root, Value>(keyPath: KeyPath<Root, Value>, ascending: Bool)

    public convenience init<Root, Value>(keyPath: KeyPath<Root, Value>, ascending: Bool, comparator cmptr: @escaping Comparator)

    public var keyPath: AnyKeyPath? { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncSequence where Self.Element == UInt8 {

    /**
     A non-blocking sequence of newline-separated `Strings` created by decoding the elements of `self` as UTF8.
     */
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public var lines: AsyncLineSequence<Self> { get }
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension URLSession {

    /// Returns a publisher that wraps a URL session data task for a given URL.
    ///
    /// The publisher publishes data when the task completes, or terminates if the task fails with an error.
    /// - Parameter url: The URL for which to create a data task.
    /// - Returns: A publisher that wraps a data task for the URL.
    public func dataTaskPublisher(for url: URL) -> URLSession.DataTaskPublisher

    /// Returns a publisher that wraps a URL session data task for a given URL request.
    ///
    /// The publisher publishes data when the task completes, or terminates if the task fails with an error.
    /// - Parameter request: The URL request for which to create a data task.
    /// - Returns: A publisher that wraps a data task for the URL request.
    public func dataTaskPublisher(for request: URLRequest) -> URLSession.DataTaskPublisher

    public struct DataTaskPublisher : Publisher, Sendable {

        /// The kind of values published by this publisher.
        public typealias Output = (data: Data, response: URLResponse)

        /// The kind of errors this publisher might publish.
        ///
        /// Use `Never` if this `Publisher` does not publish errors.
        public typealias Failure = URLError

        public let request: URLRequest

        public let session: URLSession

        public init(request: URLRequest, session: URLSession)

        /// Attaches the specified subscriber to this publisher.
        ///
        /// Implementations of ``Publisher`` must implement this method.
        ///
        /// The provided implementation of ``Publisher/subscribe(_:)-4u8kn``calls this method.
        ///
        /// - Parameter subscriber: The subscriber to attach to this ``Publisher``, after which it can receive values.
        public func receive<S>(subscriber: S) where S : Subscriber, S.Failure == URLError, S.Input == (data: Data, response: URLResponse)
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSArray : ExpressibleByArrayLiteral {

    /// Create an instance initialized with `elements`.
    required public convenience init(arrayLiteral elements: Any...)

    /// The type of the elements of an array literal.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias ArrayLiteralElement = Any
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSArray : Sequence {

    /// Return an *iterator* over the elements of this *sequence*.
    ///
    /// - Complexity: O(1).
    final public func makeIterator() -> NSFastEnumerationIterator

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1).
    @nonobjc public var underestimatedCount: Int { get }

    /// A type representing the sequence's elements.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = Any

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Iterator = NSFastEnumerationIterator
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSArray {

    public convenience init(objects elements: Any...)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSArray {

    /// Initializes a newly allocated array by placing in it the objects
    /// contained in a given array.
    ///
    /// - Returns: An array initialized to contain the objects in
    ///    `anArray``. The returned object might be different than the
    ///    original receiver.
    ///
    /// Discussion: After an immutable array has been initialized in
    /// this way, it cannot be modified.
    @nonobjc public convenience init(array anArray: NSArray)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSArray : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Array : CVarArg {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSSet : Sequence {

    /// Return an *iterator* over the elements of this *sequence*.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> NSFastEnumerationIterator

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1).
    @nonobjc public var underestimatedCount: Int { get }

    /// A type representing the sequence's elements.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = Any

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Iterator = NSFastEnumerationIterator
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSOrderedSet : Sequence {

    /// Return an *iterator* over the elements of this *sequence*.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> NSFastEnumerationIterator

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1).
    @nonobjc public var underestimatedCount: Int { get }

    /// A type representing the sequence's elements.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = Any

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Iterator = NSFastEnumerationIterator
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSOrderedSet {

    public convenience init(objects elements: Any...)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSSet {

    public convenience init(objects elements: Any...)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSSet : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    required public convenience init(arrayLiteral elements: Any...)

    /// The type of the elements of an array literal.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias ArrayLiteralElement = Any
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSOrderedSet : ExpressibleByArrayLiteral {

    /// Creates an instance initialized with the given elements.
    required public convenience init(arrayLiteral elements: Any...)

    /// The type of the elements of an array literal.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias ArrayLiteralElement = Any
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSSet {

    /// Initializes a newly allocated set and adds to it objects from
    /// another given set.
    ///
    /// - Returns: An initialized objects set containing the objects from
    ///   `set`. The returned set might be different than the original
    ///   receiver.
    @nonobjc public convenience init(set anSet: NSSet)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSSet : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Set : CVarArg {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSData : DataProtocol {

    /// The position of the first element in a nonempty collection.
    ///
    /// If the collection is empty, `startIndex` is equal to `endIndex`.
    @nonobjc public var startIndex: Int { get }

    /// The collection's "past the end" position---that is, the position one
    /// greater than the last valid subscript argument.
    ///
    /// When you need a range that includes the last element of a collection, use
    /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
    /// creates a range that doesn't include the upper bound, so it's always
    /// safe to use with `endIndex`. For example:
    ///
    ///     let numbers = [10, 20, 30, 40, 50]
    ///     if let index = numbers.firstIndex(of: 30) {
    ///         print(numbers[index ..< numbers.endIndex])
    ///     }
    ///     // Prints "[30, 40, 50]"
    ///
    /// If the collection is empty, `endIndex` is equal to `startIndex`.
    @nonobjc public var endIndex: Int { get }

    /// Returns the last found range of the given data buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    @nonobjc public func lastRange<D, R>(of data: D, in r: R) -> Range<Int>? where D : DataProtocol, R : RangeExpression, R.Bound == Int

    /// Returns the first found range of the given data buffer.
    ///
    /// A default implementation is given in terms of `self.regions`.
    @nonobjc public func firstRange<D, R>(of data: D, in r: R) -> Range<Int>? where D : DataProtocol, R : RangeExpression, R.Bound == Int

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    @nonobjc public var regions: [Data] { get }

    /// Accesses the element at the specified position.
    ///
    /// The following example accesses an element of an array through its
    /// subscript to print its value:
    ///
    ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
    ///     print(streets[1])
    ///     // Prints "Bryant"
    ///
    /// You can subscript a collection with any valid index other than the
    /// collection's end index. The end index refers to the position one past
    /// the last element of a collection, so it doesn't correspond with an
    /// element.
    ///
    /// - Parameter position: The position of the element to access. `position`
    ///   must be a valid index of the collection that is not equal to the
    ///   `endIndex` property.
    ///
    /// - Complexity: O(1)
    @nonobjc public subscript(position: Int) -> UInt8 { get }

    /// A type representing the sequence's elements.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = UInt8

    /// A type that represents a position in the collection.
    ///
    /// Valid indices consist of the position of every element and a
    /// "past the end" position that's not valid for use as a subscript
    /// argument.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Index = Int

    /// A type that represents the indices that are valid for subscripting the
    /// collection, in ascending order.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Indices = Range<Int>

    /// A type that provides the collection's iteration interface and
    /// encapsulates its iteration state.
    ///
    /// By default, a collection conforms to the `Sequence` protocol by
    /// supplying `IndexingIterator` as its associated `Iterator`
    /// type.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Iterator = IndexingIterator<NSData>

    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Regions = [Data]

    /// A collection representing a contiguous subrange of this collection's
    /// elements. The subsequence shares indices with the original collection.
    ///
    /// The default subsequence type for collections that don't define their own
    /// is `Slice`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias SubSequence = Slice<NSData>
}

@available(macOS 10.12, iOS 10.0, watchOS 3.0, tvOS 10.0, *)
extension MeasurementFormatter {

    public func string<UnitType>(from measurement: Measurement<UnitType>) -> String where UnitType : Unit
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSPredicate {

    public convenience init(format predicateFormat: String, _ args: any CVarArg...)
}

@available(macOS 15.0, iOS 18.0, tvOS 18.0, watchOS 11.0, *)
extension RangeSet where Bound == Int {

    public init(_ indices: IndexSet)
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension NotificationCenter {

    /// Returns an asynchronous sequence of messages produced by this center for a given subject and identifier.
    /// - Parameters:
    ///   - subject: The subject to observe. Specify a metatype to observe all values for a given type.
    ///   - identifier: An identifier representing a specific message type.
    ///   - limit: The maximum number of messages allowed to buffer.
    /// - Returns: An asynchronous sequence of messages produced by this center.
    public func messages<Identifier, Message>(of subject: Message.Subject, for identifier: Identifier, bufferSize limit: Int = 10) -> some AsyncSequence<Message, Never> where Identifier : NotificationCenter.MessageIdentifier, Message : NotificationCenter.AsyncMessage, Message == Identifier.MessageType, Message.Subject : AnyObject


    /// Returns an asynchronous sequence of messages produced by this center for a given subject type and identifier.
    /// - Parameters:
    ///   - subject: The metatype to observe all values for a given type.
    ///   - identifier: An identifier representing a specific message type.
    ///   - limit: The maximum number of messages allowed to buffer.
    /// - Returns: An asynchronous sequence of messages produced by this center.
    public func messages<Identifier, Message>(of subject: Message.Subject.Type, for identifier: Identifier, bufferSize limit: Int = 10) -> some AsyncSequence<Message, Never> where Identifier : NotificationCenter.MessageIdentifier, Message : NotificationCenter.AsyncMessage, Message == Identifier.MessageType


    /// Returns an asynchronous sequence of messages produced by this center for a given subject and message type.
    /// - Parameters:
    ///   - subject: The subject to observe. Specify a metatype to observe all values for a given type.
    ///   - messageType: The message type to be observed.
    ///   - limit: The maximum number of messages allowed to buffer.
    /// - Returns: An asynchronous sequence of messages produced by this center.
    public func messages<Message>(of subject: Message.Subject? = nil, for messageType: Message.Type, bufferSize limit: Int = 10) -> some AsyncSequence<Message, Never> where Message : NotificationCenter.AsyncMessage, Message.Subject : AnyObject

}

extension URLCache {

    @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, macCatalyst 13.1, *)
    public convenience init(memoryCapacity: Int, diskCapacity: Int, directory: URL? = nil)
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension HTTPCookieStorage {

    public struct CookiesChangedMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = HTTPCookieStorage

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> HTTPCookieStorage.CookiesChangedMessage?
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension UndoManager {

    public struct WillUndoChangeMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = UndoManager

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> UndoManager.WillUndoChangeMessage?
    }

    public struct DidUndoChangeMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = UndoManager

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public var groupIsDiscardable: Bool

        public init(groupIsDiscardable: Bool)

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> UndoManager.DidUndoChangeMessage?

        /// Converts a posted main actor message into a notification for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, use the properties defined by the message to populate the ``Notification``'s ``Notification/userInfo``.
        /// - Parameters:
        ///   - message: The posted `MainActorMessage`.
        /// - Returns: The converted ``Notification``.
        @MainActor public static func makeNotification(_ message: UndoManager.DidUndoChangeMessage) -> Notification
    }

    public struct WillRedoChangeMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = UndoManager

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> UndoManager.WillRedoChangeMessage?
    }

    public struct DidRedoChangeMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = UndoManager

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public var groupIsDiscardable: Bool

        public init(groupIsDiscardable: Bool)

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> UndoManager.DidRedoChangeMessage?

        /// Converts a posted main actor message into a notification for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, use the properties defined by the message to populate the ``Notification``'s ``Notification/userInfo``.
        /// - Parameters:
        ///   - message: The posted `MainActorMessage`.
        /// - Returns: The converted ``Notification``.
        @MainActor public static func makeNotification(_ message: UndoManager.DidRedoChangeMessage) -> Notification
    }

    public struct CheckpointMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = UndoManager

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> UndoManager.CheckpointMessage?
    }

    public struct DidOpenUndoGroupMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = UndoManager

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> UndoManager.DidOpenUndoGroupMessage?
    }

    public struct DidCloseUndoGroupMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = UndoManager

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public var groupIsDiscardable: Bool

        public init(groupIsDiscardable: Bool)

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> UndoManager.DidCloseUndoGroupMessage?

        /// Converts a posted main actor message into a notification for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, use the properties defined by the message to populate the ``Notification``'s ``Notification/userInfo``.
        /// - Parameters:
        ///   - message: The posted `MainActorMessage`.
        /// - Returns: The converted ``Notification``.
        @MainActor public static func makeNotification(_ message: UndoManager.DidCloseUndoGroupMessage) -> Notification
    }

    public struct WillCloseUndoGroupMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = UndoManager

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> UndoManager.WillCloseUndoGroupMessage?
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension NSMetadataQuery {

    public struct DidFinishGatheringMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = NSMetadataQuery

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> NSMetadataQuery.DidFinishGatheringMessage?
    }

    public struct DidStartGatheringMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = NSMetadataQuery

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> NSMetadataQuery.DidStartGatheringMessage?
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension ProcessInfo {

    public struct PowerStateDidChangeMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = ProcessInfo

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> ProcessInfo.PowerStateDidChangeMessage?
    }

    public struct ThermalStateDidChangeMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = ProcessInfo

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> ProcessInfo.ThermalStateDidChangeMessage?
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension FileHandle {

    public struct ConnectionAcceptedMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = FileHandle

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public var fileHandleItem: Result<FileHandle, POSIXError>

        public init(fileHandleItem: Result<FileHandle, POSIXError>)

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> FileHandle.ConnectionAcceptedMessage?

        /// Converts a posted asynchronous message into a notification for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, use the properties defined by the message to populate the ``Notification``'s ``Notification/userInfo``.
        /// - Parameters:
        ///   - message: The posted `AsyncMessage`.
        /// - Returns: The converted ``Notification``.
        public static func makeNotification(_ message: FileHandle.ConnectionAcceptedMessage) -> Notification
    }

    public struct DataAvailableMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = FileHandle

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> FileHandle.DataAvailableMessage?
    }

    public struct ReadToEndOfFileCompletionMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = FileHandle

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public var dataItem: Result<Data, POSIXError>

        public init(dataItem: Result<Data, POSIXError>)

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> FileHandle.ReadToEndOfFileCompletionMessage?

        /// Converts a posted asynchronous message into a notification for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, use the properties defined by the message to populate the ``Notification``'s ``Notification/userInfo``.
        /// - Parameters:
        ///   - message: The posted `AsyncMessage`.
        /// - Returns: The converted ``Notification``.
        public static func makeNotification(_ message: FileHandle.ReadToEndOfFileCompletionMessage) -> Notification
    }

    public struct ReadCompletionMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = FileHandle

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public var dataItem: Result<Data, POSIXError>

        public init(dataItem: Result<Data, POSIXError>)

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> FileHandle.ReadCompletionMessage?

        /// Converts a posted asynchronous message into a notification for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, use the properties defined by the message to populate the ``Notification``'s ``Notification/userInfo``.
        /// - Parameters:
        ///   - message: The posted `AsyncMessage`.
        /// - Returns: The converted ``Notification``.
        public static func makeNotification(_ message: FileHandle.ReadCompletionMessage) -> Notification
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Bundle {

    public struct DidLoadMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = Bundle

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> Bundle.DidLoadMessage?
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension UserDefaults {

    public struct DidChangeMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = UserDefaults

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> UserDefaults.DidChangeMessage?
    }

    public struct SizeLimitExceededMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = UserDefaults

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> UserDefaults.SizeLimitExceededMessage?
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension Port {

    public struct DidBecomeInvalidMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = Port

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> Port.DidBecomeInvalidMessage?
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension FileManager {

    public struct UbiquityIdentityDidChangeMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = FileManager

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> FileManager.UbiquityIdentityDidChangeMessage?
    }
}

@available(iOS 26.0, tvOS 26.0, watchOS 26.0, *)
@available(macOS, unavailable)
extension NSBundleResourceRequest {

    public struct LowDiskSpaceMessage : NotificationCenter.AsyncMessage {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        public typealias Subject = NSBundleResourceRequest

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        public static func makeMessage(_ notification: Notification) -> NSBundleResourceRequest.LowDiskSpaceMessage?
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension NSExtensionContext {

    public struct DidBecomeActiveMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = NSExtensionContext

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> NSExtensionContext.DidBecomeActiveMessage?
    }

    public struct DidEnterBackgroundMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = NSExtensionContext

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> NSExtensionContext.DidEnterBackgroundMessage?
    }

    public struct WillEnterForegroundMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = NSExtensionContext

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> NSExtensionContext.WillEnterForegroundMessage?
    }

    public struct WillResignActiveMessage : NotificationCenter.MainActorMessage, Sendable {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        public typealias Subject = NSExtensionContext

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        public static var name: Notification.Name { get }

        public init()

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor public static func makeMessage(_ notification: Notification) -> NSExtensionContext.WillResignActiveMessage?
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSTextCheckingResult.CheckingType {

    public static var allSystemTypes: NSTextCheckingResult.CheckingType { get }

    public static var allCustomTypes: NSTextCheckingResult.CheckingType { get }

    public static var allTypes: NSTextCheckingResult.CheckingType { get }
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension OperationQueue : Scheduler {

    /// The scheduler time type used by the operation queue.
    public struct SchedulerTimeType : Strideable, Codable, Hashable, Sendable {

        /// The date represented by this type.
        public var date: Date

        /// Initializes a operation queue scheduler time with the given date.
        ///
        /// - Parameter date: The date to represent.
        public init(_ date: Date)

        /// Returns the distance to another operation queue scheduler time.
        ///
        /// - Parameter other: Another operation queue time.
        /// - Returns: The time interval between this time and the provided time.
        public func distance(to other: OperationQueue.SchedulerTimeType) -> OperationQueue.SchedulerTimeType.Stride

        /// Returns a operation queue scheduler time calculated by advancing this instance’s time by the given interval.
        ///
        /// - Parameter n: A time interval to advance.
        /// - Returns: A operation queue time advanced by the given interval from this instance’s time.
        public func advanced(by n: OperationQueue.SchedulerTimeType.Stride) -> OperationQueue.SchedulerTimeType

        /// The interval by which operation queue times advance.
        public struct Stride : ExpressibleByFloatLiteral, Comparable, SignedNumeric, Codable, SchedulerTimeIntervalConvertible, Sendable {

            /// A type that represents a floating-point literal.
            ///
            /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
            /// where available.
            public typealias FloatLiteralType = TimeInterval

            /// A type that represents an integer literal.
            ///
            /// The standard library integer and floating-point types are all valid types
            /// for `IntegerLiteralType`.
            public typealias IntegerLiteralType = TimeInterval

            /// A type that can represent the absolute value of any possible value of the
            /// conforming type.
            public typealias Magnitude = TimeInterval

            /// The value of this time interval in seconds.
            public var magnitude: TimeInterval

            /// The value of this time interval in seconds.
            public var timeInterval: TimeInterval { get }

            /// Creates an instance initialized to the specified integer value.
            ///
            /// Do not call this initializer directly. Instead, initialize a variable or
            /// constant using an integer literal. For example:
            ///
            ///     let x = 23
            ///
            /// In this example, the assignment to the `x` constant calls this integer
            /// literal initializer behind the scenes.
            ///
            /// - Parameter value: The value to create.
            public init(integerLiteral value: TimeInterval)

            /// Creates an instance initialized to the specified floating-point value.
            ///
            /// Do not call this initializer directly. Instead, initialize a variable or
            /// constant using a floating-point literal. For example:
            ///
            ///     let x = 21.5
            ///
            /// In this example, the assignment to the `x` constant calls this
            /// floating-point literal initializer behind the scenes.
            ///
            /// - Parameter value: The value to create.
            public init(floatLiteral value: TimeInterval)

            public init(_ timeInterval: TimeInterval)

            /// Creates a new instance from the given integer, if it can be represented
            /// exactly.
            ///
            /// If the value passed as `source` is not representable exactly, the result
            /// is `nil`. In the following example, the constant `x` is successfully
            /// created from a value of `100`, while the attempt to initialize the
            /// constant `y` from `1_000` fails because the `Int8` type can represent
            /// `127` at maximum:
            ///
            ///     let x = Int8(exactly: 100)
            ///     // x == Optional(100)
            ///     let y = Int8(exactly: 1_000)
            ///     // y == nil
            ///
            /// - Parameter source: A value to convert to this type.
            public init?<T>(exactly source: T) where T : BinaryInteger

            /// Returns a Boolean value indicating whether the value of the first
            /// argument is less than that of the second argument.
            ///
            /// This function is the only requirement of the `Comparable` protocol. The
            /// remainder of the relational operator functions are implemented by the
            /// standard library for any type that conforms to `Comparable`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func < (lhs: OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride) -> Bool

            /// Multiplies two values and produces their product.
            ///
            /// The multiplication operator (`*`) calculates the product of its two
            /// arguments. For example:
            ///
            ///     2 * 3                   // 6
            ///     100 * 21                // 2100
            ///     -10 * 15                // -150
            ///     3.5 * 2.25              // 7.875
            ///
            /// You cannot use `*` with arguments of different types. To multiply values
            /// of different types, convert one of the values to the other value's type.
            ///
            ///     let x: Int8 = 21
            ///     let y: Int = 1000000
            ///     Int(x) * y              // 21000000
            ///
            /// - Parameters:
            ///   - lhs: The first value to multiply.
            ///   - rhs: The second value to multiply.
            public static func * (lhs: OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride) -> OperationQueue.SchedulerTimeType.Stride

            /// Adds two values and produces their sum.
            ///
            /// The addition operator (`+`) calculates the sum of its two arguments. For
            /// example:
            ///
            ///     1 + 2                   // 3
            ///     -10 + 15                // 5
            ///     -15 + -5                // -20
            ///     21.5 + 3.25             // 24.75
            ///
            /// You cannot use `+` with arguments of different types. To add values of
            /// different types, convert one of the values to the other value's type.
            ///
            ///     let x: Int8 = 21
            ///     let y: Int = 1000000
            ///     Int(x) + y              // 1000021
            ///
            /// - Parameters:
            ///   - lhs: The first value to add.
            ///   - rhs: The second value to add.
            public static func + (lhs: OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride) -> OperationQueue.SchedulerTimeType.Stride

            /// Subtracts one value from another and produces their difference.
            ///
            /// The subtraction operator (`-`) calculates the difference of its two
            /// arguments. For example:
            ///
            ///     8 - 3                   // 5
            ///     -10 - 5                 // -15
            ///     100 - -5                // 105
            ///     10.5 - 100.0            // -89.5
            ///
            /// You cannot use `-` with arguments of different types. To subtract values
            /// of different types, convert one of the values to the other value's type.
            ///
            ///     let x: UInt8 = 21
            ///     let y: UInt = 1000000
            ///     y - UInt(x)             // 999979
            ///
            /// - Parameters:
            ///   - lhs: A numeric value.
            ///   - rhs: The value to subtract from `lhs`.
            public static func - (lhs: OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride) -> OperationQueue.SchedulerTimeType.Stride

            /// Multiplies two values and stores the result in the left-hand-side
            /// variable.
            ///
            /// - Parameters:
            ///   - lhs: The first value to multiply.
            ///   - rhs: The second value to multiply.
            public static func *= (lhs: inout OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride)

            /// Adds two values and stores the result in the left-hand-side variable.
            ///
            /// - Parameters:
            ///   - lhs: The first value to add.
            ///   - rhs: The second value to add.
            public static func += (lhs: inout OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride)

            /// Subtracts the second value from the first and stores the difference in the
            /// left-hand-side variable.
            ///
            /// - Parameters:
            ///   - lhs: A numeric value.
            ///   - rhs: The value to subtract from `lhs`.
            public static func -= (lhs: inout OperationQueue.SchedulerTimeType.Stride, rhs: OperationQueue.SchedulerTimeType.Stride)

            /// Converts the specified number of seconds into an instance of this scheduler time type.
            public static func seconds(_ s: Int) -> OperationQueue.SchedulerTimeType.Stride

            /// Converts the specified number of seconds, as a floating-point value, into an instance of this scheduler time type.
            public static func seconds(_ s: Double) -> OperationQueue.SchedulerTimeType.Stride

            /// Converts the specified number of milliseconds into an instance of this scheduler time type.
            public static func milliseconds(_ ms: Int) -> OperationQueue.SchedulerTimeType.Stride

            /// Converts the specified number of microseconds into an instance of this scheduler time type.
            public static func microseconds(_ us: Int) -> OperationQueue.SchedulerTimeType.Stride

            /// Converts the specified number of nanoseconds into an instance of this scheduler time type.
            public static func nanoseconds(_ ns: Int) -> OperationQueue.SchedulerTimeType.Stride

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: OperationQueue.SchedulerTimeType.Stride, b: OperationQueue.SchedulerTimeType.Stride) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        /// Encodes this value into the given encoder.
        ///
        /// If the value fails to encode anything, `encoder` will encode an empty
        /// keyed container in its place.
        ///
        /// This function throws an error if any values are invalid for the given
        /// encoder's format.
        ///
        /// - Parameter encoder: The encoder to write data to.
        public func encode(to encoder: any Encoder) throws

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }

        /// Creates a new instance by decoding from the given decoder.
        ///
        /// This initializer throws an error if reading from the decoder fails, or
        /// if the data read is corrupted or otherwise invalid.
        ///
        /// - Parameter decoder: The decoder to read data from.
        public init(from decoder: any Decoder) throws
    }

    /// Options that affect the operation of the operation queue scheduler.
    public struct SchedulerOptions : Sendable {
    }

    /// Performs the action at the next possible opportunity.
    public func schedule(options: OperationQueue.SchedulerOptions?, _ action: @escaping () -> Void)

    /// Performs the action at some time after the specified date.
    public func schedule(after date: OperationQueue.SchedulerTimeType, tolerance: OperationQueue.SchedulerTimeType.Stride, options: OperationQueue.SchedulerOptions?, _ action: @escaping () -> Void)

    /// Performs the action at some time after the specified date, at the specified frequency, optionally taking into account tolerance if possible.
    public func schedule(after date: OperationQueue.SchedulerTimeType, interval: OperationQueue.SchedulerTimeType.Stride, tolerance: OperationQueue.SchedulerTimeType.Stride, options: OperationQueue.SchedulerOptions?, _ action: @escaping () -> Void) -> any Cancellable

    /// This scheduler’s definition of the current moment in time.
    public var now: OperationQueue.SchedulerTimeType { get }

    /// The minimum tolerance allowed by the scheduler.
    public var minimumTolerance: OperationQueue.SchedulerTimeType.Stride { get }
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSessionWebSocketTask {

    public enum Message : Sendable {

        case data(Data)

        case string(String)
    }

    @preconcurrency public func send(_ message: URLSessionWebSocketTask.Message, completionHandler: @escaping @Sendable ((any Error)?) -> Void)

    public func send(_ message: URLSessionWebSocketTask.Message) async throws

    @preconcurrency public func receive(completionHandler: @escaping @Sendable (Result<URLSessionWebSocketTask.Message, any Error>) -> Void)

    public func receive() async throws -> URLSessionWebSocketTask.Message
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSessionTaskTransactionMetrics {

    public var localPort: Int? { get }

    public var remotePort: Int? { get }

    public var negotiatedTLSProtocolVersion: tls_protocol_version_t? { get }

    public var negotiatedTLSCipherSuite: tls_ciphersuite_t? { get }
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension URLSession {

    /// Convenience method to load data using a URLRequest, creates and resumes a URLSessionDataTask internally.
    ///
    /// - Parameter request: The URLRequest for which to load data.
    /// - Parameter delegate: Task-specific delegate.
    /// - Returns: Data and response.
    public func data(for request: URLRequest, delegate: (any URLSessionTaskDelegate)? = nil) async throws -> (Data, URLResponse)

    /// Convenience method to load data using a URL, creates and resumes a URLSessionDataTask internally.
    ///
    /// - Parameter url: The URL for which to load data.
    /// - Parameter delegate: Task-specific delegate.
    /// - Returns: Data and response.
    public func data(from url: URL, delegate: (any URLSessionTaskDelegate)? = nil) async throws -> (Data, URLResponse)

    /// Convenience method to upload data using a URLRequest, creates and resumes a URLSessionUploadTask internally.
    ///
    /// - Parameter request: The URLRequest for which to upload data.
    /// - Parameter fileURL: File to upload.
    /// - Parameter delegate: Task-specific delegate.
    /// - Returns: Data and response.
    public func upload(for request: URLRequest, fromFile fileURL: URL, delegate: (any URLSessionTaskDelegate)? = nil) async throws -> (Data, URLResponse)

    /// Convenience method to upload data using a URLRequest, creates and resumes a URLSessionUploadTask internally.
    ///
    /// - Parameter request: The URLRequest for which to upload data.
    /// - Parameter bodyData: Data to upload.
    /// - Parameter delegate: Task-specific delegate.
    /// - Returns: Data and response.
    public func upload(for request: URLRequest, from bodyData: Data, delegate: (any URLSessionTaskDelegate)? = nil) async throws -> (Data, URLResponse)

    /// Convenience method to download using a URLRequest, creates and resumes a URLSessionDownloadTask internally.
    ///
    /// - Parameter request: The URLRequest for which to download.
    /// - Parameter delegate: Task-specific delegate.
    /// - Returns: Downloaded file URL and response. The file will not be removed automatically.
    public func download(for request: URLRequest, delegate: (any URLSessionTaskDelegate)? = nil) async throws -> (URL, URLResponse)

    /// Convenience method to download using a URL, creates and resumes a URLSessionDownloadTask internally.
    ///
    /// - Parameter url: The URL for which to download.
    /// - Parameter delegate: Task-specific delegate.
    /// - Returns: Downloaded file URL and response. The file will not be removed automatically.
    public func download(from url: URL, delegate: (any URLSessionTaskDelegate)? = nil) async throws -> (URL, URLResponse)

    /// Convenience method to resume download, creates and resumes a URLSessionDownloadTask internally.
    ///
    /// - Parameter resumeData: Resume data from an incomplete download.
    /// - Parameter delegate: Task-specific delegate.
    /// - Returns: Downloaded file URL and response. The file will not be removed automatically.
    public func download(resumeFrom resumeData: Data, delegate: (any URLSessionTaskDelegate)? = nil) async throws -> (URL, URLResponse)

    /// AsyncBytes conforms to AsyncSequence for data delivery. The sequence is single pass. Delegate will not be called for response and data delivery.
    public struct AsyncBytes : AsyncSequence, Sendable {

        /// Underlying data task providing the bytes.
        public var task: URLSessionDataTask { get }

        /// The type of element produced by this asynchronous sequence.
        public typealias Element = UInt8

        /// The type of asynchronous iterator that produces elements of this
        /// asynchronous sequence.
        public typealias AsyncIterator = URLSession.AsyncBytes.Iterator

        @frozen public struct Iterator : AsyncIteratorProtocol, Sendable {

            public typealias Element = UInt8

            /// Asynchronously advances to the next element and returns it, or ends the
            /// sequence if there is no next element.
            ///
            /// - Returns: The next element, if it exists, or `nil` to signal the end of
            ///   the sequence.
            @inlinable public mutating func next() async throws -> UInt8?
        }

        /// Creates the asynchronous iterator that produces elements of this
        /// asynchronous sequence.
        ///
        /// - Returns: An instance of the `AsyncIterator` type used to produce
        /// elements of the asynchronous sequence.
        public func makeAsyncIterator() -> URLSession.AsyncBytes.Iterator
    }

    /// Returns a byte stream that conforms to AsyncSequence protocol.
    ///
    /// - Parameter request: The URLRequest for which to load data.
    /// - Parameter delegate: Task-specific delegate.
    /// - Returns: Data stream and response.
    public func bytes(for request: URLRequest, delegate: (any URLSessionTaskDelegate)? = nil) async throws -> (URLSession.AsyncBytes, URLResponse)

    /// Returns a byte stream that conforms to AsyncSequence protocol.
    ///
    /// - Parameter url: The URL for which to load data.
    /// - Parameter delegate: Task-specific delegate.
    /// - Returns: Data stream and response.
    public func bytes(from url: URL, delegate: (any URLSessionTaskDelegate)? = nil) async throws -> (URLSession.AsyncBytes, URLResponse)
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSession {

    /// Convenience method to load data using a URLRequest, creates and resumes a URLSessionDataTask internally.
    ///
    /// - Parameter request: The URLRequest for which to load data.
    /// - Returns: Data and response.
    public func data(for request: URLRequest) async throws -> (Data, URLResponse)

    /// Convenience method to load data using a URL, creates and resumes a URLSessionDataTask internally.
    ///
    /// - Parameter url: The URL for which to load data.
    /// - Returns: Data and response.
    public func data(from url: URL) async throws -> (Data, URLResponse)

    /// Convenience method to upload data using a URLRequest, creates and resumes a URLSessionUploadTask internally.
    ///
    /// - Parameter request: The URLRequest for which to upload data.
    /// - Parameter fileURL: File to upload.
    /// - Returns: Data and response.
    public func upload(for request: URLRequest, fromFile fileURL: URL) async throws -> (Data, URLResponse)

    /// Convenience method to upload data using a URLRequest, creates and resumes a URLSessionUploadTask internally.
    ///
    /// - Parameter request: The URLRequest for which to upload data.
    /// - Parameter bodyData: Data to upload.
    /// - Returns: Data and response.
    public func upload(for request: URLRequest, from bodyData: Data) async throws -> (Data, URLResponse)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSString : ExpressibleByStringLiteral {

    /// Create an instance initialized to `value`.
    required public convenience init(stringLiteral value: StaticString)

    /// A type that represents an extended grapheme cluster literal.
    ///
    /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
    /// `String`, and `StaticString`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias ExtendedGraphemeClusterLiteralType = StaticString

    /// A type that represents a string literal.
    ///
    /// Valid types for `StringLiteralType` are `String` and `StaticString`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias StringLiteralType = StaticString

    /// A type that represents a Unicode scalar literal.
    ///
    /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
    /// `Character`, `String`, and `StaticString`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias UnicodeScalarLiteralType = StaticString
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSString {

    public convenience init(format: NSString, _ args: any CVarArg...)

    public convenience init(format: NSString, locale: Locale?, _ args: any CVarArg...)

    public class func localizedStringWithFormat(_ format: NSString, _ args: any CVarArg...) -> Self

    public func appendingFormat(_ format: NSString, _ args: any CVarArg...) -> NSString
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSMutableString {

    public func appendFormat(_ format: NSString, _ args: any CVarArg...)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSString {

    /// Returns an `NSString` object initialized by copying the characters
    /// from another given string.
    ///
    /// - Returns: An `NSString` object initialized by copying the
    ///   characters from `aString`. The returned object may be different
    ///   from the original receiver.
    @nonobjc public convenience init(string aString: NSString)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSString {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "NSString.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSExpression {

    public convenience init(format expressionFormat: String, _ args: any CVarArg...)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSExpression {

    public convenience init<Root, Value>(forKeyPath keyPath: KeyPath<Root, Value>)
}

extension NotificationCenter {

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    @preconcurrency public func notifications(named name: Notification.Name, object: (any AnyObject & Sendable)? = nil) -> NotificationCenter.Notifications

    @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
    final public class Notifications : AsyncSequence, Sendable {

        /// The type of element produced by this asynchronous sequence.
        public typealias Element = Notification

        @available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
        public struct Iterator : AsyncIteratorProtocol {

            /// Asynchronously advances to the next element and returns it, or ends the
            /// sequence if there is no next element.
            ///
            /// - Returns: The next element, if it exists, or `nil` to signal the end of
            ///   the sequence.
            public func next() async -> Notification?

            @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
            public typealias Element = Notification
        }

        @objc deinit

        /// Creates the asynchronous iterator that produces elements of this
        /// asynchronous sequence.
        ///
        /// - Returns: An instance of the `AsyncIterator` type used to produce
        /// elements of the asynchronous sequence.
        final public func makeAsyncIterator() -> NotificationCenter.Notifications.Iterator

        /// The type of asynchronous iterator that produces elements of this
        /// asynchronous sequence.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias AsyncIterator = NotificationCenter.Notifications.Iterator
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSError : Error {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CFError : Error, @unchecked Sendable {
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NotificationCenter {

    /// Returns a publisher that emits events when broadcasting notifications.
    ///
    /// - Parameters:
    ///   - name: The name of the notification to publish.
    ///   - object: The object posting the named notfication. If `nil`, the publisher emits elements for any object producing a notification with the given name.
    /// - Returns: A publisher that emits events when broadcasting notifications.
    public func publisher(for name: Notification.Name, object: AnyObject? = nil) -> NotificationCenter.Publisher
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension NotificationCenter {

    /// A publisher that emits elements when broadcasting notifications.
    public struct Publisher : Publisher {

        /// The kind of values published by this publisher.
        public typealias Output = Notification

        /// The kind of errors this publisher might publish.
        ///
        /// Use `Never` if this `Publisher` does not publish errors.
        public typealias Failure = Never

        /// The notification center this publisher uses as a source.
        public let center: NotificationCenter

        /// The name of notifications published by this publisher.
        public let name: Notification.Name

        /// The object posting the named notfication.
        public let object: AnyObject?

        /// Creates a publisher that emits events when broadcasting notifications.
        ///
        /// - Parameters:
        ///   - center: The notification center to publish notifications for.
        ///   - name: The name of the notification to publish.
        ///   - object: The object posting the named notfication. If `nil`, the publisher emits elements for any object producing a notification with the given name.
        public init(center: NotificationCenter, name: Notification.Name, object: AnyObject? = nil)

        /// Attaches the specified subscriber to this publisher.
        ///
        /// Implementations of ``Publisher`` must implement this method.
        ///
        /// The provided implementation of ``Publisher/subscribe(_:)-4u8kn``calls this method.
        ///
        /// - Parameter subscriber: The subscriber to attach to this ``Publisher``, after which it can receive values.
        public func receive<S>(subscriber: S) where S : Subscriber, S.Failure == Never, S.Input == Notification
    }
}

extension FileHandle {

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public struct AsyncBytes : AsyncSequence, Sendable {

        /// The type of element produced by this asynchronous sequence.
        public typealias Element = UInt8

        /// The type of asynchronous iterator that produces elements of this
        /// asynchronous sequence.
        public typealias AsyncIterator = FileHandle.AsyncBytes.Iterator

        /// Creates the asynchronous iterator that produces elements of this
        /// asynchronous sequence.
        ///
        /// - Returns: An instance of the `AsyncIterator` type used to produce
        /// elements of the asynchronous sequence.
        public func makeAsyncIterator() -> FileHandle.AsyncBytes.Iterator

        @frozen public struct Iterator : AsyncIteratorProtocol, Sendable {

            public typealias Element = UInt8

            /// Asynchronously advances to the next element and returns it, or ends the
            /// sequence if there is no next element.
            ///
            /// - Returns: The next element, if it exists, or `nil` to signal the end of
            ///   the sequence.
            @inlinable public mutating func next() async throws -> UInt8?
        }
    }

    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public var bytes: FileHandle.AsyncBytes { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSEnumerator : Sequence {

    /// Return an *iterator* over the *enumerator*.
    ///
    /// - Complexity: O(1).
    @available(*, noasync)
    public func makeIterator() -> NSFastEnumerationIterator

    /// A type representing the sequence's elements.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = Any

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Iterator = NSFastEnumerationIterator
}

@available(macOS 10.0, iOS 2.0, watchOS 1.0, tvOS 9.0, *)
extension DispatchData : DataProtocol {

    public struct Region : DataProtocol, ContiguousBytes, Sendable {

        /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
        /// discontiguous buffer of memory.  Each region is a contiguous buffer of
        /// bytes.
        ///
        /// The sum of the lengths of the associated regions must equal `self.count`
        /// (such that iterating `regions` and iterating `self` produces the same
        /// sequence of indices in the same number of index advancements).
        public var regions: CollectionOfOne<DispatchData.Region> { get }

        /// Accesses the element at the specified position.
        ///
        /// The following example accesses an element of an array through its
        /// subscript to print its value:
        ///
        ///     var streets = ["Adams", "Bryant", "Channing", "Douglas", "Evarts"]
        ///     print(streets[1])
        ///     // Prints "Bryant"
        ///
        /// You can subscript a collection with any valid index other than the
        /// collection's end index. The end index refers to the position one past
        /// the last element of a collection, so it doesn't correspond with an
        /// element.
        ///
        /// - Parameter position: The position of the element to access. `position`
        ///   must be a valid index of the collection that is not equal to the
        ///   `endIndex` property.
        ///
        /// - Complexity: O(1)
        public subscript(position: DispatchData.Index) -> UInt8 { get }

        /// The position of the first element in a nonempty collection.
        ///
        /// If the collection is empty, `startIndex` is equal to `endIndex`.
        public var startIndex: DispatchData.Index { get }

        /// The collection's "past the end" position---that is, the position one
        /// greater than the last valid subscript argument.
        ///
        /// When you need a range that includes the last element of a collection, use
        /// the half-open range operator (`..<`) with `endIndex`. The `..<` operator
        /// creates a range that doesn't include the upper bound, so it's always
        /// safe to use with `endIndex`. For example:
        ///
        ///     let numbers = [10, 20, 30, 40, 50]
        ///     if let index = numbers.firstIndex(of: 30) {
        ///         print(numbers[index ..< numbers.endIndex])
        ///     }
        ///     // Prints "[30, 40, 50]"
        ///
        /// If the collection is empty, `endIndex` is equal to `startIndex`.
        public var endIndex: DispatchData.Index { get }

        /// Calls the given closure with the contents of underlying storage.
        ///
        /// - note: Calling `withUnsafeBytes` multiple times does not guarantee that
        ///         the same buffer pointer will be passed in every time.
        /// - warning: The buffer argument to the body should not be stored or used
        ///            outside of the lifetime of the call to the closure.
        public func withUnsafeBytes<ResultType>(_ body: (UnsafeRawBufferPointer) throws -> ResultType) rethrows -> ResultType

        /// A type representing the sequence's elements.
        @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
        public typealias Element = UInt8

        /// A type that represents a position in the collection.
        ///
        /// Valid indices consist of the position of every element and a
        /// "past the end" position that's not valid for use as a subscript
        /// argument.
        @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
        public typealias Index = DispatchData.Index

        /// A type that represents the indices that are valid for subscripting the
        /// collection, in ascending order.
        @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
        public typealias Indices = Range<DispatchData.Index>

        /// A type that provides the collection's iteration interface and
        /// encapsulates its iteration state.
        ///
        /// By default, a collection conforms to the `Sequence` protocol by
        /// supplying `IndexingIterator` as its associated `Iterator`
        /// type.
        @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
        public typealias Iterator = IndexingIterator<DispatchData.Region>

        @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
        public typealias Regions = CollectionOfOne<DispatchData.Region>

        /// A collection representing a contiguous subrange of this collection's
        /// elements. The subsequence shares indices with the original collection.
        ///
        /// The default subsequence type for collections that don't define their own
        /// is `Slice`.
        @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
        public typealias SubSequence = Slice<DispatchData.Region>
    }

    /// A `BidirectionalCollection` of `DataProtocol` elements which compose a
    /// discontiguous buffer of memory.  Each region is a contiguous buffer of
    /// bytes.
    ///
    /// The sum of the lengths of the associated regions must equal `self.count`
    /// (such that iterating `regions` and iterating `self` produces the same
    /// sequence of indices in the same number of index advancements).
    public var regions: [DispatchData.Region] { get }

    @available(iOS 2.0, tvOS 9.0, watchOS 1.0, macOS 10.0, *)
    public typealias Regions = [DispatchData.Region]
}

extension UndoManager {

    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, macCatalyst 13.1, *)
    @MainActor @preconcurrency public func registerUndo<TargetType>(withTarget target: TargetType, handler: @escaping @MainActor (TargetType) -> Void) where TargetType : AnyObject

    /// Set the name of the action associated with the Undo or Redo command.
    ///
    /// - Parameter actionName: The name of the action. Pass in `nil` to reset the action name currently associated with the menu command.
    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    @MainActor @preconcurrency final public func setActionName(_ actionNameResource: LocalizedStringResource?)
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncSequence where Self.Element == UInt8 {

    /**
     A non-blocking sequence of `Characters` created by decoding the elements of `self` as UTF8.
     */
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public var characters: AsyncCharacterSequence<Self> { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Progress {

    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public var estimatedTimeRemaining: TimeInterval?

    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public var throughput: Int?

    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public var fileTotalCount: Int?

    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public var fileCompletedCount: Int?

    public func performAsCurrent<ReturnType>(withPendingUnitCount unitCount: Int64, using work: () throws -> ReturnType) rethrows -> ReturnType
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSDictionary : ExpressibleByDictionaryLiteral {

    /// Creates an instance initialized with the given key-value pairs.
    required public convenience init(dictionaryLiteral elements: (Any, Any)...)

    /// The key type of a dictionary literal.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Key = Any

    /// The value type of a dictionary literal.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Value = Any
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSDictionary : Sequence {

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    final public class Iterator : IteratorProtocol {

        /// Advances to the next element and returns it, or `nil` if no next element
        /// exists.
        ///
        /// Repeatedly calling this method returns, in order, all the elements of the
        /// underlying sequence. As soon as the sequence has run out of elements, all
        /// subsequent calls return `nil`.
        ///
        /// You must not call this method if any other copy of this iterator has been
        /// advanced with a call to its `next()` method.
        ///
        /// The following example shows how an iterator can be used explicitly to
        /// emulate a `for`-`in` loop. First, retrieve a sequence's iterator, and
        /// then call the iterator's `next()` method until it returns `nil`.
        ///
        ///     let numbers = [2, 3, 5, 7]
        ///     var numbersIterator = numbers.makeIterator()
        ///
        ///     while let num = numbersIterator.next() {
        ///         print(num)
        ///     }
        ///     // Prints "2"
        ///     // Prints "3"
        ///     // Prints "5"
        ///     // Prints "7"
        ///
        /// - Returns: The next element in the underlying sequence, if a next element
        ///   exists; otherwise, `nil`.
        final public func next() -> (key: Any, value: Any)?

        /// The type of element traversed by the iterator.
        @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
        public typealias Element = (key: Any, value: Any)

        @objc deinit
    }

    @objc dynamic public subscript(key: Any) -> Any? { get }

    /// Return an *iterator* over the elements of this *sequence*.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> NSDictionary.Iterator

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1).
    @nonobjc public var underestimatedCount: Int { get }

    /// A type representing the sequence's elements.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = (key: Any, value: Any)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSMutableDictionary {

    @objc override dynamic public subscript(key: Any) -> Any?
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSDictionary {

    /// Initializes a newly allocated dictionary and adds to it objects from
    /// another given dictionary.
    ///
    /// - Returns: An initialized dictionary--which might be different
    ///   than the original receiver--containing the keys and values
    ///   found in `otherDictionary`.
    @objc(__swiftInitWithDictionary_NSDictionary:) dynamic public convenience init(dictionary otherDictionary: NSDictionary)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSDictionary : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Dictionary : CVarArg {
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension String {

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public struct LocalizationOptions {

        public var replacements: [any CVarArg]?

        public init()
    }

    public struct LocalizationValue : Equatable, ExpressibleByStringInterpolation {

        @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
        public enum Placeholder : Codable, Hashable, Sendable {

            case int

            case uint

            case float

            case double

            case object

            /// Returns a Boolean value indicating whether two values are equal.
            ///
            /// Equality is the inverse of inequality. For any values `a` and `b`,
            /// `a == b` implies that `a != b` is `false`.
            ///
            /// - Parameters:
            ///   - lhs: A value to compare.
            ///   - rhs: Another value to compare.
            public static func == (a: String.LocalizationValue.Placeholder, b: String.LocalizationValue.Placeholder) -> Bool

            /// Encodes this value into the given encoder.
            ///
            /// If the value fails to encode anything, `encoder` will encode an empty
            /// keyed container in its place.
            ///
            /// This function throws an error if any values are invalid for the given
            /// encoder's format.
            ///
            /// - Parameter encoder: The encoder to write data to.
            public func encode(to encoder: any Encoder) throws

            /// Hashes the essential components of this value by feeding them into the
            /// given hasher.
            ///
            /// Implement this method to conform to the `Hashable` protocol. The
            /// components used for hashing must be the same as the components compared
            /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
            /// with each of these components.
            ///
            /// - Important: In your implementation of `hash(into:)`,
            ///   don't call `finalize()` on the `hasher` instance provided,
            ///   or replace it with a different instance.
            ///   Doing so may become a compile-time error in the future.
            ///
            /// - Parameter hasher: The hasher to use when combining the components
            ///   of this instance.
            public func hash(into hasher: inout Hasher)

            /// The hash value.
            ///
            /// Hash values are not guaranteed to be equal across different executions of
            /// your program. Do not save hash values to use during a future execution.
            ///
            /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
            ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
            ///   The compiler provides an implementation for `hashValue` for you.
            public var hashValue: Int { get }

            /// Creates a new instance by decoding from the given decoder.
            ///
            /// This initializer throws an error if reading from the decoder fails, or
            /// if the data read is corrupted or otherwise invalid.
            ///
            /// - Parameter decoder: The decoder to read data from.
            public init(from decoder: any Decoder) throws
        }

        public init(_ value: String)

        /// Creates an instance initialized to the given string value.
        ///
        /// - Parameter value: The value of the new instance.
        public init(stringLiteral value: String)

        /// Creates an instance from a string interpolation.
        /// 
        /// Most `StringInterpolation` types will store information about the
        /// literals and interpolations appended to them in one or more properties.
        /// `init(stringInterpolation:)` should use these properties to initialize
        /// the instance.
        /// 
        /// - Parameter stringInterpolation: An instance of `StringInterpolation`
        ///             which has had each segment of the string literal appended
        ///             to it.
        public init(stringInterpolation: String.LocalizationValue.StringInterpolation)

        /// The type each segment of a string literal containing interpolations
        /// should be appended to.
        ///
        /// The `StringLiteralType` of an interpolation type must match the
        /// `StringLiteralType` of the conforming type.
        public struct StringInterpolation : StringInterpolationProtocol {

            /// Creates an empty instance ready to be filled with string literal content.
            /// 
            /// Don't call this initializer directly. Instead, initialize a variable or
            /// constant using a string literal with interpolated expressions.
            /// 
            /// Swift passes this initializer a pair of arguments specifying the size of
            /// the literal segments and the number of interpolated segments. Use this
            /// information to estimate the amount of storage you will need.
            /// 
            /// - Parameter literalCapacity: The approximate size of all literal segments
            ///   combined. This is meant to be passed to `String.reserveCapacity(_:)`;
            ///   it may be slightly larger or smaller than the sum of the counts of each
            ///   literal segment.
            /// - Parameter interpolationCount: The number of interpolations which will be
            ///   appended. Use this value to estimate how much additional capacity will
            ///   be needed for the interpolated segments.
            public init(literalCapacity: Int, interpolationCount: Int)

            /// Appends a literal segment to the interpolation.
            /// 
            /// Don't call this method directly. Instead, initialize a variable or
            /// constant using a string literal with interpolated expressions.
            /// 
            /// Interpolated expressions don't pass through this method; instead, Swift
            /// selects an overload of `appendInterpolation`. For more information, see
            /// the top-level `StringInterpolationProtocol` documentation.
            /// 
            /// - Parameter literal: A string literal containing the characters
            ///   that appear next in the string literal.
            public mutating func appendLiteral(_ literal: String)

            public mutating func appendInterpolation(_ string: String)

            public mutating func appendInterpolation(_ substring: Substring)

            @available(*, deprecated, message: "Localized string interpolation produces an unlocalized, debug description for this type of value. Use String(describing:) to make this explicit and silence this warning or provide a different value that has built-in support or conforms to CustomLocalizedStringResourceConvertible.")
            public mutating func appendInterpolation<T>(_ object: T)

            public mutating func appendInterpolation<Subject>(_ subject: Subject) where Subject : NSObject

            public mutating func appendInterpolation<T>(_ value: T) where T : _FormatSpecifiable

            public mutating func appendInterpolation<T>(_ value: T, specifier: String) where T : _FormatSpecifiable

            @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
            public mutating func appendInterpolation(placeholder: String.LocalizationValue.Placeholder)

            @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
            public mutating func appendInterpolation(placeholder: String.LocalizationValue.Placeholder, specifier: String)

            @preconcurrency public mutating func appendInterpolation<T, F>(_ value: T, format: F) where T : Sendable, T == F.FormatInput, F : FormatStyle, F : Sendable, F.FormatOutput : StringProtocol

            @preconcurrency public mutating func appendInterpolation<T, F>(_ value: T, format: F) where T : Sendable, T == F.FormatInput, F : FormatStyle, F : Sendable, F.FormatOutput : AttributedStringProtocol

            public mutating func appendInterpolation(_ attrStr: AttributedString, options: AttributedString.InterpolationOptions = [])

            public mutating func appendInterpolation(_ attributedSubstring: AttributedSubstring, options: AttributedString.InterpolationOptions = [])

            @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
            public mutating func appendInterpolation<T>(_ value: T) where T : CustomLocalizedStringResourceConvertible

            @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
            public mutating func appendInterpolation<C>(_ value: C, format: ListFormatStyle<StringStyle, [String]>) where C : Collection, C.Element : CustomLocalizedStringResourceConvertible

            /// The type that should be used for literal segments.
            @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
            public typealias StringLiteralType = String
        }

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: String.LocalizationValue, b: String.LocalizationValue) -> Bool

        /// A type that represents an extended grapheme cluster literal.
        ///
        /// Valid types for `ExtendedGraphemeClusterLiteralType` are `Character`,
        /// `String`, and `StaticString`.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias ExtendedGraphemeClusterLiteralType = String

        /// A type that represents a string literal.
        ///
        /// Valid types for `StringLiteralType` are `String` and `StaticString`.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias StringLiteralType = String

        /// A type that represents a Unicode scalar literal.
        ///
        /// Valid types for `UnicodeScalarLiteralType` are `Unicode.Scalar`,
        /// `Character`, `String`, and `StaticString`.
        @available(iOS 15, tvOS 15, watchOS 8, macOS 12, *)
        public typealias UnicodeScalarLiteralType = String
    }

    public init(localized keyAndValue: String.LocalizationValue, table: String? = nil, bundle: Bundle? = nil, locale: Locale = .current, comment: StaticString? = nil)

    public init(localized key: StaticString, defaultValue: String.LocalizationValue, table: String? = nil, bundle: Bundle? = nil, locale: Locale = .current, comment: StaticString? = nil)

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init(localized keyAndValue: String.LocalizationValue, options: String.LocalizationOptions, table: String? = nil, bundle: Bundle? = nil, locale: Locale = .current, comment: StaticString? = nil)

    @available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
    public init(localized key: StaticString, defaultValue: String.LocalizationValue, options: String.LocalizationOptions, table: String? = nil, bundle: Bundle? = nil, locale: Locale = .current, comment: StaticString? = nil)
}

@available(macOS 13, iOS 16, tvOS 16, watchOS 9, *)
extension String {

    public init(localized resource: LocalizedStringResource)

    public init(localized resource: LocalizedStringResource, options: String.LocalizationOptions)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSObject : CustomStringConvertible {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSObject : CustomDebugStringConvertible {
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSLocking {

    public func withLock<R>(_ body: () throws -> R) rethrows -> R
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSDate {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "NSDate.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

@available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
extension NSItemProvider {

    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    @preconcurrency public func registerObject<T>(ofClass: T.Type, visibility: NSItemProviderRepresentationVisibility, loadHandler: @escaping @Sendable (@Sendable (T?, (any Error)?) -> Void) -> Progress?) where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderWriting

    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    public func canLoadObject<T>(ofClass: T.Type) -> Bool where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading

    @available(macOS 10.13, iOS 11.0, watchOS 4.0, tvOS 11.0, *)
    @preconcurrency public func loadObject<T>(ofClass: T.Type, completionHandler: @escaping @Sendable (T?, (any Error)?) -> Void) -> Progress where T : _ObjectiveCBridgeable, T._ObjectiveCType : NSItemProviderReading
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String {

    /// An array of the encodings that strings support in the application's
    /// environment.
    public static var availableStringEncodings: [String.Encoding] { get }

    /// The C-string encoding assumed for any method accepting a C string as an
    /// argument.
    public static var defaultCStringEncoding: String.Encoding { get }

    /// Returns a human-readable string giving the name of the specified encoding.
    ///
    /// - Parameter encoding: A string encoding. For possible values, see
    ///   `String.Encoding`.
    /// - Returns: A human-readable string giving the name of `encoding` in the
    ///   current locale.
    public static func localizedName(of encoding: String.Encoding) -> String

    /// Returns a string created by using a given format string as a
    /// template into which the remaining argument values are substituted
    /// according to the user's default locale.
    public static func localizedStringWithFormat(_ format: String, _ arguments: any CVarArg...) -> String

    /// Creates a string by copying the data from a given
    /// null-terminated C array of UTF8-encoded bytes.
    public init?(utf8String bytes: UnsafePointer<CChar>)

    /// Creates a string by copying the data from a given
    /// null-terminated array of UTF8-encoded bytes.
    public init?(utf8String bytes: [CChar])

    @available(*, deprecated, message: "Use a copy of the String argument")
    public init?(utf8String bytes: String)

    @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
    public init?(utf8String bytes: inout CChar)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension String {

    /// Creates a new string that contains the specified number of bytes from the
    /// given buffer, interpreted in the specified encoding, and optionally
    /// frees the buffer.
    ///
    /// - Warning: This initializer is not memory-safe!
    @available(macOS, deprecated: 13, message: "String does not support no-copy initialization")
    @available(iOS, deprecated: 16, message: "String does not support no-copy initialization")
    @available(tvOS, deprecated: 16, message: "String does not support no-copy initialization")
    @available(watchOS, deprecated: 9, message: "String does not support no-copy initialization")
    public init?(bytesNoCopy bytes: UnsafeMutableRawPointer, length: Int, encoding: String.Encoding, freeWhenDone flag: Bool)

    /// Creates a new string that contains the specified number of characters
    /// from the given C array of Unicode characters.
    public init(utf16CodeUnits: UnsafePointer<unichar>, count: Int)

    /// Creates a new string that contains the specified number of characters
    /// from the given C array of UTF-16 code units.
    @available(macOS, deprecated: 13, message: "String does not support no-copy initialization")
    @available(iOS, deprecated: 16, message: "String does not support no-copy initialization")
    @available(tvOS, deprecated: 16, message: "String does not support no-copy initialization")
    @available(watchOS, deprecated: 9, message: "String does not support no-copy initialization")
    public init(utf16CodeUnitsNoCopy: UnsafePointer<unichar>, count: Int, freeWhenDone flag: Bool)

    @available(macOS, deprecated: 15, message: "Use `init(contentsOfFile:encoding:)` instead")
    @available(iOS, deprecated: 18, message: "Use `init(contentsOfFile:encoding:)` instead")
    @available(tvOS, deprecated: 18, message: "Use `init(contentsOfFile:encoding:)` instead")
    @available(watchOS, deprecated: 11, message: "Use `init(contentsOfFile:encoding:)` instead")
    public init(contentsOfFile path: String) throws

    @available(macOS, deprecated: 15, message: "Use `init(contentsOf:encoding:)` instead")
    @available(iOS, deprecated: 18, message: "Use `init(contentsOf:encoding:)` instead")
    @available(tvOS, deprecated: 18, message: "Use `init(contentsOf:encoding:)` instead")
    @available(watchOS, deprecated: 11, message: "Use `init(contentsOf:encoding:)` instead")
    public init(contentsOf url: URL) throws

    /// Produces a string by copying the null-terminated bytes
    /// in a given C array, interpreted according to a given encoding.
    public init?(cString: UnsafePointer<CChar>, encoding enc: String.Encoding)

    /// Produces a string by copying the null-terminated bytes
    /// in a given array, interpreted according to a given encoding.
    public init?(cString: [CChar], encoding enc: String.Encoding)

    @available(*, deprecated, message: "Use a copy of the String argument")
    public init?(cString: String, encoding enc: String.Encoding)

    @available(*, deprecated, message: "Use String(_ scalar: Unicode.Scalar)")
    public init?(cString: inout CChar, encoding enc: String.Encoding)

    /// Returns a `String` object initialized by using a given
    /// format string as a template into which the remaining argument
    /// values are substituted.
    public init(format: String, _ arguments: any CVarArg...)

    /// Returns a `String` object initialized by using a given
    /// format string as a template into which the remaining argument
    /// values are substituted according to the user's default locale.
    public init(format: String, arguments: [any CVarArg])

    /// Returns a `String` object initialized by using a given
    /// format string as a template into which the remaining argument
    /// values are substituted according to given locale information.
    public init(format: String, locale: Locale?, _ args: any CVarArg...)

    /// Returns a `String` object initialized by using a given
    /// format string as a template into which the remaining argument
    /// values are substituted according to given locale information.
    public init(format: String, locale: Locale?, arguments: [any CVarArg])
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension StringProtocol {

    /// Returns a Boolean value that indicates whether the string can be
    /// converted to the specified encoding without loss of information.
    ///
    /// - Parameter encoding: A string encoding.
    /// - Returns: `true` if the string can be encoded in `encoding` without loss
    ///   of information; otherwise, `false`.
    public func canBeConverted(to encoding: String.Encoding) -> Bool

    /// Returns the result of invoking `compare:options:` with
    /// `NSCaseInsensitiveSearch` as the only option.
    public func caseInsensitiveCompare<T>(_ aString: T) -> ComparisonResult where T : StringProtocol

    /// Returns a string containing characters this string and the
    /// given string have in common, starting from the beginning of each
    /// up to the first characters that aren't equivalent.
    public func commonPrefix<T>(with aString: T, options: String.CompareOptions = []) -> String where T : StringProtocol

    /// Compares the string using the specified options and
    /// returns the lexical ordering for the range.
    public func compare<T>(_ aString: T, options mask: String.CompareOptions = [], range: Range<Self.Index>? = nil, locale: Locale? = nil) -> ComparisonResult where T : StringProtocol

    /// Interprets the string as a path in the file system and
    /// attempts to perform filename completion, returning a numeric
    /// value that indicates whether a match was possible, and by
    /// reference the longest path that matches the string.
    ///
    /// - Returns: The actual number of matching paths.
    public func completePath(into outputName: UnsafeMutablePointer<String>? = nil, caseSensitive: Bool, matchesInto outputArray: UnsafeMutablePointer<[String]>? = nil, filterTypes: [String]? = nil) -> Int

    /// Returns an array containing substrings from the string
    /// that have been divided by characters in the given set.
    public func components(separatedBy separator: CharacterSet) -> [String]

    /// Returns a representation of the string as a C string
    /// using a given encoding.
    public func cString(using encoding: String.Encoding) -> [CChar]?

    /// A string created by normalizing the string's contents using Form D.
    public var decomposedStringWithCanonicalMapping: String { get }

    /// A string created by normalizing the string's contents using Form KD.
    public var decomposedStringWithCompatibilityMapping: String { get }

    /// Enumerates all the lines in a string.
    public func enumerateLines(invoking body: @escaping (_ line: String, _ stop: inout Bool) -> Void)

    /// The fastest encoding to which the string can be converted without loss
    /// of information.
    public var fastestEncoding: String.Encoding { get }

    /// Converts the `String`'s content to a given encoding and
    /// stores them in a buffer.
    /// - Note: will store a maximum of `min(buffer.count, maxLength)` bytes.
    public func getCString(_ buffer: inout [CChar], maxLength: Int, encoding: String.Encoding) -> Bool

    /// An unsigned integer that can be used as a hash table address.
    public var hash: Int { get }

    /// Returns the number of bytes required to store the
    /// `String` in a given encoding.
    public func lengthOfBytes(using encoding: String.Encoding) -> Int

    /// Compares the string and the given string using a case-insensitive,
    /// localized, comparison.
    public func localizedCaseInsensitiveCompare<T>(_ aString: T) -> ComparisonResult where T : StringProtocol

    /// Compares the string and the given string using a localized comparison.
    public func localizedCompare<T>(_ aString: T) -> ComparisonResult where T : StringProtocol

    /// Compares the string and the given string as sorted by the Finder.
    public func localizedStandardCompare<T>(_ string: T) -> ComparisonResult where T : StringProtocol

    /// Returns the maximum number of bytes needed to store the
    /// `String` in a given encoding.
    public func maximumLengthOfBytes(using encoding: String.Encoding) -> Int

    /// A string created by normalizing the string's contents using Form C.
    public var precomposedStringWithCanonicalMapping: String { get }

    /// A string created by normalizing the string's contents using Form KC.
    public var precomposedStringWithCompatibilityMapping: String { get }

    /// Parses the `String` as a text representation of a
    /// property list, returning an NSString, NSData, NSArray, or
    /// NSDictionary object, according to the topmost element.
    public func propertyList() -> Any

    /// Returns a dictionary object initialized with the keys and
    /// values found in the `String`.
    public func propertyListFromStringsFileFormat() -> [String : String]

    /// Returns a Boolean value indicating whether the string contains the given
    /// string, taking the current locale into account.
    ///
    /// This is the most appropriate method for doing user-level string searches,
    /// similar to how searches are done generally in the system.  The search is
    /// locale-aware, case and diacritic insensitive.  The exact list of search
    /// options applied may change over time.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public func localizedStandardContains<T>(_ string: T) -> Bool where T : StringProtocol

    /// The smallest encoding to which the string can be converted without
    /// loss of information.
    public var smallestEncoding: String.Encoding { get }

    /// Returns a new string created by replacing all characters in the string
    /// not in the specified set with percent encoded characters.
    public func addingPercentEncoding(withAllowedCharacters allowedCharacters: CharacterSet) -> String?

    /// Returns a string created by appending a string constructed from a given
    /// format string and the following arguments.
    public func appendingFormat<T>(_ format: T, _ arguments: any CVarArg...) -> String where T : StringProtocol

    /// Returns a new string created by appending the given string.
    @inlinable public func appending(_ other: some StringProtocol) -> String

    /// Returns a string with the given character folding options
    /// applied.
    public func folding(options: String.CompareOptions = [], locale: Locale?) -> String

    /// Returns a new string formed from the `String` by either
    /// removing characters from the end, or by appending as many
    /// occurrences as necessary of a given pad string.
    public func padding<T>(toLength newLength: Int, withPad padString: T, startingAt padIndex: Int) -> String where T : StringProtocol

    /// A new string made from the string by replacing all percent encoded
    /// sequences with the matching UTF-8 characters.
    public var removingPercentEncoding: String? { get }

    /// Returns a new string in which the characters in a
    /// specified range of the `String` are replaced by a given string.
    @inlinable public func replacingCharacters<T, R>(in range: R, with replacement: T) -> String where T : StringProtocol, R : RangeExpression, R.Bound == String.Index

    /// Returns a new string in which all occurrences of a target
    /// string in a specified range of the string are replaced by
    /// another given string.
    public func replacingOccurrences<Target, Replacement>(of target: Target, with replacement: Replacement, options: String.CompareOptions = [], range searchRange: Range<Self.Index>? = nil) -> String where Target : StringProtocol, Replacement : StringProtocol

    /// Returns a new string made by removing from both ends of
    /// the `String` characters contained in a given character set.
    public func trimmingCharacters(in set: CharacterSet) -> String

    /// Perform string transliteration.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public func applyingTransform(_ transform: StringTransform, reverse: Bool) -> String?

    /// Performs linguistic analysis on the specified string by
    /// enumerating the specific range of the string, providing the
    /// Block with the located tags.
    public func enumerateLinguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: NSLinguisticTagger.Options = [], orthography: NSOrthography? = nil, invoking body: (String, Range<Self.Index>, Range<Self.Index>, inout Bool) -> Void) where T : StringProtocol, R : RangeExpression, R.Bound == String.Index

    /// Enumerates the substrings of the specified type in the specified range of
    /// the string.
    ///
    /// Mutation of a string value while enumerating its substrings is not
    /// supported. If you need to mutate a string from within `body`, convert
    /// your string to an `NSMutableString` instance and then call the
    /// `enumerateSubstrings(in:options:using:)` method.
    ///
    /// - Parameters:
    ///   - range: The range within the string to enumerate substrings.
    ///   - opts: Options specifying types of substrings and enumeration styles.
    ///     If `opts` is omitted or empty, `body` is called a single time with
    ///     the range of the string specified by `range`.
    ///   - body: The closure executed for each substring in the enumeration. The
    ///     closure takes four arguments:
    ///     - The enumerated substring. If `substringNotRequired` is included in
    ///       `opts`, this parameter is `nil` for every execution of the
    ///       closure.
    ///     - The range of the enumerated substring in the string that
    ///       `enumerate(in:options:_:)` was called on.
    ///     - The range that includes the substring as well as any separator or
    ///       filler characters that follow. For instance, for lines,
    ///       `enclosingRange` contains the line terminators. The enclosing
    ///       range for the first string enumerated also contains any characters
    ///       that occur before the string. Consecutive enclosing ranges are
    ///       guaranteed not to overlap, and every single character in the
    ///       enumerated range is included in one and only one enclosing range.
    ///     - An `inout` Boolean value that the closure can use to stop the
    ///       enumeration by setting `stop = true`.
    public func enumerateSubstrings<R>(in range: R, options opts: String.EnumerationOptions = [], _ body: @escaping (_ substring: String?, _ substringRange: Range<Self.Index>, _ enclosingRange: Range<Self.Index>, inout Bool) -> Void) where R : RangeExpression, R.Bound == String.Index

    /// Writes the given `range` of characters into `buffer` in a given
    /// `encoding`, without any allocations.  Does not NULL-terminate.
    ///
    /// - Parameter buffer: A buffer into which to store the bytes from
    ///   the receiver. The returned bytes are not NUL-terminated.
    ///
    /// - Parameter maxBufferCount: The maximum number of bytes to write
    ///   to buffer.
    ///
    /// - Parameter usedBufferCount: The number of bytes used from
    ///   buffer. Pass `nil` if you do not need this value.
    ///
    /// - Parameter encoding: The encoding to use for the returned bytes.
    ///
    /// - Parameter options: A mask to specify options to use for
    ///   converting the receiver's contents to `encoding` (if conversion
    ///   is necessary).
    ///
    /// - Parameter range: The range of characters in the receiver to get.
    ///
    /// - Parameter leftover: The remaining range. Pass `nil` If you do
    ///   not need this value.
    ///
    /// - Returns: `true` if some characters were converted, `false` otherwise.
    ///
    /// - Note: Conversion stops when the buffer fills or when the
    ///   conversion isn't possible due to the chosen encoding.
    ///
    /// - Note: will get a maximum of `min(buffer.count, maxLength)` bytes.
    public func getBytes<R>(_ buffer: inout [UInt8], maxLength maxBufferCount: Int, usedLength usedBufferCount: UnsafeMutablePointer<Int>, encoding: String.Encoding, options: String.EncodingConversionOptions = [], range: R, remaining leftover: UnsafeMutablePointer<Range<Self.Index>>) -> Bool where R : RangeExpression, R.Bound == String.Index

    /// Returns by reference the beginning of the first line and
    /// the end of the last line touched by the given range.
    public func getLineStart(_ start: UnsafeMutablePointer<Self.Index>, end: UnsafeMutablePointer<Self.Index>, contentsEnd: UnsafeMutablePointer<Self.Index>, for range: some RangeExpression<String.Index>)

    /// Returns by reference the beginning of the first paragraph
    /// and the end of the last paragraph touched by the given range.
    public func getParagraphStart(_ start: UnsafeMutablePointer<Self.Index>, end: UnsafeMutablePointer<Self.Index>, contentsEnd: UnsafeMutablePointer<Self.Index>, for range: some RangeExpression<String.Index>)

    /// Returns an array of linguistic tags for the specified
    /// range and requested tags within the receiving string.
    public func linguisticTags<T, R>(in range: R, scheme tagScheme: T, options opts: NSLinguisticTagger.Options = [], orthography: NSOrthography? = nil, tokenRanges: UnsafeMutablePointer<[Range<Self.Index>]>? = nil) -> [String] where T : StringProtocol, R : RangeExpression, R.Bound == String.Index

    /// Returns the range in the `String` of the composed
    /// character sequence located at a given index.
    public func rangeOfComposedCharacterSequence(at anIndex: Self.Index) -> Range<Self.Index>

    /// Returns the range in the string of the composed character
    /// sequences for a given range.
    public func rangeOfComposedCharacterSequences<R>(for range: R) -> Range<Self.Index> where R : RangeExpression, R.Bound == String.Index

    /// Finds and returns the range of the first occurrence of a
    /// given string within a given range of the `String`, subject to
    /// given options, using the specified locale, if any.
    public func range<T>(of aString: T, options mask: String.CompareOptions = [], range searchRange: Range<Self.Index>? = nil, locale: Locale? = nil) -> Range<Self.Index>? where T : StringProtocol

    /// Finds and returns the range of the first occurrence of a given string,
    /// taking the current locale into account.  Returns `nil` if the string was
    /// not found.
    ///
    /// This is the most appropriate method for doing user-level string searches,
    /// similar to how searches are done generally in the system.  The search is
    /// locale-aware, case and diacritic insensitive.  The exact list of search
    /// options applied may change over time.
    @available(macOS 10.11, iOS 9.0, watchOS 2.0, tvOS 9.0, *)
    public func localizedStandardRange<T>(of string: T) -> Range<Self.Index>? where T : StringProtocol

    /// Returns `true` if `other` is non-empty and contained within `self` by
    /// case-sensitive, non-literal search. Otherwise, returns `false`.
    ///
    /// Equivalent to `self.range(of: other) != nil`
    public func contains<T>(_ other: T) -> Bool where T : StringProtocol

    /// Returns a Boolean value indicating whether the given string is non-empty
    /// and contained within this string by case-insensitive, non-literal
    /// search, taking into account the current locale.
    ///
    /// Locale-independent case-insensitive operation, and other needs, can be
    /// achieved by calling `range(of:options:range:locale:)`.
    ///
    /// Equivalent to:
    ///
    ///     range(of: other, options: .caseInsensitiveSearch,
    ///           locale: Locale.current) != nil
    public func localizedCaseInsensitiveContains<T>(_ other: T) -> Bool where T : StringProtocol
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension StringProtocol {

    /// Returns a new string containing the characters of the
    /// `String` from the one at a given index to the end.
    @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range from' operator.")
    public func substring(from index: Self.Index) -> String

    /// Returns a new string containing the characters of the
    /// `String` up to, but not including, the one at a given index.
    @available(swift, deprecated: 4.0, message: "Please use String slicing subscript with a 'partial range upto' operator.")
    public func substring(to index: Self.Index) -> String

    /// Returns a string object containing the characters of the
    /// `String` that lie within a given range.
    @available(swift, deprecated: 4.0, message: "Please use String slicing subscript.")
    public func substring(with aRange: Range<Self.Index>) -> String
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSIndexSet : Sequence {

    /// Return an *iterator* over the elements of this *sequence*.
    ///
    /// - Complexity: O(1).
    public func makeIterator() -> NSIndexSetIterator

    /// A value less than or equal to the number of elements in the collection.
    ///
    /// - Complexity: O(1).
    @nonobjc public var underestimatedCount: Int { get }

    /// A type representing the sequence's elements.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Element = NSIndexSetIterator.Element

    /// A type that provides the sequence's iteration interface and
    /// encapsulates its iteration state.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias Iterator = NSIndexSetIterator
}

@available(macOS 12, iOS 15, tvOS 15, watchOS 8, *)
extension InlinePresentationIntent : Hashable, Codable {
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Timer {

    /// Returns a publisher that repeatedly emits the current date on the given interval.
    ///
    /// - Parameters:
    ///   - interval: The time interval on which to publish events. For example, a value of `0.5` publishes an event approximately every half-second.
    ///   - tolerance: The allowed timing variance when emitting events. Defaults to `nil`, which allows any variance.
    ///   - runLoop: The run loop on which the timer runs.
    ///   - mode: The run loop mode in which to run the timer.
    ///   - options: Scheduler options passed to the timer. Defaults to `nil`.
    /// - Returns: A publisher that repeatedly emits the current date on the given interval.
    public static func publish(every interval: TimeInterval, tolerance: TimeInterval? = nil, on runLoop: RunLoop, in mode: RunLoop.Mode, options: RunLoop.SchedulerOptions? = nil) -> Timer.TimerPublisher

    /// A publisher that repeatedly emits the current date on a given interval.
    final public class TimerPublisher : ConnectablePublisher {

        /// The kind of values published by this publisher.
        public typealias Output = Date

        /// The kind of errors this publisher might publish.
        ///
        /// Use `Never` if this `Publisher` does not publish errors.
        public typealias Failure = Never

        final public let interval: TimeInterval

        final public let tolerance: TimeInterval?

        final public let runLoop: RunLoop

        final public let mode: RunLoop.Mode

        final public let options: RunLoop.SchedulerOptions?

        /// Creates a publisher that repeatedly emits the current date on the given interval.
        ///
        /// - Parameters:
        ///   - interval: The interval on which to publish events.
        ///   - tolerance: The allowed timing variance when emitting events. Defaults to `nil`, which allows any variance.
        ///   - runLoop: The run loop on which the timer runs.
        ///   - mode: The run loop mode in which to run the timer.
        ///   - options: Scheduler options passed to the timer. Defaults to `nil`.
        public init(interval: TimeInterval, tolerance: TimeInterval? = nil, runLoop: RunLoop, mode: RunLoop.Mode, options: RunLoop.SchedulerOptions? = nil)

        @objc deinit

        /// Connects to the publisher, allowing it to produce elements, and returns an instance with which to cancel publishing.
        ///
        /// - Returns: A ``Cancellable`` instance that you use to cancel publishing.
        final public func connect() -> any Cancellable

        /// Attaches the specified subscriber to this publisher.
        ///
        /// Implementations of ``Publisher`` must implement this method.
        ///
        /// The provided implementation of ``Publisher/subscribe(_:)-4u8kn``calls this method.
        ///
        /// - Parameter subscriber: The subscriber to attach to this ``Publisher``, after which it can receive values.
        final public func receive<S>(subscriber: S) where S : Subscriber, S.Failure == Never, S.Input == Date
    }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSURL {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "NSURL.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
extension AsyncSequence where Self.Element == UInt8 {

    /**
     A non-blocking sequence of `UnicodeScalars` created by decoding the elements of `self` as UTF8.
     */
    @available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, *)
    public var unicodeScalars: AsyncUnicodeScalarSequence<Self> { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension _NSRange : Hashable {

    /// Hashes the essential components of this value by feeding them into the
    /// given hasher.
    ///
    /// Implement this method to conform to the `Hashable` protocol. The
    /// components used for hashing must be the same as the components compared
    /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
    /// with each of these components.
    ///
    /// - Important: In your implementation of `hash(into:)`,
    ///   don't call `finalize()` on the `hasher` instance provided,
    ///   or replace it with a different instance.
    ///   Doing so may become a compile-time error in the future.
    ///
    /// - Parameter hasher: The hasher to use when combining the components
    ///   of this instance.
    @inlinable public func hash(into hasher: inout Hasher)

    /// Returns a Boolean value indicating whether two values are equal.
    ///
    /// Equality is the inverse of inequality. For any values `a` and `b`,
    /// `a == b` implies that `a != b` is `false`.
    ///
    /// - Parameters:
    ///   - lhs: A value to compare.
    ///   - rhs: Another value to compare.
    @inlinable public static func == (lhs: NSRange, rhs: NSRange) -> Bool

    /// The hash value.
    ///
    /// Hash values are not guaranteed to be equal across different executions of
    /// your program. Do not save hash values to use during a future execution.
    ///
    /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
    ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
    ///   The compiler provides an implementation for `hashValue` for you.
    public var hashValue: Int { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension _NSRange : CustomStringConvertible, CustomDebugStringConvertible {

    /// A textual representation of this instance.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(describing:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `description` property for types that conform to
    /// `CustomStringConvertible`:
    ///
    ///     struct Point: CustomStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var description: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(describing: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `description` property.
    public var description: String { get }

    /// A textual representation of this instance, suitable for debugging.
    ///
    /// Calling this property directly is discouraged. Instead, convert an
    /// instance of any type to a string by using the `String(reflecting:)`
    /// initializer. This initializer works with any type, and uses the custom
    /// `debugDescription` property for types that conform to
    /// `CustomDebugStringConvertible`:
    ///
    ///     struct Point: CustomDebugStringConvertible {
    ///         let x: Int, y: Int
    ///
    ///         var debugDescription: String {
    ///             return "(\(x), \(y))"
    ///         }
    ///     }
    ///
    ///     let p = Point(x: 21, y: 30)
    ///     let s = String(reflecting: p)
    ///     print(s)
    ///     // Prints "(21, 30)"
    ///
    /// The conversion of `p` to a string in the assignment to `s` uses the
    /// `Point` type's `debugDescription` property.
    public var debugDescription: String { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension _NSRange {

    public init?(_ string: String)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension _NSRange {

    @inlinable public var lowerBound: Int { get }

    @inlinable public var upperBound: Int { get }

    @inlinable public func contains(_ index: Int) -> Bool

    @inlinable public mutating func formUnion(_ other: NSRange)

    @inlinable public func union(_ other: NSRange) -> NSRange

    @inlinable public func intersection(_ other: NSRange) -> NSRange?
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension _NSRange {

    @inlinable public init<R>(_ region: R) where R : RangeExpression, R.Bound : FixedWidthInteger

    public init<R, S>(_ region: R, in target: S) where R : RangeExpression, S : StringProtocol, R.Bound == String.Index

    @available(swift, deprecated: 4, message: "Use Range.init(_:) instead")
    public func toRange() -> Range<Int>?
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Range where Bound : BinaryInteger {

    @inlinable public init?(_ range: NSRange)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Range where Bound == Int {

    @inlinable public init?(_ range: NSRange)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Range where Bound == String.Index {

    public init?(_ range: NSRange, in string: String)

    @available(macOS 10.15, iOS 13, tvOS 13, watchOS 6, *)
    public init?<S>(_ range: NSRange, in string: S) where S : StringProtocol
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension _NSRange : CustomReflectable {

    /// The custom mirror for this instance.
    ///
    /// If this type has value semantics, the mirror should be unaffected by
    /// subsequent mutations of the instance.
    public var customMirror: Mirror { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension _NSRange {

    /// A custom playground Quick Look for this instance.
    ///
    /// If this type has value semantics, the `PlaygroundQuickLook` instance
    /// should be unaffected by subsequent mutations.
    @available(*, deprecated, message: "NSRange.customPlaygroundQuickLook will be removed in a future Swift version")
    public var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension _NSRange : Codable {

    /// Creates a new instance by decoding from the given decoder.
    ///
    /// This initializer throws an error if reading from the decoder fails, or
    /// if the data read is corrupted or otherwise invalid.
    ///
    /// - Parameter decoder: The decoder to read data from.
    public init(from decoder: any Decoder) throws

    /// Encodes this value into the given encoder.
    ///
    /// If the value fails to encode anything, `encoder` will encode an empty
    /// keyed container in its place.
    ///
    /// This function throws an error if any values are invalid for the given
    /// encoder's format.
    ///
    /// - Parameter encoder: The encoder to write data to.
    public func encode(to encoder: any Encoder) throws
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension NotificationCenter {

    /// A protocol for creating types that you can post to a notification center, which posts them to an arbitrary isolation.
    ///
    /// You post types conforming to `AsyncMessage` to a notification center using `post(_:subject:)` and observe them with `addObserver(of:for:using:)`.
    ///
    /// The notification center delivers `AsyncMessage` types asynchronously when posted. Asynchronous delivery isn't suitable
    /// for messages with time-critical deliveries, such as a message that must have its observers called before a certain
    /// action takes place.
    ///
    /// For types that post on the main actor, use ``MainActorMessage``.
    ///
    /// Each `AsyncMessage` is associated with a specific `Subject` type.
    ///
    /// For example, an `AsyncMessage` associated with the type `Event` could use the following declaration:
    ///
    /// ```swift
    /// struct EventDidStart: NotificationCenter.AsyncMessage {
    ///     typealias Subject = Event
    /// }
    /// ```
    ///
    /// `AsyncMessage` can use an optional ``MessageIdentifier`` type for context-aware observer registration:
    ///
    /// ```swift
    /// extension NotificationCenter.MessageIdentifier where Self == NotificationCenter.BaseMessageIdentifier<EventDidStart> {
    ///     static var didStart: Self { .init() }
    /// }
    /// ```
    ///
    /// With this identifier, observers can receive information about a specific instance by registering for this message with a ``NotificationCenter``:
    ///
    /// ```swift
    /// let observerToken = NotificationCenter.default.addObserver(of: importantEvent, for: .didStart)
    /// ````
    ///
    /// Or an observer can receive information about any instance with:
    ///
    /// ```swift
    /// let observerToken = NotificationCenter.default.addObserver(of: Event.self, for: .didStart)
    /// ```
    ///
    /// The notification center ties observation the lifetime of the returned ``NotificationCenter/ObservationToken`` and automatically de-registers the observer if the token
    /// goes out of scope. You can also remove observation explicitly:
    ///
    /// ```swift
    /// NotificationCenter.default.removeObserver(observerToken)
    /// ```
    ///
    /// ### Notification Interoperability
    ///
    /// `AsyncMessage` includes optional interoperability with ``Notification``, enabling posters and observers of both types
    /// to pass information.
    ///
    /// It does this by offering a ``makeMessage(_:)`` method that collects values from a ``Notification``'s ``Notification/userInfo`` and populates properties on a new message.
    /// In the other direction, a ``makeNotification(_:)`` method collects the message's defined properties and loads them into a new notification's ``Notification/userInfo`` dictionary.
    ///
    /// For example, if there exists a ``Notification`` posted on an arbitrary isolation identified by the ``Notification/Name`` `"eventDidFinish"` with a ``Notification/userInfo``
    /// dictionary containing the key `"duration"` as an ``NSNumber``, an app could post and observe the notification with the following ``AsyncMessage``:
    ///
    /// ```swift
    /// struct EventDidFinish: NotificationCenter.AsyncMessage {
    ///     typealias Subject = Event
    ///     static var name: Notification.Name { Notification.Name("eventDidFinish") }
    ///
    ///     var duration: Int
    ///
    ///     static func makeNotification(_ message: Self) -> Notification {
    ///         return Notification(name: Self.name, userInfo: ["duration": NSNumber(message.duration)])
    ///     }
    ///
    ///     static func makeMessage(_ notification: Notification) -> Self? {
    ///         guard let userInfo = notification.userInfo,
    ///               let duration = userInfo["duration"] as? Int
    ///         else {
    ///             return nil
    ///         }
    ///
    ///         return Self(duration: duration)
    ///     }
    /// }
    /// ```
    ///
    /// With this definition, an observer for this `AsyncMessage` type receives information even if the poster used the ``Notification`` equivalent, and vice versa.
    public protocol AsyncMessage : Sendable {

        /// A type which you can optionally post and observe along with this `AsyncMessage`.
        associatedtype Subject

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        static var name: Notification.Name { get }

        /// Converts a posted notification into this asynchronous message type for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `AsyncMessage`, or `nil` if conversion is not possible.
        static func makeMessage(_ notification: Notification) -> Self?

        /// Converts a posted asynchronous message into a notification for any observers.
        ///
        /// To implement this method in your own `AsyncMessage` conformance, use the properties defined by the message to populate the ``Notification``'s ``Notification/userInfo``.
        /// - Parameters:
        ///   - message: The posted `AsyncMessage`.
        /// - Returns: The converted ``Notification``.
        static func makeNotification(_ message: Self) -> Notification
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension NotificationCenter {

    /// Adds an observer to a center for messages delivered asynchronously with a given subject and identifier.
    /// - Parameters:
    ///   - subject: The subject to observe. Specify a metatype to observe all values for a given type.
    ///   - identifier: An identifier representing a specific message type.
    ///   - observer: A closure to execute when receving a message.
    /// - Returns: A token representing the observation registration with the given notification center. Retain this token for as long as you need to receive messages.
    public func addObserver<Identifier, Message>(of subject: Message.Subject, for identifier: Identifier, using observer: @escaping @Sendable (Message) async -> Void) -> NotificationCenter.ObservationToken where Identifier : NotificationCenter.MessageIdentifier, Message : NotificationCenter.AsyncMessage, Message == Identifier.MessageType, Message.Subject : AnyObject

    /// Adds an observer to a center for messages delivered asynchronously with a given subject and message type.
    /// - Parameters:
    ///   - subject: The metatype to observe all values for a given type.
    ///   - identifier: An identifier representing a specific message type.
    ///   - observer: A closure to execute when receving a message.
    /// - Returns: A token representing the observation registration with the given notification center. Retain this token for as long as you need to receive messages.
    public func addObserver<Identifier, Message>(of subject: Message.Subject.Type, for identifier: Identifier, using observer: @escaping @Sendable (Message) async -> Void) -> NotificationCenter.ObservationToken where Identifier : NotificationCenter.MessageIdentifier, Message : NotificationCenter.AsyncMessage, Message == Identifier.MessageType

    /// Adds an observer to a center for messages delivered asynchronously with a given subject and message type.
    /// - Parameters:
    ///   - subject: The subject to observe. Specify a metatype to observe all values for a given type.
    ///   - messageType: The message type to be observed.
    ///   - observer: A closure to execute when receving a message.
    /// - Returns: A token representing the observation registration with the given notification center.  Retain this token for as long as you need to receive messages.
    public func addObserver<Message>(of subject: Message.Subject? = nil, for messageType: Message.Type, using observer: @escaping @Sendable (Message) async -> Void) -> NotificationCenter.ObservationToken where Message : NotificationCenter.AsyncMessage, Message.Subject : AnyObject

    /// Posts a given asynchronous message to the notification center.
    /// - Parameters:
    ///   - message: The message to post.
    ///   - subject: The subject instance that corresponds to the message.
    public func post<Message>(_ message: Message, subject: Message.Subject) where Message : NotificationCenter.AsyncMessage, Message.Subject : AnyObject

    /// Posts a given asynchronous message to the notification center.
    /// - Parameters:
    ///   - message: The message to post.
    public func post<Message>(_ message: Message) where Message : NotificationCenter.AsyncMessage
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension NotificationCenter {

    /// A protocol for creating types that you can post to a notification center and bind to the main actor.
    ///
    /// You post types conforming to  `MainActorMessage` to a notification center using `post(_:subject:)` and observe them with `addObserver(of:for:using:)`. The notification center delivers `MainActorMessage` types synchronously when posted.
    ///
    /// For types that post on an arbitrary isolation, use ``NotificationCenter/AsyncMessage``.
    ///
    /// Each `MainActorMessage` is associated with a specific `Subject` type.
    ///
    /// For example, a `MainActorMessage` associated with the type `Event` could use the following declaration:
    ///
    /// ```swift
    /// struct EventDidStart: NotificationCenter.MainActorMessage {
    ///     typealias Subject = Event
    /// }
    /// ```
    ///
    /// `MainActorMessage` can use an optional ``MessageIdentifier`` type for context-aware observer registration:
    ///
    /// ```swift
    /// extension NotificationCenter.MessageIdentifier where Self == NotificationCenter.BaseMessageIdentifier<EventDidStart> {
    ///     static var didStart: Self { .init() }
    /// }
    /// ```
    ///
    /// With this identifier, observers can receive information about a specific instance by registering for this message with a ``NotificationCenter``:
    ///
    /// ```swift
    /// let observerToken = NotificationCenter.default.addObserver(of: importantEvent, for: .didStart)
    /// ```
    ///
    /// Or an observer can receive information about any instance with:
    ///
    /// ```swift
    /// let observerToken = NotificationCenter.default.addObserver(of: Event.self, for: .didStart)
    /// ```
    ///
    /// The notification center ties observation the lifetime of the returned ``NotificationCenter/ObservationToken`` and automatically de-registers the observer if the token
    /// goes out of scope. You can also remove observation explicitly:
    ///
    /// ```swift
    /// NotificationCenter.default.removeObserver(observerToken)
    /// ```
    /// ### Notification Interoperability
    ///
    /// `MainActorMessage` includes optional interoperability with ``Notification``, enabling posters and observers of both types
    /// to pass information.
    ///
    /// It does this by offering a ``makeMessage(_:)`` method that collects values from a ``Notification``'s ``Notification/userInfo`` and populates properties on a new message.
    /// In the other direction, a ``makeNotification(_:)`` method collects the message's defined properties and loads them into a new notification's ``Notification/userInfo`` dictionary.
    ///
    /// For example, if there exists a ``Notification`` posted on `MainActor` identified by the ``Notification/Name`` `"eventDidFinish"` with a ``Notification/userInfo``
    /// dictionary containing the key `"duration"` as an ``NSNumber``, an app could post and observe the notification with the following ``MainActorMessage``:
    ///
    /// ```swift
    /// struct EventDidFinish: NotificationCenter.MainActorMessage {
    ///     typealias Subject = Event
    ///     static var name: Notification.Name { Notification.Name("eventDidFinish") }
    ///
    ///     var duration: Int
    ///
    ///     static func makeNotification(_ message: Self) -> Notification {
    ///         return Notification(name: Self.name, userInfo: ["duration": NSNumber(message.duration)])
    ///     }
    ///
    ///     static func makeMessage(_ notification: Notification) -> Self? {
    ///         guard let userInfo = notification.userInfo,
    ///               let duration = userInfo["duration"] as? Int
    ///         else {
    ///             return nil
    ///         }
    ///
    ///         return Self(duration: duration)
    ///     }
    /// }
    /// ```
    ///
    /// With this definition, an observer for this `MainActorMessage` type receives information even if the poster used the ``Notification`` equivalent, and vice versa.
    public protocol MainActorMessage : SendableMetatype {

        /// A type which you can optionally post and observe along with this `MainActorMessage`.
        associatedtype Subject

        /// A optional name corresponding to this type, used to interoperate with notification posters and observers.
        static var name: Notification.Name { get }

        /// Converts a posted notification into this main actor message type for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, retrieve values from the ``Notification``'s ``Notification/userInfo`` and set them as properties on the message.
        /// - Parameter notification: The posted ``Notification``.
        /// - Returns: The converted `MainActorMessage` or `nil` if conversion is not possible.
        @MainActor static func makeMessage(_ notification: Notification) -> Self?

        /// Converts a posted main actor message into a notification for any observers.
        ///
        /// To implement this method in your own `MainActorMessage` conformance, use the properties defined by the message to populate the ``Notification``'s ``Notification/userInfo``.
        /// - Parameters:
        ///   - message: The posted `MainActorMessage`.
        /// - Returns: The converted ``Notification``.
        @MainActor static func makeNotification(_ message: Self) -> Notification
    }
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension NotificationCenter {

    /// Adds an observer to a center for messages delivered on the main actor with a given subject and identifier.
    ///
    /// - Parameters:
    ///   - subject: The subject to observe. Specify a metatype to observe all values for a given type.
    ///   - identifier: An identifier representing a specific message type.
    ///   - observer: A closure to execute when receving a message.
    /// - Returns: A token representing the observation registration with the given notification center.
    public func addObserver<Identifier, Message>(of subject: Message.Subject, for identifier: Identifier, using observer: @escaping @MainActor (Message) -> Void) -> NotificationCenter.ObservationToken where Identifier : NotificationCenter.MessageIdentifier, Message : NotificationCenter.MainActorMessage, Message == Identifier.MessageType, Message.Subject : AnyObject

    /// Adds an observer to a center for messages delivered on the main actor with a given subject and identifier.
    ///
    /// - Parameters:
    ///   - subject: The metatype to observe all values for a given type.
    ///   - identifier: An identifier representing a specific message type.
    ///   - observer: A closure to execute when receving a message.
    /// - Returns: A token representing the observation registration with the given notification center.
    public func addObserver<Identifier, Message>(of subject: Message.Subject.Type, for identifier: Identifier, using observer: @escaping @MainActor (Message) -> Void) -> NotificationCenter.ObservationToken where Identifier : NotificationCenter.MessageIdentifier, Message : NotificationCenter.MainActorMessage, Message == Identifier.MessageType

    /// Adds an observer to a center for messages delivered on the main actor with a given subject and message type.
    /// - Parameters:
    ///   - subject: The subject to be observed. Specify a metatype to observe all values for a given type.
    ///   - messageType: The message type to be observed.
    ///   - observer: A closure to execute when receving a message.
    /// - Returns: A token representing the observation registration with the given notification center.
    public func addObserver<Message>(of subject: Message.Subject? = nil, for messageType: Message.Type, using observer: @escaping @MainActor (Message) -> Void) -> NotificationCenter.ObservationToken where Message : NotificationCenter.MainActorMessage, Message.Subject : AnyObject

    /// Posts a given main actor message to the notification center.
    /// - Parameters:
    ///   - message: The message to post.
    ///   - subject: The subject instance that corresponds to the message.
    @MainActor public func post<Message>(_ message: Message, subject: Message.Subject) where Message : NotificationCenter.MainActorMessage, Message.Subject : AnyObject

    /// Posts a given main actor message to the notification center.
    /// - Parameters:
    ///   - message: The message to post.
    @MainActor public func post<Message>(_ message: Message) where Message : NotificationCenter.MainActorMessage
}

@available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
extension NotificationCenter {

    /// An optional identifier to associate a given message with a given type.
    ///
    /// Implement a `MessageIdentifier` to provide a typed, ergonomic experience at the call point, as described in [SE-0299](https://github.com/swiftlang/swift-evolution/blob/main/proposals/0299-extend-generic-static-member-lookup.md).
    ///
    /// For example, given `ExampleMessage` with a `Subject` called `ExampleSubject`:
    ///
    /// ```swift
    /// extension NotificationCenter.MessageIdentifier where Self == NotificationCenter.BaseMessageIdentifier<ExampleMessage> {
    ///     static var eventDidOccur: Self { .init() }
    /// }
    /// ```
    ///
    /// This simplifies the call point for clients, as seen here:
    ///
    /// ```swift
    /// let token = center.addObserver(of: exampleSubject, for: .eventDidOccur) { ... }
    /// ```
    public protocol MessageIdentifier {

        associatedtype MessageType
    }

    /// A type for use when defining optional Message identifiers.
    ///
    /// See ``MessageIdentifier`` for an example of how to use this type when defining your own message identifiers.
    public struct BaseMessageIdentifier<MessageType> : NotificationCenter.MessageIdentifier, Sendable {

        public init() where MessageType : NotificationCenter.MainActorMessage

        public init() where MessageType : NotificationCenter.AsyncMessage
    }
}

extension NotificationCenter {

    /// A unique token representing a single observer registration in a notification center.
    ///
    /// You receive the `ObservationToken` type as a return value from `addObserver(of:for:using:)` and related methods.
    ///
    /// Retain the `ObservationToken` for as long as you need to continue observation, since observation ends when the token goes out of scope.
    /// You can also explicitly stop observing by passing the token to ``removeObserver(_:)-(ObservationToken)``.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public struct ObservationToken : Hashable, Sendable {

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: NotificationCenter.ObservationToken, b: NotificationCenter.ObservationToken) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    /// Stops the observation represented by the given observation token.
    ///
    /// - Parameter token: a unique token representing a specific observer in a specific notification center. You receive this type from prior calls to `addObserver(of:for:using:)`.
    @available(macOS 26.0, iOS 26.0, tvOS 26.0, watchOS 26.0, *)
    public func removeObserver(_ token: NotificationCenter.ObservationToken)
}

extension Bundle {

    /// Look up a localized string given a list of available languages.
    /// - Parameters:
    ///   - key: The key for the localized string to retrieve.
    ///   - value: A default value to return if a localized string for ``key`` cannot be found.
    ///   - tableName: The name of the strings file to search. If `nil`, the method uses tables in `Localizable.strings`.
    ///   - localizations: An array of `Locale.Language` corresponding to available localizations. Bundle compares the array against its available localizations, and uses the best result to retrieve the localized string. If empty, we treat it as no localization is available, and may return a fallback.
    /// - Returns: A localized version of the string designated by ``key`` in table ``tableName``.
    @available(macOS 15.4, iOS 18.4, tvOS 18.4, watchOS 11.4, visionOS 2.4, *)
    public func localizedString(forKey key: String, value: String?, table tableName: String?, localizations: [Locale.Language]) -> String
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension Scanner {

    public enum NumberRepresentation : Sendable {

        case decimal

        case hexadecimal

        /// Returns a Boolean value indicating whether two values are equal.
        ///
        /// Equality is the inverse of inequality. For any values `a` and `b`,
        /// `a == b` implies that `a != b` is `false`.
        ///
        /// - Parameters:
        ///   - lhs: A value to compare.
        ///   - rhs: Another value to compare.
        public static func == (a: Scanner.NumberRepresentation, b: Scanner.NumberRepresentation) -> Bool

        /// Hashes the essential components of this value by feeding them into the
        /// given hasher.
        ///
        /// Implement this method to conform to the `Hashable` protocol. The
        /// components used for hashing must be the same as the components compared
        /// in your type's `==` operator implementation. Call `hasher.combine(_:)`
        /// with each of these components.
        ///
        /// - Important: In your implementation of `hash(into:)`,
        ///   don't call `finalize()` on the `hasher` instance provided,
        ///   or replace it with a different instance.
        ///   Doing so may become a compile-time error in the future.
        ///
        /// - Parameter hasher: The hasher to use when combining the components
        ///   of this instance.
        public func hash(into hasher: inout Hasher)

        /// The hash value.
        ///
        /// Hash values are not guaranteed to be equal across different executions of
        /// your program. Do not save hash values to use during a future execution.
        ///
        /// - Important: `hashValue` is deprecated as a `Hashable` requirement. To
        ///   conform to `Hashable`, implement the `hash(into:)` requirement instead.
        ///   The compiler provides an implementation for `hashValue` for you.
        public var hashValue: Int { get }
    }

    public var currentIndex: String.Index

    public func scanInt(representation: Scanner.NumberRepresentation = .decimal) -> Int?

    public func scanInt32(representation: Scanner.NumberRepresentation = .decimal) -> Int32?

    public func scanInt64(representation: Scanner.NumberRepresentation = .decimal) -> Int64?

    public func scanUInt64(representation: Scanner.NumberRepresentation = .decimal) -> UInt64?

    public func scanFloat(representation: Scanner.NumberRepresentation = .decimal) -> Float?

    public func scanDouble(representation: Scanner.NumberRepresentation = .decimal) -> Double?

    public func scanDecimal() -> Decimal?

    public func scanString(_ searchString: String) -> String?

    public func scanCharacters(from set: CharacterSet) -> String?

    public func scanUpToString(_ substring: String) -> String?

    public func scanUpToCharacters(from set: CharacterSet) -> String?

    public func scanCharacter() -> Character?
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Int8 {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UInt8 {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Int16 {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UInt16 {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Int32 {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UInt32 {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Int64 {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UInt64 {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Int {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension UInt {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Float {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Double {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension Bool {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension CGFloat {

    @available(swift, deprecated: 4, renamed: "init(truncating:)")
    public init(_ number: NSNumber)

    public init(truncating number: NSNumber)

    public init?(exactly number: NSNumber)
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
extension NSNumber : ExpressibleByFloatLiteral, ExpressibleByIntegerLiteral, ExpressibleByBooleanLiteral {

    /// Create an instance initialized to `value`.
    @nonobjc required public convenience init(integerLiteral value: Int)

    /// Create an instance initialized to `value`.
    @nonobjc required public convenience init(floatLiteral value: Double)

    /// Create an instance initialized to `value`.
    @nonobjc required public convenience init(booleanLiteral value: Bool)

    /// A type that represents a Boolean literal, such as `Bool`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias BooleanLiteralType = Bool

    /// A type that represents a floating-point literal.
    ///
    /// Valid types for `FloatLiteralType` are `Float`, `Double`, and `Float80`
    /// where available.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias FloatLiteralType = Double

    /// A type that represents an integer literal.
    ///
    /// The standard library integer and floating-point types are all valid types
    /// for `IntegerLiteralType`.
    @available(iOS 8.0, tvOS 9.0, watchOS 2.0, macOS 10.10, *)
    public typealias IntegerLiteralType = Int
}

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public let kCFStringEncodingASCII: CFStringEncoding { get }

@available(macOS 10.10, iOS 8.0, watchOS 2.0, tvOS 9.0, *)
public var NSNotFound: Int

